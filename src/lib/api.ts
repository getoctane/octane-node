/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Octane API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost:8080".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration!: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch.default) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name!: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AddOnInputArgs
 */
export interface AddOnInputArgs {
    /**
     * 
     * @type {number}
     * @memberof AddOnInputArgs
     */
    price?: number;
    /**
     * 
     * @type {FeatureInputArgs}
     * @memberof AddOnInputArgs
     */
    feature?: FeatureInputArgs;
}
/**
 * 
 * @export
 * @interface BillingSpec
 */
export interface BillingSpec {
    /**
     * Time period that defines the billing cycle. One of `day`, `week`, `month`, `quarter`, or `year`.
     * @type {string}
     * @memberof BillingSpec
     */
    period: string;
    /**
     * Strategy for determining when a billing cycle starts and ends. One of `calendar` or `subscription_date`
     * @type {string}
     * @memberof BillingSpec
     */
    cycleEnd?: string;
    /**
     * Time length of the grace period between the end of a billing cycle and invoice generation. *NOTE*: The specified length is unitless. Unit is designated with the `invoice_grace_period_unit` field.
     * @type {number}
     * @memberof BillingSpec
     */
    invoiceGracePeriodLength?: number;
    /**
     * Time length unit of the grace period between the end of a billing cycle and invoice generation. One of `minute`, `hour`, `day`. Maximum grace period is 2 days.
     * @type {string}
     * @memberof BillingSpec
     */
    invoiceGracePeriodUnit?: string;
    /**
     * Flag that controls whether or not invoices should be sent to customers.
     * @type {boolean}
     * @memberof BillingSpec
     */
    shouldSendInvoiceToCustomers?: boolean;
    /**
     * Defines the detail level of the invoice sent to customers. One of `basic` or `usage`.
     * @type {string}
     * @memberof BillingSpec
     */
    customerInvoiceDetailLevel?: string;
    /**
     * An amount threshold at which to automatically bill and charge customers. In place to minimize risk of inflated bills being unpaid.
     * @type {number}
     * @memberof BillingSpec
     */
    chargeThreshold?: number;
}
/**
 * 
 * @export
 * @interface ContactInfo
 */
export interface ContactInfo {
    /**
     * 
     * @type {string}
     * @memberof ContactInfo
     */
    addressLine1?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactInfo
     */
    addressLine2?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactInfo
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactInfo
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactInfo
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactInfo
     */
    zipcode?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactInfo
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactInfo
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactInfo
     */
    phone?: string;
}
/**
 * 
 * @export
 * @interface ContactInfoInputArgs
 */
export interface ContactInfoInputArgs {
    /**
     * 
     * @type {string}
     * @memberof ContactInfoInputArgs
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactInfoInputArgs
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactInfoInputArgs
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactInfoInputArgs
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactInfoInputArgs
     */
    zipcode?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactInfoInputArgs
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactInfoInputArgs
     */
    addressLine1?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactInfoInputArgs
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactInfoInputArgs
     */
    addressLine2?: string;
}
/**
 * 
 * @export
 * @interface Coupon
 */
export interface Coupon {
    /**
     * Unique name identifier.
     * @type {string}
     * @memberof Coupon
     */
    name: string;
}
/**
 * 
 * @export
 * @interface CreateCustomerArgs
 */
export interface CreateCustomerArgs {
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerArgs
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerArgs
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateCustomerArgs
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Array<CustomerMeasurementMappingInputArgs>}
     * @memberof CreateCustomerArgs
     */
    measurementMappings?: Array<CustomerMeasurementMappingInputArgs>;
    /**
     * 
     * @type {number}
     * @memberof CreateCustomerArgs
     */
    vendorId?: number;
    /**
     * 
     * @type {ContactInfoInputArgs}
     * @memberof CreateCustomerArgs
     */
    contactInfo?: ContactInfoInputArgs;
}
/**
 * 
 * @export
 * @interface CreatePricePlanArgs
 */
export interface CreatePricePlanArgs {
    /**
     * 
     * @type {DiscountInputArgs}
     * @memberof CreatePricePlanArgs
     */
    discount?: DiscountInputArgs;
    /**
     * 
     * @type {string}
     * @memberof CreatePricePlanArgs
     */
    description?: string;
    /**
     * 
     * @type {Array<AddOnInputArgs>}
     * @memberof CreatePricePlanArgs
     */
    addOns?: Array<AddOnInputArgs>;
    /**
     * 
     * @type {TrialInputArgs}
     * @memberof CreatePricePlanArgs
     */
    trial?: TrialInputArgs;
    /**
     * 
     * @type {Array<MeteredComponentInputArgs>}
     * @memberof CreatePricePlanArgs
     */
    meteredComponents?: Array<MeteredComponentInputArgs>;
    /**
     * 
     * @type {string}
     * @memberof CreatePricePlanArgs
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePricePlanArgs
     */
    couponName?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePricePlanArgs
     */
    period?: string;
    /**
     * 
     * @type {Array<FeatureInputArgs>}
     * @memberof CreatePricePlanArgs
     */
    features?: Array<FeatureInputArgs>;
    /**
     * 
     * @type {string}
     * @memberof CreatePricePlanArgs
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreatePricePlanArgs
     */
    tags?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof CreatePricePlanArgs
     */
    vendorId?: number;
    /**
     * 
     * @type {Array<LimitInputArgs>}
     * @memberof CreatePricePlanArgs
     */
    limits?: Array<LimitInputArgs>;
    /**
     * 
     * @type {number}
     * @memberof CreatePricePlanArgs
     */
    basePrice?: number;
}
/**
 * 
 * @export
 * @interface CreateSubscriptionArgs
 */
export interface CreateSubscriptionArgs {
    /**
     * 
     * @type {string}
     * @memberof CreateSubscriptionArgs
     */
    pricePlanName?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateSubscriptionArgs
     */
    pricePlanId?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateSubscriptionArgs
     */
    customerId?: number;
    /**
     * 
     * @type {DiscountInputArgs}
     * @memberof CreateSubscriptionArgs
     */
    discountOverride?: DiscountInputArgs;
    /**
     * 
     * @type {number}
     * @memberof CreateSubscriptionArgs
     */
    vendorId?: number;
    /**
     * 
     * @type {Date}
     * @memberof CreateSubscriptionArgs
     */
    effectiveAt?: Date;
}
/**
 * 
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * Unique name identifier of a customer
     * @type {string}
     * @memberof Customer
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    displayName?: string;
    /**
     * 
     * @type {ContactInfo}
     * @memberof Customer
     */
    contactInfo?: ContactInfo;
    /**
     * 
     * @type {Array<Object>}
     * @memberof Customer
     */
    measurementMappings?: Array<Object>;
}
/**
 * 
 * @export
 * @interface CustomerMeasurementMapping
 */
export interface CustomerMeasurementMapping {
    /**
     * The label key used to map measurements to customers.
     * @type {string}
     * @memberof CustomerMeasurementMapping
     */
    label: string;
    /**
     * A regex used to match the value of the associated label key.
     * @type {string}
     * @memberof CustomerMeasurementMapping
     */
    valueRegex?: string;
}
/**
 * 
 * @export
 * @interface CustomerMeasurementMappingInputArgs
 */
export interface CustomerMeasurementMappingInputArgs {
    /**
     * 
     * @type {string}
     * @memberof CustomerMeasurementMappingInputArgs
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerMeasurementMappingInputArgs
     */
    valueRegex?: string;
}
/**
 * 
 * @export
 * @interface CustomerPaymentGatewayCredentialInputArgs
 */
export interface CustomerPaymentGatewayCredentialInputArgs {
    /**
     * 
     * @type {string}
     * @memberof CustomerPaymentGatewayCredentialInputArgs
     */
    accountId?: string;
}
/**
 * 
 * @export
 * @interface CustomerStatus
 */
export interface CustomerStatus {
    /**
     * 
     * @type {string}
     * @memberof CustomerStatus
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface DeleteSubscriptionArgs
 */
export interface DeleteSubscriptionArgs {
    /**
     * 
     * @type {number}
     * @memberof DeleteSubscriptionArgs
     */
    vendorId?: number;
    /**
     * 
     * @type {number}
     * @memberof DeleteSubscriptionArgs
     */
    customerId?: number;
    /**
     * 
     * @type {Date}
     * @memberof DeleteSubscriptionArgs
     */
    expireAt?: Date;
}
/**
 * 
 * @export
 * @interface Discount
 */
export interface Discount {
    /**
     * Type of the discount. One of 'FLAT' or 'PERCENT'
     * @type {string}
     * @memberof Discount
     */
    discountType: string;
    /**
     * 
     * @type {number}
     * @memberof Discount
     */
    amount?: number;
}
/**
 * 
 * @export
 * @interface DiscountInputArgs
 */
export interface DiscountInputArgs {
    /**
     * 
     * @type {string}
     * @memberof DiscountInputArgs
     */
    discountType?: string;
    /**
     * 
     * @type {number}
     * @memberof DiscountInputArgs
     */
    amount?: number;
}
/**
 * 
 * @export
 * @interface Feature
 */
export interface Feature {
    /**
     * 
     * @type {string}
     * @memberof Feature
     */
    description?: string;
    /**
     * Unique name of a feature
     * @type {string}
     * @memberof Feature
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Feature
     */
    displayName?: string;
}
/**
 * 
 * @export
 * @interface FeatureInputArgs
 */
export interface FeatureInputArgs {
    /**
     * 
     * @type {string}
     * @memberof FeatureInputArgs
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof FeatureInputArgs
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FeatureInputArgs
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface LimitInputArgs
 */
export interface LimitInputArgs {
    /**
     * 
     * @type {number}
     * @memberof LimitInputArgs
     */
    limit?: number;
    /**
     * 
     * @type {FeatureInputArgs}
     * @memberof LimitInputArgs
     */
    feature?: FeatureInputArgs;
}
/**
 * 
 * @export
 * @interface Measurement
 */
export interface Measurement {
    /**
     * The unique name of the meter associated with this measurement
     * @type {string}
     * @memberof Measurement
     */
    meterName: string;
    /**
     * All times are parsed as `ISO-8601` formatted, UTC-based timestamps
     * @type {Date}
     * @memberof Measurement
     */
    time?: Date;
    /**
     * The raw value of the measurement
     * @type {number}
     * @memberof Measurement
     */
    value: number;
    /**
     * A set of key:value label pairs to supplement a measurement. Each meter defines its own set of primary and/or expected labels.
     * @type {{ [key: string]: string; }}
     * @memberof Measurement
     */
    labels?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface Meter
 */
export interface Meter {
    /**
     * Unique name identifier
     * @type {string}
     * @memberof Meter
     */
    name: string;
    /**
     * Name used for display in UI
     * @type {string}
     * @memberof Meter
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof Meter
     */
    description?: string;
    /**
     * Whether measurement values are to be considered incremental (versus a running total)
     * @type {boolean}
     * @memberof Meter
     */
    isIncremental?: boolean;
    /**
     * One of `COUNTER` or `GAUGE`
     * @type {string}
     * @memberof Meter
     */
    meterType?: string;
    /**
     * The expected unit for the measurement values associated with this meter.
     * @type {Object}
     * @memberof Meter
     */
    unitName?: Object;
    /**
     * 
     * @type {Array<Object>}
     * @memberof Meter
     */
    expectedLabels?: Array<Object>;
    /**
     * 
     * @type {Array<Object>}
     * @memberof Meter
     */
    primaryLabels?: Array<Object>;
}
/**
 * 
 * @export
 * @interface MeterInputArgs
 */
export interface MeterInputArgs {
    /**
     * 
     * @type {string}
     * @memberof MeterInputArgs
     */
    unitName?: string;
    /**
     * 
     * @type {string}
     * @memberof MeterInputArgs
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MeterInputArgs
     */
    primaryLabels?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof MeterInputArgs
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof MeterInputArgs
     */
    meterType?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MeterInputArgs
     */
    expectedLabels?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof MeterInputArgs
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof MeterInputArgs
     */
    vendorId?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MeterInputArgs
     */
    isIncremental?: boolean;
}
/**
 * 
 * @export
 * @interface MeterUpdateInputArgs
 */
export interface MeterUpdateInputArgs {
    /**
     * The expected unit for the measurement values associated with this meter.
     * @type {Object}
     * @memberof MeterUpdateInputArgs
     */
    unitName?: Object;
    /**
     * 
     * @type {Array<Object>}
     * @memberof MeterUpdateInputArgs
     */
    expectedLabels?: Array<Object>;
    /**
     * 
     * @type {Array<Object>}
     * @memberof MeterUpdateInputArgs
     */
    primaryLabels?: Array<Object>;
    /**
     * Unique name identifier
     * @type {string}
     * @memberof MeterUpdateInputArgs
     */
    name: string;
    /**
     * Name used for display in UI
     * @type {string}
     * @memberof MeterUpdateInputArgs
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof MeterUpdateInputArgs
     */
    description?: string;
    /**
     * Whether measurement values are to be considered incremental (versus a running total)
     * @type {boolean}
     * @memberof MeterUpdateInputArgs
     */
    isIncremental?: boolean;
    /**
     * One of `COUNTER` or `GAUGE`
     * @type {string}
     * @memberof MeterUpdateInputArgs
     */
    meterType?: string;
}
/**
 * 
 * @export
 * @interface MeteredComponent
 */
export interface MeteredComponent {
    /**
     * Unique name identifier
     * @type {Object}
     * @memberof MeteredComponent
     */
    meterName?: Object;
    /**
     * 
     * @type {PriceScheme}
     * @memberof MeteredComponent
     */
    priceScheme?: PriceScheme;
}
/**
 * 
 * @export
 * @interface MeteredComponentInputArgs
 */
export interface MeteredComponentInputArgs {
    /**
     * 
     * @type {string}
     * @memberof MeteredComponentInputArgs
     */
    meterName?: string;
    /**
     * 
     * @type {number}
     * @memberof MeteredComponentInputArgs
     */
    meterId?: number;
    /**
     * 
     * @type {PriceSchemeInputArgs}
     * @memberof MeteredComponentInputArgs
     */
    priceScheme?: PriceSchemeInputArgs;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Error name
     * @type {string}
     * @memberof ModelError
     */
    status?: string;
    /**
     * Errors
     * @type {any}
     * @memberof ModelError
     */
    errors?: any;
    /**
     * Error code
     * @type {number}
     * @memberof ModelError
     */
    code?: number;
    /**
     * Error message
     * @type {string}
     * @memberof ModelError
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface PaymentGatewayCredential
 */
export interface PaymentGatewayCredential {
    /**
     * One of `STRIPE` or `PADDLE`
     * @type {string}
     * @memberof PaymentGatewayCredential
     */
    paymentGateway: string;
    /**
     * Payment gateway account id associated with customer
     * @type {string}
     * @memberof PaymentGatewayCredential
     */
    accountId: string;
    /**
     * Unique name identifier of a customer
     * @type {string}
     * @memberof PaymentGatewayCredential
     */
    authToken?: string;
}
/**
 * 
 * @export
 * @interface PaymentGatewayCredentialInputArgs
 */
export interface PaymentGatewayCredentialInputArgs {
    /**
     * 
     * @type {string}
     * @memberof PaymentGatewayCredentialInputArgs
     */
    paymentGateway?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentGatewayCredentialInputArgs
     */
    authToken?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentGatewayCredentialInputArgs
     */
    accountId?: string;
}
/**
 * 
 * @export
 * @interface PriceInputArgs
 */
export interface PriceInputArgs {
    /**
     * 
     * @type {number}
     * @memberof PriceInputArgs
     */
    price?: number;
    /**
     * 
     * @type {number}
     * @memberof PriceInputArgs
     */
    cap?: number;
}
/**
 * 
 * @export
 * @interface PricePlan
 */
export interface PricePlan {
    /**
     * Unique name indentifier of a price plan
     * @type {string}
     * @memberof PricePlan
     */
    name: string;
    /**
     * UI-friendly name used for data display. Defaults to `name`.
     * @type {string}
     * @memberof PricePlan
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof PricePlan
     */
    description?: string;
    /**
     * Lowest denomination of currency. e.g. USD is represented as cents.
     * @type {number}
     * @memberof PricePlan
     */
    basePrice?: number;
    /**
     * Time period that defines the length of a price plan cycle. One of `day`, `week`, `month`, `quarter`, or `year`.
     * @type {string}
     * @memberof PricePlan
     */
    period: string;
    /**
     * 
     * @type {Coupon}
     * @memberof PricePlan
     */
    coupon?: Coupon;
    /**
     * 
     * @type {Array<MeteredComponent>}
     * @memberof PricePlan
     */
    meteredComponents?: Array<MeteredComponent>;
    /**
     * 
     * @type {Discount}
     * @memberof PricePlan
     */
    discount?: Discount;
    /**
     * 
     * @type {Array<Feature>}
     * @memberof PricePlan
     */
    features?: Array<Feature>;
    /**
     * 
     * @type {Array<PricePlanTag>}
     * @memberof PricePlan
     */
    tags?: Array<PricePlanTag>;
    /**
     * 
     * @type {Trial}
     * @memberof PricePlan
     */
    trial?: Trial;
}
/**
 * 
 * @export
 * @interface PricePlanTag
 */
export interface PricePlanTag {
    /**
     * Supplementary tag label that is associated with a specific version of a price plan
     * @type {string}
     * @memberof PricePlanTag
     */
    tag: string;
}
/**
 * 
 * @export
 * @interface PriceScheme
 */
export interface PriceScheme {
    /**
     * 
     * @type {string}
     * @memberof PriceScheme
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof PriceScheme
     */
    name?: string;
    /**
     * One of 'flat', 'volume', or 'stairstep'
     * @type {string}
     * @memberof PriceScheme
     */
    schemeType?: string;
    /**
     * Array of price tiers, each of which consists of `price` and `cap` key:value pairs
     * @type {Array<PriceTier>}
     * @memberof PriceScheme
     */
    prices?: Array<PriceTier>;
    /**
     * 
     * @type {string}
     * @memberof PriceScheme
     */
    timeUnitName?: string;
    /**
     * 
     * @type {string}
     * @memberof PriceScheme
     */
    unitName?: string;
}
/**
 * 
 * @export
 * @interface PriceSchemeInputArgs
 */
export interface PriceSchemeInputArgs {
    /**
     * 
     * @type {string}
     * @memberof PriceSchemeInputArgs
     */
    unitName?: string;
    /**
     * 
     * @type {Array<PriceInputArgs>}
     * @memberof PriceSchemeInputArgs
     */
    prices?: Array<PriceInputArgs>;
    /**
     * 
     * @type {string}
     * @memberof PriceSchemeInputArgs
     */
    timeUnitName?: string;
    /**
     * 
     * @type {string}
     * @memberof PriceSchemeInputArgs
     */
    schemeType?: string;
}
/**
 * 
 * @export
 * @interface PriceTier
 */
export interface PriceTier {
    /**
     * The price (in lowest currency denomination by which to charge, given that the usage is within the cap range.
     * @type {number}
     * @memberof PriceTier
     */
    price: number;
    /**
     * Cap of the tier, meaning that any subsequent usage will be bucketed into the following tier. If cap is undefined, it is effectively treated as Infinity.
     * @type {number}
     * @memberof PriceTier
     */
    cap?: number;
}
/**
 * 
 * @export
 * @interface RevenueResponse
 */
export interface RevenueResponse {
    /**
     * 
     * @type {number}
     * @memberof RevenueResponse
     */
    revenue?: number;
}
/**
 * 
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * Unique name identifier of a customer
     * @type {Object}
     * @memberof Subscription
     */
    customerName: Object;
    /**
     * Unique name indentifier of a price plan
     * @type {Object}
     * @memberof Subscription
     */
    pricePlanName: Object;
    /**
     * 
     * @type {BillingSpec}
     * @memberof Subscription
     */
    billingSpec?: BillingSpec;
    /**
     * Optional discount override for the associated subscription.
     * @type {Discount}
     * @memberof Subscription
     */
    discountOverride?: Discount;
    /**
     * Optional trial override for the associated subscription.
     * @type {Trial}
     * @memberof Subscription
     */
    trialOverride?: Trial;
    /**
     * Optional base price override for the associated subscription.
     * @type {number}
     * @memberof Subscription
     */
    basePriceOverride?: number;
    /**
     * ISO-8601 formatted timestamp that defines when the subscription should take effect. If this field is omitted, the subscription is effective upon creation.
     * @type {Date}
     * @memberof Subscription
     */
    effectiveAt?: Date;
}
/**
 * 
 * @export
 * @interface Trial
 */
export interface Trial {
    /**
     * 
     * @type {number}
     * @memberof Trial
     */
    timeLength?: number;
    /**
     * 
     * @type {string}
     * @memberof Trial
     */
    timeUnitName?: string;
    /**
     * 
     * @type {number}
     * @memberof Trial
     */
    credit?: number;
}
/**
 * 
 * @export
 * @interface TrialInputArgs
 */
export interface TrialInputArgs {
    /**
     * 
     * @type {number}
     * @memberof TrialInputArgs
     */
    timeLength?: number;
    /**
     * 
     * @type {number}
     * @memberof TrialInputArgs
     */
    credit?: number;
    /**
     * 
     * @type {string}
     * @memberof TrialInputArgs
     */
    timeUnitName?: string;
}
/**
 * 
 * @export
 * @interface UpdateCustomerArgs
 */
export interface UpdateCustomerArgs {
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomerArgs
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomerArgs
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateCustomerArgs
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Array<CustomerMeasurementMappingInputArgs>}
     * @memberof UpdateCustomerArgs
     */
    measurementMappings?: Array<CustomerMeasurementMappingInputArgs>;
    /**
     * 
     * @type {number}
     * @memberof UpdateCustomerArgs
     */
    vendorId?: number;
    /**
     * 
     * @type {ContactInfoInputArgs}
     * @memberof UpdateCustomerArgs
     */
    contactInfo?: ContactInfoInputArgs;
}
/**
 * 
 * @export
 * @interface UpdatePricePlanArgs
 */
export interface UpdatePricePlanArgs {
    /**
     * 
     * @type {DiscountInputArgs}
     * @memberof UpdatePricePlanArgs
     */
    discount?: DiscountInputArgs;
    /**
     * 
     * @type {string}
     * @memberof UpdatePricePlanArgs
     */
    description?: string;
    /**
     * 
     * @type {Array<AddOnInputArgs>}
     * @memberof UpdatePricePlanArgs
     */
    addOns?: Array<AddOnInputArgs>;
    /**
     * 
     * @type {TrialInputArgs}
     * @memberof UpdatePricePlanArgs
     */
    trial?: TrialInputArgs;
    /**
     * 
     * @type {Array<MeteredComponentInputArgs>}
     * @memberof UpdatePricePlanArgs
     */
    meteredComponents?: Array<MeteredComponentInputArgs>;
    /**
     * 
     * @type {string}
     * @memberof UpdatePricePlanArgs
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePricePlanArgs
     */
    couponName?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePricePlanArgs
     */
    period?: string;
    /**
     * 
     * @type {Array<FeatureInputArgs>}
     * @memberof UpdatePricePlanArgs
     */
    features?: Array<FeatureInputArgs>;
    /**
     * 
     * @type {string}
     * @memberof UpdatePricePlanArgs
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdatePricePlanArgs
     */
    tags?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof UpdatePricePlanArgs
     */
    vendorId?: number;
    /**
     * 
     * @type {Array<LimitInputArgs>}
     * @memberof UpdatePricePlanArgs
     */
    limits?: Array<LimitInputArgs>;
    /**
     * 
     * @type {number}
     * @memberof UpdatePricePlanArgs
     */
    basePrice?: number;
}
/**
 * 
 * @export
 * @interface UpdateSubscriptionArgs
 */
export interface UpdateSubscriptionArgs {
    /**
     * 
     * @type {string}
     * @memberof UpdateSubscriptionArgs
     */
    pricePlanName?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateSubscriptionArgs
     */
    pricePlanId?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateSubscriptionArgs
     */
    customerId?: number;
    /**
     * 
     * @type {DiscountInputArgs}
     * @memberof UpdateSubscriptionArgs
     */
    discountOverride?: DiscountInputArgs;
    /**
     * 
     * @type {number}
     * @memberof UpdateSubscriptionArgs
     */
    vendorId?: number;
    /**
     * 
     * @type {Date}
     * @memberof UpdateSubscriptionArgs
     */
    effectiveAt?: Date;
}
/**
 * 
 * @export
 * @interface Vendor
 */
export interface Vendor {
    /**
     * Unique name identifier of a Vendor
     * @type {string}
     * @memberof Vendor
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Vendor
     */
    displayName?: string;
    /**
     * 
     * @type {ContactInfo}
     * @memberof Vendor
     */
    contactInfo?: ContactInfo;
}
/**
 * 
 * @export
 * @interface VendorCreateArgs
 */
export interface VendorCreateArgs {
    /**
     * 
     * @type {ContactInfo}
     * @memberof VendorCreateArgs
     */
    contactInfo?: ContactInfo;
    /**
     * 
     * @type {string}
     * @memberof VendorCreateArgs
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof VendorCreateArgs
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof VendorCreateArgs
     */
    apiKey?: string;
}
/**
 * 
 * @export
 * @interface VendorUpdateInputArgs
 */
export interface VendorUpdateInputArgs {
    /**
     * 
     * @type {ContactInfo}
     * @memberof VendorUpdateInputArgs
     */
    contactInfo?: ContactInfo;
    /**
     * Unique name identifier of a Vendor
     * @type {string}
     * @memberof VendorUpdateInputArgs
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof VendorUpdateInputArgs
     */
    displayName?: string;
}
/**
 * CustomersApi - fetch parameter creator
 * @export
 */
export const CustomersApiFetchParamCreator = function (_configuration?: Configuration) {
    return {
        /**
         * Delete a customer by their unique name.
         * @summary Delete Customer
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameDelete(customerName: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerName' is not null or undefined
            if (customerName === null || customerName === undefined) {
                throw new RequiredError('customerName','Required parameter customerName was null or undefined when calling customersCustomerNameDelete.');
            }
            const localVarPath = `/customers/{customer_name}`
                .replace(`{${"customer_name"}}`, encodeURIComponent(String(customerName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a customer by their unique name.
         * @summary Get Customer
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameGet(customerName: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerName' is not null or undefined
            if (customerName === null || customerName === undefined) {
                throw new RequiredError('customerName','Required parameter customerName was null or undefined when calling customersCustomerNameGet.');
            }
            const localVarPath = `/customers/{customer_name}`
                .replace(`{${"customer_name"}}`, encodeURIComponent(String(customerName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch current cycle revenue for a customer and generate an invoice.
         * @summary Generate Current Invoice
         * @param {number} invoiceId 
         * @param {string} token 
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameInvoiceInvoiceIdTokenGet(invoiceId: number, token: string, customerName: string, options: any = {}): FetchArgs {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling customersCustomerNameInvoiceInvoiceIdTokenGet.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling customersCustomerNameInvoiceInvoiceIdTokenGet.');
            }
            // verify required parameter 'customerName' is not null or undefined
            if (customerName === null || customerName === undefined) {
                throw new RequiredError('customerName','Required parameter customerName was null or undefined when calling customersCustomerNameInvoiceInvoiceIdTokenGet.');
            }
            const localVarPath = `/customers/{customer_name}/invoice/{invoice_id}/{token}`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)))
                .replace(`{${"token"}}`, encodeURIComponent(String(token)))
                .replace(`{${"customer_name"}}`, encodeURIComponent(String(customerName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch all measurement mappings for a specific customer (by unique customer name).
         * @summary Get Measurement Mappings
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameMappingsGet(customerName: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerName' is not null or undefined
            if (customerName === null || customerName === undefined) {
                throw new RequiredError('customerName','Required parameter customerName was null or undefined when calling customersCustomerNameMappingsGet.');
            }
            const localVarPath = `/customers/{customer_name}/mappings`
                .replace(`{${"customer_name"}}`, encodeURIComponent(String(customerName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new measurement mapping for a customer. If no value_regex is passed, label existence is checked instead.
         * @summary Append Measurement Mapping
         * @param {CustomerMeasurementMappingInputArgs} body 
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameMappingsPost(body: CustomerMeasurementMappingInputArgs, customerName: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling customersCustomerNameMappingsPost.');
            }
            // verify required parameter 'customerName' is not null or undefined
            if (customerName === null || customerName === undefined) {
                throw new RequiredError('customerName','Required parameter customerName was null or undefined when calling customersCustomerNameMappingsPost.');
            }
            const localVarPath = `/customers/{customer_name}/mappings`
                .replace(`{${"customer_name"}}`, encodeURIComponent(String(customerName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerMeasurementMappingInputArgs" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add PaymentGatewayCredential for Customer
         * @param {CustomerPaymentGatewayCredentialInputArgs} body 
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNamePaymentGatewayCredentialsPost(body: CustomerPaymentGatewayCredentialInputArgs, customerName: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling customersCustomerNamePaymentGatewayCredentialsPost.');
            }
            // verify required parameter 'customerName' is not null or undefined
            if (customerName === null || customerName === undefined) {
                throw new RequiredError('customerName','Required parameter customerName was null or undefined when calling customersCustomerNamePaymentGatewayCredentialsPost.');
            }
            const localVarPath = `/customers/{customer_name}/payment_gateway_credentials`
                .replace(`{${"customer_name"}}`, encodeURIComponent(String(customerName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerPaymentGatewayCredentialInputArgs" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a single customer. To update Customer measurement mappings, use the `customers/{customer_name}/mappings` endpoint.
         * @summary Update Customer
         * @param {UpdateCustomerArgs} body 
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNamePut(body: UpdateCustomerArgs, customerName: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling customersCustomerNamePut.');
            }
            // verify required parameter 'customerName' is not null or undefined
            if (customerName === null || customerName === undefined) {
                throw new RequiredError('customerName','Required parameter customerName was null or undefined when calling customersCustomerNamePut.');
            }
            const localVarPath = `/customers/{customer_name}`
                .replace(`{${"customer_name"}}`, encodeURIComponent(String(customerName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateCustomerArgs" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch revenue of a customer from start_time and end_time.
         * @summary Get Customer Revenue
         * @param {string} customerName 
         * @param {Date} [startTime] 
         * @param {Date} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameRevenueGet(customerName: string, startTime?: Date, endTime?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'customerName' is not null or undefined
            if (customerName === null || customerName === undefined) {
                throw new RequiredError('customerName','Required parameter customerName was null or undefined when calling customersCustomerNameRevenueGet.');
            }
            const localVarPath = `/customers/{customer_name}/revenue`
                .replace(`{${"customer_name"}}`, encodeURIComponent(String(customerName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any).toISOString();
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch current cycle revenue for a customer and generate an invoice.
         * @summary Generate Current Invoice
         * @param {string} token 
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameSampleInvoiceTokenGet(token: string, customerName: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling customersCustomerNameSampleInvoiceTokenGet.');
            }
            // verify required parameter 'customerName' is not null or undefined
            if (customerName === null || customerName === undefined) {
                throw new RequiredError('customerName','Required parameter customerName was null or undefined when calling customersCustomerNameSampleInvoiceTokenGet.');
            }
            const localVarPath = `/customers/{customer_name}/sample_invoice/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)))
                .replace(`{${"customer_name"}}`, encodeURIComponent(String(customerName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the current status for a customer.
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameStatusGet(customerName: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerName' is not null or undefined
            if (customerName === null || customerName === undefined) {
                throw new RequiredError('customerName','Required parameter customerName was null or undefined when calling customersCustomerNameStatusGet.');
            }
            const localVarPath = `/customers/{customer_name}/status`
                .replace(`{${"customer_name"}}`, encodeURIComponent(String(customerName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a subscription for a specific customer (by customer name).
         * @summary Delete Subscription
         * @param {DeleteSubscriptionArgs} body 
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameSubscriptionDelete(body: DeleteSubscriptionArgs, customerName: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling customersCustomerNameSubscriptionDelete.');
            }
            // verify required parameter 'customerName' is not null or undefined
            if (customerName === null || customerName === undefined) {
                throw new RequiredError('customerName','Required parameter customerName was null or undefined when calling customersCustomerNameSubscriptionDelete.');
            }
            const localVarPath = `/customers/{customer_name}/subscription`
                .replace(`{${"customer_name"}}`, encodeURIComponent(String(customerName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeleteSubscriptionArgs" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a subscription for a specific customer (by customer name).
         * @summary Update Subscription
         * @param {UpdateSubscriptionArgs} body 
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameSubscriptionPut(body: UpdateSubscriptionArgs, customerName: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling customersCustomerNameSubscriptionPut.');
            }
            // verify required parameter 'customerName' is not null or undefined
            if (customerName === null || customerName === undefined) {
                throw new RequiredError('customerName','Required parameter customerName was null or undefined when calling customersCustomerNameSubscriptionPut.');
            }
            const localVarPath = `/customers/{customer_name}/subscription`
                .replace(`{${"customer_name"}}`, encodeURIComponent(String(customerName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateSubscriptionArgs" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all subscriptions for the customer.
         * @summary Get Subscriptions
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameSubscriptionsGet(customerName: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerName' is not null or undefined
            if (customerName === null || customerName === undefined) {
                throw new RequiredError('customerName','Required parameter customerName was null or undefined when calling customersCustomerNameSubscriptionsGet.');
            }
            const localVarPath = `/customers/{customer_name}/subscriptions`
                .replace(`{${"customer_name"}}`, encodeURIComponent(String(customerName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new subscription for a customer / price plan combination (by unique name).
         * @summary Create Subscription
         * @param {CreateSubscriptionArgs} body 
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameSubscriptionsPost(body: CreateSubscriptionArgs, customerName: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling customersCustomerNameSubscriptionsPost.');
            }
            // verify required parameter 'customerName' is not null or undefined
            if (customerName === null || customerName === undefined) {
                throw new RequiredError('customerName','Required parameter customerName was null or undefined when calling customersCustomerNameSubscriptionsPost.');
            }
            const localVarPath = `/customers/{customer_name}/subscriptions`
                .replace(`{${"customer_name"}}`, encodeURIComponent(String(customerName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateSubscriptionArgs" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all customers for a given vendor.
         * @summary Get All Customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersGet(options: any = {}): FetchArgs {
            const localVarPath = `/customers/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new customer.
         * @summary Create Customer
         * @param {CreateCustomerArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersPost(body: CreateCustomerArgs, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling customersPost.');
            }
            const localVarPath = `/customers/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateCustomerArgs" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomersApi - functional programming interface
 * @export
 */
export const CustomersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a customer by their unique name.
         * @summary Delete Customer
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameDelete(customerName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CustomersApiFetchParamCreator(configuration).customersCustomerNameDelete(customerName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch a customer by their unique name.
         * @summary Get Customer
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameGet(customerName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Customer> {
            const localVarFetchArgs = CustomersApiFetchParamCreator(configuration).customersCustomerNameGet(customerName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch current cycle revenue for a customer and generate an invoice.
         * @summary Generate Current Invoice
         * @param {number} invoiceId 
         * @param {string} token 
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameInvoiceInvoiceIdTokenGet(invoiceId: number, token: string, customerName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Error> {
            const localVarFetchArgs = CustomersApiFetchParamCreator(configuration).customersCustomerNameInvoiceInvoiceIdTokenGet(invoiceId, token, customerName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch all measurement mappings for a specific customer (by unique customer name).
         * @summary Get Measurement Mappings
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameMappingsGet(customerName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CustomerMeasurementMapping>> {
            const localVarFetchArgs = CustomersApiFetchParamCreator(configuration).customersCustomerNameMappingsGet(customerName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new measurement mapping for a customer. If no value_regex is passed, label existence is checked instead.
         * @summary Append Measurement Mapping
         * @param {CustomerMeasurementMappingInputArgs} body 
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameMappingsPost(body: CustomerMeasurementMappingInputArgs, customerName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerMeasurementMapping> {
            const localVarFetchArgs = CustomersApiFetchParamCreator(configuration).customersCustomerNameMappingsPost(body, customerName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Add PaymentGatewayCredential for Customer
         * @param {CustomerPaymentGatewayCredentialInputArgs} body 
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNamePaymentGatewayCredentialsPost(body: CustomerPaymentGatewayCredentialInputArgs, customerName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaymentGatewayCredential> {
            const localVarFetchArgs = CustomersApiFetchParamCreator(configuration).customersCustomerNamePaymentGatewayCredentialsPost(body, customerName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a single customer. To update Customer measurement mappings, use the `customers/{customer_name}/mappings` endpoint.
         * @summary Update Customer
         * @param {UpdateCustomerArgs} body 
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNamePut(body: UpdateCustomerArgs, customerName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Customer> {
            const localVarFetchArgs = CustomersApiFetchParamCreator(configuration).customersCustomerNamePut(body, customerName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch revenue of a customer from start_time and end_time.
         * @summary Get Customer Revenue
         * @param {string} customerName 
         * @param {Date} [startTime] 
         * @param {Date} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameRevenueGet(customerName: string, startTime?: Date, endTime?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RevenueResponse> {
            const localVarFetchArgs = CustomersApiFetchParamCreator(configuration).customersCustomerNameRevenueGet(customerName, startTime, endTime, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch current cycle revenue for a customer and generate an invoice.
         * @summary Generate Current Invoice
         * @param {string} token 
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameSampleInvoiceTokenGet(token: string, customerName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Error> {
            const localVarFetchArgs = CustomersApiFetchParamCreator(configuration).customersCustomerNameSampleInvoiceTokenGet(token, customerName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the current status for a customer.
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameStatusGet(customerName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerStatus> {
            const localVarFetchArgs = CustomersApiFetchParamCreator(configuration).customersCustomerNameStatusGet(customerName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a subscription for a specific customer (by customer name).
         * @summary Delete Subscription
         * @param {DeleteSubscriptionArgs} body 
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameSubscriptionDelete(body: DeleteSubscriptionArgs, customerName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CustomersApiFetchParamCreator(configuration).customersCustomerNameSubscriptionDelete(body, customerName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a subscription for a specific customer (by customer name).
         * @summary Update Subscription
         * @param {UpdateSubscriptionArgs} body 
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameSubscriptionPut(body: UpdateSubscriptionArgs, customerName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Subscription> {
            const localVarFetchArgs = CustomersApiFetchParamCreator(configuration).customersCustomerNameSubscriptionPut(body, customerName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all subscriptions for the customer.
         * @summary Get Subscriptions
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameSubscriptionsGet(customerName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Subscription>> {
            const localVarFetchArgs = CustomersApiFetchParamCreator(configuration).customersCustomerNameSubscriptionsGet(customerName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new subscription for a customer / price plan combination (by unique name).
         * @summary Create Subscription
         * @param {CreateSubscriptionArgs} body 
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameSubscriptionsPost(body: CreateSubscriptionArgs, customerName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Subscription> {
            const localVarFetchArgs = CustomersApiFetchParamCreator(configuration).customersCustomerNameSubscriptionsPost(body, customerName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all customers for a given vendor.
         * @summary Get All Customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Customer>> {
            const localVarFetchArgs = CustomersApiFetchParamCreator(configuration).customersGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new customer.
         * @summary Create Customer
         * @param {CreateCustomerArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersPost(body: CreateCustomerArgs, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Customer> {
            const localVarFetchArgs = CustomersApiFetchParamCreator(configuration).customersPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomersApi - factory interface
 * @export
 */
export const CustomersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete a customer by their unique name.
         * @summary Delete Customer
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameDelete(customerName: string, options?: any) {
            return CustomersApiFp(configuration).customersCustomerNameDelete(customerName, options)(fetch, basePath);
        },
        /**
         * Fetch a customer by their unique name.
         * @summary Get Customer
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameGet(customerName: string, options?: any) {
            return CustomersApiFp(configuration).customersCustomerNameGet(customerName, options)(fetch, basePath);
        },
        /**
         * Fetch current cycle revenue for a customer and generate an invoice.
         * @summary Generate Current Invoice
         * @param {number} invoiceId 
         * @param {string} token 
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameInvoiceInvoiceIdTokenGet(invoiceId: number, token: string, customerName: string, options?: any) {
            return CustomersApiFp(configuration).customersCustomerNameInvoiceInvoiceIdTokenGet(invoiceId, token, customerName, options)(fetch, basePath);
        },
        /**
         * Fetch all measurement mappings for a specific customer (by unique customer name).
         * @summary Get Measurement Mappings
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameMappingsGet(customerName: string, options?: any) {
            return CustomersApiFp(configuration).customersCustomerNameMappingsGet(customerName, options)(fetch, basePath);
        },
        /**
         * Create a new measurement mapping for a customer. If no value_regex is passed, label existence is checked instead.
         * @summary Append Measurement Mapping
         * @param {CustomerMeasurementMappingInputArgs} body 
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameMappingsPost(body: CustomerMeasurementMappingInputArgs, customerName: string, options?: any) {
            return CustomersApiFp(configuration).customersCustomerNameMappingsPost(body, customerName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add PaymentGatewayCredential for Customer
         * @param {CustomerPaymentGatewayCredentialInputArgs} body 
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNamePaymentGatewayCredentialsPost(body: CustomerPaymentGatewayCredentialInputArgs, customerName: string, options?: any) {
            return CustomersApiFp(configuration).customersCustomerNamePaymentGatewayCredentialsPost(body, customerName, options)(fetch, basePath);
        },
        /**
         * Update a single customer. To update Customer measurement mappings, use the `customers/{customer_name}/mappings` endpoint.
         * @summary Update Customer
         * @param {UpdateCustomerArgs} body 
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNamePut(body: UpdateCustomerArgs, customerName: string, options?: any) {
            return CustomersApiFp(configuration).customersCustomerNamePut(body, customerName, options)(fetch, basePath);
        },
        /**
         * Fetch revenue of a customer from start_time and end_time.
         * @summary Get Customer Revenue
         * @param {string} customerName 
         * @param {Date} [startTime] 
         * @param {Date} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameRevenueGet(customerName: string, startTime?: Date, endTime?: Date, options?: any) {
            return CustomersApiFp(configuration).customersCustomerNameRevenueGet(customerName, startTime, endTime, options)(fetch, basePath);
        },
        /**
         * Fetch current cycle revenue for a customer and generate an invoice.
         * @summary Generate Current Invoice
         * @param {string} token 
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameSampleInvoiceTokenGet(token: string, customerName: string, options?: any) {
            return CustomersApiFp(configuration).customersCustomerNameSampleInvoiceTokenGet(token, customerName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the current status for a customer.
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameStatusGet(customerName: string, options?: any) {
            return CustomersApiFp(configuration).customersCustomerNameStatusGet(customerName, options)(fetch, basePath);
        },
        /**
         * Delete a subscription for a specific customer (by customer name).
         * @summary Delete Subscription
         * @param {DeleteSubscriptionArgs} body 
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameSubscriptionDelete(body: DeleteSubscriptionArgs, customerName: string, options?: any) {
            return CustomersApiFp(configuration).customersCustomerNameSubscriptionDelete(body, customerName, options)(fetch, basePath);
        },
        /**
         * Update a subscription for a specific customer (by customer name).
         * @summary Update Subscription
         * @param {UpdateSubscriptionArgs} body 
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameSubscriptionPut(body: UpdateSubscriptionArgs, customerName: string, options?: any) {
            return CustomersApiFp(configuration).customersCustomerNameSubscriptionPut(body, customerName, options)(fetch, basePath);
        },
        /**
         * Get all subscriptions for the customer.
         * @summary Get Subscriptions
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameSubscriptionsGet(customerName: string, options?: any) {
            return CustomersApiFp(configuration).customersCustomerNameSubscriptionsGet(customerName, options)(fetch, basePath);
        },
        /**
         * Create a new subscription for a customer / price plan combination (by unique name).
         * @summary Create Subscription
         * @param {CreateSubscriptionArgs} body 
         * @param {string} customerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerNameSubscriptionsPost(body: CreateSubscriptionArgs, customerName: string, options?: any) {
            return CustomersApiFp(configuration).customersCustomerNameSubscriptionsPost(body, customerName, options)(fetch, basePath);
        },
        /**
         * Retrieve all customers for a given vendor.
         * @summary Get All Customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersGet(options?: any) {
            return CustomersApiFp(configuration).customersGet(options)(fetch, basePath);
        },
        /**
         * Create a new customer.
         * @summary Create Customer
         * @param {CreateCustomerArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersPost(body: CreateCustomerArgs, options?: any) {
            return CustomersApiFp(configuration).customersPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * CustomersApi - object-oriented interface
 * @export
 * @class CustomersApi
 * @extends {BaseAPI}
 */
export class CustomersApi extends BaseAPI {
    /**
     * Delete a customer by their unique name.
     * @summary Delete Customer
     * @param {string} customerName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public customersCustomerNameDelete(customerName: string, options?: any) {
        return CustomersApiFp(this.configuration).customersCustomerNameDelete(customerName, options)(this.fetch, this.basePath);
    }

    /**
     * Fetch a customer by their unique name.
     * @summary Get Customer
     * @param {string} customerName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public customersCustomerNameGet(customerName: string, options?: any) {
        return CustomersApiFp(this.configuration).customersCustomerNameGet(customerName, options)(this.fetch, this.basePath);
    }

    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * @summary Generate Current Invoice
     * @param {number} invoiceId 
     * @param {string} token 
     * @param {string} customerName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public customersCustomerNameInvoiceInvoiceIdTokenGet(invoiceId: number, token: string, customerName: string, options?: any) {
        return CustomersApiFp(this.configuration).customersCustomerNameInvoiceInvoiceIdTokenGet(invoiceId, token, customerName, options)(this.fetch, this.basePath);
    }

    /**
     * Fetch all measurement mappings for a specific customer (by unique customer name).
     * @summary Get Measurement Mappings
     * @param {string} customerName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public customersCustomerNameMappingsGet(customerName: string, options?: any) {
        return CustomersApiFp(this.configuration).customersCustomerNameMappingsGet(customerName, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new measurement mapping for a customer. If no value_regex is passed, label existence is checked instead.
     * @summary Append Measurement Mapping
     * @param {CustomerMeasurementMappingInputArgs} body 
     * @param {string} customerName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public customersCustomerNameMappingsPost(body: CustomerMeasurementMappingInputArgs, customerName: string, options?: any) {
        return CustomersApiFp(this.configuration).customersCustomerNameMappingsPost(body, customerName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Add PaymentGatewayCredential for Customer
     * @param {CustomerPaymentGatewayCredentialInputArgs} body 
     * @param {string} customerName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public customersCustomerNamePaymentGatewayCredentialsPost(body: CustomerPaymentGatewayCredentialInputArgs, customerName: string, options?: any) {
        return CustomersApiFp(this.configuration).customersCustomerNamePaymentGatewayCredentialsPost(body, customerName, options)(this.fetch, this.basePath);
    }

    /**
     * Update a single customer. To update Customer measurement mappings, use the `customers/{customer_name}/mappings` endpoint.
     * @summary Update Customer
     * @param {UpdateCustomerArgs} body 
     * @param {string} customerName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public customersCustomerNamePut(body: UpdateCustomerArgs, customerName: string, options?: any) {
        return CustomersApiFp(this.configuration).customersCustomerNamePut(body, customerName, options)(this.fetch, this.basePath);
    }

    /**
     * Fetch revenue of a customer from start_time and end_time.
     * @summary Get Customer Revenue
     * @param {string} customerName 
     * @param {Date} [startTime] 
     * @param {Date} [endTime] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public customersCustomerNameRevenueGet(customerName: string, startTime?: Date, endTime?: Date, options?: any) {
        return CustomersApiFp(this.configuration).customersCustomerNameRevenueGet(customerName, startTime, endTime, options)(this.fetch, this.basePath);
    }

    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * @summary Generate Current Invoice
     * @param {string} token 
     * @param {string} customerName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public customersCustomerNameSampleInvoiceTokenGet(token: string, customerName: string, options?: any) {
        return CustomersApiFp(this.configuration).customersCustomerNameSampleInvoiceTokenGet(token, customerName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the current status for a customer.
     * @param {string} customerName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public customersCustomerNameStatusGet(customerName: string, options?: any) {
        return CustomersApiFp(this.configuration).customersCustomerNameStatusGet(customerName, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a subscription for a specific customer (by customer name).
     * @summary Delete Subscription
     * @param {DeleteSubscriptionArgs} body 
     * @param {string} customerName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public customersCustomerNameSubscriptionDelete(body: DeleteSubscriptionArgs, customerName: string, options?: any) {
        return CustomersApiFp(this.configuration).customersCustomerNameSubscriptionDelete(body, customerName, options)(this.fetch, this.basePath);
    }

    /**
     * Update a subscription for a specific customer (by customer name).
     * @summary Update Subscription
     * @param {UpdateSubscriptionArgs} body 
     * @param {string} customerName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public customersCustomerNameSubscriptionPut(body: UpdateSubscriptionArgs, customerName: string, options?: any) {
        return CustomersApiFp(this.configuration).customersCustomerNameSubscriptionPut(body, customerName, options)(this.fetch, this.basePath);
    }

    /**
     * Get all subscriptions for the customer.
     * @summary Get Subscriptions
     * @param {string} customerName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public customersCustomerNameSubscriptionsGet(customerName: string, options?: any) {
        return CustomersApiFp(this.configuration).customersCustomerNameSubscriptionsGet(customerName, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new subscription for a customer / price plan combination (by unique name).
     * @summary Create Subscription
     * @param {CreateSubscriptionArgs} body 
     * @param {string} customerName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public customersCustomerNameSubscriptionsPost(body: CreateSubscriptionArgs, customerName: string, options?: any) {
        return CustomersApiFp(this.configuration).customersCustomerNameSubscriptionsPost(body, customerName, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all customers for a given vendor.
     * @summary Get All Customers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public customersGet(options?: any) {
        return CustomersApiFp(this.configuration).customersGet(options)(this.fetch, this.basePath);
    }

    /**
     * Create a new customer.
     * @summary Create Customer
     * @param {CreateCustomerArgs} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public customersPost(body: CreateCustomerArgs, options?: any) {
        return CustomersApiFp(this.configuration).customersPost(body, options)(this.fetch, this.basePath);
    }

}
/**
 * MeasurementsApi - fetch parameter creator
 * @export
 */
export const MeasurementsApiFetchParamCreator = function (_configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Send Batched Measurements
         * @param {Array<Measurement>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        measurementsMultiPost(body: Array<Measurement>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling measurementsMultiPost.');
            }
            const localVarPath = `/measurements/multi`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Measurement&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send Measurement
         * @param {Measurement} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        measurementsPost(body: Measurement, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling measurementsPost.');
            }
            const localVarPath = `/measurements/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Measurement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeasurementsApi - functional programming interface
 * @export
 */
export const MeasurementsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Send Batched Measurements
         * @param {Array<Measurement>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        measurementsMultiPost(body: Array<Measurement>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Measurement>> {
            const localVarFetchArgs = MeasurementsApiFetchParamCreator(configuration).measurementsMultiPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Send Measurement
         * @param {Measurement} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        measurementsPost(body: Measurement, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Measurement> {
            const localVarFetchArgs = MeasurementsApiFetchParamCreator(configuration).measurementsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MeasurementsApi - factory interface
 * @export
 */
export const MeasurementsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Send Batched Measurements
         * @param {Array<Measurement>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        measurementsMultiPost(body: Array<Measurement>, options?: any) {
            return MeasurementsApiFp(configuration).measurementsMultiPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Send Measurement
         * @param {Measurement} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        measurementsPost(body: Measurement, options?: any) {
            return MeasurementsApiFp(configuration).measurementsPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * MeasurementsApi - object-oriented interface
 * @export
 * @class MeasurementsApi
 * @extends {BaseAPI}
 */
export class MeasurementsApi extends BaseAPI {
    /**
     * 
     * @summary Send Batched Measurements
     * @param {Array<Measurement>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementsApi
     */
    public measurementsMultiPost(body: Array<Measurement>, options?: any) {
        return MeasurementsApiFp(this.configuration).measurementsMultiPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Send Measurement
     * @param {Measurement} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementsApi
     */
    public measurementsPost(body: Measurement, options?: any) {
        return MeasurementsApiFp(this.configuration).measurementsPost(body, options)(this.fetch, this.basePath);
    }

}
/**
 * MetersApi - fetch parameter creator
 * @export
 */
export const MetersApiFetchParamCreator = function (_configuration?: Configuration) {
    return {
        /**
         * Get a set of meters. If no meter names are provided, all meters will be fetched
         * @summary Get Meters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metersGet(options: any = {}): FetchArgs {
            const localVarPath = `/meters/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a meter by its unique name. Meters can only be deleted if they have no active usage.
         * @summary Delete Meter
         * @param {string} meterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metersMeterNameDelete(meterName: string, options: any = {}): FetchArgs {
            // verify required parameter 'meterName' is not null or undefined
            if (meterName === null || meterName === undefined) {
                throw new RequiredError('meterName','Required parameter meterName was null or undefined when calling metersMeterNameDelete.');
            }
            const localVarPath = `/meters/{meter_name}`
                .replace(`{${"meter_name"}}`, encodeURIComponent(String(meterName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a meter by its unique name
         * @summary Get Meter
         * @param {string} meterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metersMeterNameGet(meterName: string, options: any = {}): FetchArgs {
            // verify required parameter 'meterName' is not null or undefined
            if (meterName === null || meterName === undefined) {
                throw new RequiredError('meterName','Required parameter meterName was null or undefined when calling metersMeterNameGet.');
            }
            const localVarPath = `/meters/{meter_name}`
                .replace(`{${"meter_name"}}`, encodeURIComponent(String(meterName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a meter by its unique name
         * @summary Update Meter
         * @param {MeterUpdateInputArgs} body 
         * @param {string} meterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metersMeterNamePut(body: MeterUpdateInputArgs, meterName: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling metersMeterNamePut.');
            }
            // verify required parameter 'meterName' is not null or undefined
            if (meterName === null || meterName === undefined) {
                throw new RequiredError('meterName','Required parameter meterName was null or undefined when calling metersMeterNamePut.');
            }
            const localVarPath = `/meters/{meter_name}`
                .replace(`{${"meter_name"}}`, encodeURIComponent(String(meterName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MeterUpdateInputArgs" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Meter.
         * @summary Create Meter
         * @param {MeterInputArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metersPost(body: MeterInputArgs, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling metersPost.');
            }
            const localVarPath = `/meters/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MeterInputArgs" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetersApi - functional programming interface
 * @export
 */
export const MetersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get a set of meters. If no meter names are provided, all meters will be fetched
         * @summary Get Meters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metersGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Meter>> {
            const localVarFetchArgs = MetersApiFetchParamCreator(configuration).metersGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a meter by its unique name. Meters can only be deleted if they have no active usage.
         * @summary Delete Meter
         * @param {string} meterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metersMeterNameDelete(meterName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = MetersApiFetchParamCreator(configuration).metersMeterNameDelete(meterName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch a meter by its unique name
         * @summary Get Meter
         * @param {string} meterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metersMeterNameGet(meterName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Meter> {
            const localVarFetchArgs = MetersApiFetchParamCreator(configuration).metersMeterNameGet(meterName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a meter by its unique name
         * @summary Update Meter
         * @param {MeterUpdateInputArgs} body 
         * @param {string} meterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metersMeterNamePut(body: MeterUpdateInputArgs, meterName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Meter> {
            const localVarFetchArgs = MetersApiFetchParamCreator(configuration).metersMeterNamePut(body, meterName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new Meter.
         * @summary Create Meter
         * @param {MeterInputArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metersPost(body: MeterInputArgs, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Meter> {
            const localVarFetchArgs = MetersApiFetchParamCreator(configuration).metersPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MetersApi - factory interface
 * @export
 */
export const MetersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get a set of meters. If no meter names are provided, all meters will be fetched
         * @summary Get Meters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metersGet(options?: any) {
            return MetersApiFp(configuration).metersGet(options)(fetch, basePath);
        },
        /**
         * Delete a meter by its unique name. Meters can only be deleted if they have no active usage.
         * @summary Delete Meter
         * @param {string} meterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metersMeterNameDelete(meterName: string, options?: any) {
            return MetersApiFp(configuration).metersMeterNameDelete(meterName, options)(fetch, basePath);
        },
        /**
         * Fetch a meter by its unique name
         * @summary Get Meter
         * @param {string} meterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metersMeterNameGet(meterName: string, options?: any) {
            return MetersApiFp(configuration).metersMeterNameGet(meterName, options)(fetch, basePath);
        },
        /**
         * Update a meter by its unique name
         * @summary Update Meter
         * @param {MeterUpdateInputArgs} body 
         * @param {string} meterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metersMeterNamePut(body: MeterUpdateInputArgs, meterName: string, options?: any) {
            return MetersApiFp(configuration).metersMeterNamePut(body, meterName, options)(fetch, basePath);
        },
        /**
         * Create a new Meter.
         * @summary Create Meter
         * @param {MeterInputArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metersPost(body: MeterInputArgs, options?: any) {
            return MetersApiFp(configuration).metersPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * MetersApi - object-oriented interface
 * @export
 * @class MetersApi
 * @extends {BaseAPI}
 */
export class MetersApi extends BaseAPI {
    /**
     * Get a set of meters. If no meter names are provided, all meters will be fetched
     * @summary Get Meters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetersApi
     */
    public metersGet(options?: any) {
        return MetersApiFp(this.configuration).metersGet(options)(this.fetch, this.basePath);
    }

    /**
     * Delete a meter by its unique name. Meters can only be deleted if they have no active usage.
     * @summary Delete Meter
     * @param {string} meterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetersApi
     */
    public metersMeterNameDelete(meterName: string, options?: any) {
        return MetersApiFp(this.configuration).metersMeterNameDelete(meterName, options)(this.fetch, this.basePath);
    }

    /**
     * Fetch a meter by its unique name
     * @summary Get Meter
     * @param {string} meterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetersApi
     */
    public metersMeterNameGet(meterName: string, options?: any) {
        return MetersApiFp(this.configuration).metersMeterNameGet(meterName, options)(this.fetch, this.basePath);
    }

    /**
     * Update a meter by its unique name
     * @summary Update Meter
     * @param {MeterUpdateInputArgs} body 
     * @param {string} meterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetersApi
     */
    public metersMeterNamePut(body: MeterUpdateInputArgs, meterName: string, options?: any) {
        return MetersApiFp(this.configuration).metersMeterNamePut(body, meterName, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new Meter.
     * @summary Create Meter
     * @param {MeterInputArgs} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetersApi
     */
    public metersPost(body: MeterInputArgs, options?: any) {
        return MetersApiFp(this.configuration).metersPost(body, options)(this.fetch, this.basePath);
    }

}
/**
 * PaymentGatewayCredentialApi - fetch parameter creator
 * @export
 */
export const PaymentGatewayCredentialApiFetchParamCreator = function (_configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add PaymentGatewayCredential for Vendor
         * @param {PaymentGatewayCredentialInputArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentGatewayCredentialsPost(body: PaymentGatewayCredentialInputArgs, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling paymentGatewayCredentialsPost.');
            }
            const localVarPath = `/payment_gateway_credentials/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PaymentGatewayCredentialInputArgs" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentGatewayCredentialApi - functional programming interface
 * @export
 */
export const PaymentGatewayCredentialApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add PaymentGatewayCredential for Vendor
         * @param {PaymentGatewayCredentialInputArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentGatewayCredentialsPost(body: PaymentGatewayCredentialInputArgs, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaymentGatewayCredential> {
            const localVarFetchArgs = PaymentGatewayCredentialApiFetchParamCreator(configuration).paymentGatewayCredentialsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PaymentGatewayCredentialApi - factory interface
 * @export
 */
export const PaymentGatewayCredentialApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Add PaymentGatewayCredential for Vendor
         * @param {PaymentGatewayCredentialInputArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentGatewayCredentialsPost(body: PaymentGatewayCredentialInputArgs, options?: any) {
            return PaymentGatewayCredentialApiFp(configuration).paymentGatewayCredentialsPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * PaymentGatewayCredentialApi - object-oriented interface
 * @export
 * @class PaymentGatewayCredentialApi
 * @extends {BaseAPI}
 */
export class PaymentGatewayCredentialApi extends BaseAPI {
    /**
     * 
     * @summary Add PaymentGatewayCredential for Vendor
     * @param {PaymentGatewayCredentialInputArgs} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentGatewayCredentialApi
     */
    public paymentGatewayCredentialsPost(body: PaymentGatewayCredentialInputArgs, options?: any) {
        return PaymentGatewayCredentialApiFp(this.configuration).paymentGatewayCredentialsPost(body, options)(this.fetch, this.basePath);
    }

}
/**
 * PricePlansApi - fetch parameter creator
 * @export
 */
export const PricePlansApiFetchParamCreator = function (_configuration?: Configuration) {
    return {
        /**
         * Fetch all price plans associated with a vendor.
         * @summary Get All Price Plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricePlansGet(options: any = {}): FetchArgs {
            const localVarPath = `/price_plans/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Price Plan
         * @param {CreatePricePlanArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricePlansPost(body: CreatePricePlanArgs, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling pricePlansPost.');
            }
            const localVarPath = `/price_plans/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreatePricePlanArgs" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Price Plan. Plans which map to active Subscriptions must be replaced or removed before deletion can occur.
         * @summary Delete Price Plan
         * @param {string} pricePlanName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricePlansPricePlanNameDelete(pricePlanName: string, options: any = {}): FetchArgs {
            // verify required parameter 'pricePlanName' is not null or undefined
            if (pricePlanName === null || pricePlanName === undefined) {
                throw new RequiredError('pricePlanName','Required parameter pricePlanName was null or undefined when calling pricePlansPricePlanNameDelete.');
            }
            const localVarPath = `/price_plans/{price_plan_name}`
                .replace(`{${"price_plan_name"}}`, encodeURIComponent(String(pricePlanName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch an existing price plan.
         * @summary Get a Price Plan
         * @param {string} pricePlanName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricePlansPricePlanNameGet(pricePlanName: string, options: any = {}): FetchArgs {
            // verify required parameter 'pricePlanName' is not null or undefined
            if (pricePlanName === null || pricePlanName === undefined) {
                throw new RequiredError('pricePlanName','Required parameter pricePlanName was null or undefined when calling pricePlansPricePlanNameGet.');
            }
            const localVarPath = `/price_plans/{price_plan_name}`
                .replace(`{${"price_plan_name"}}`, encodeURIComponent(String(pricePlanName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing price plan.
         * @summary Update a Price Plan
         * @param {UpdatePricePlanArgs} body 
         * @param {string} pricePlanName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricePlansPricePlanNamePut(body: UpdatePricePlanArgs, pricePlanName: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling pricePlansPricePlanNamePut.');
            }
            // verify required parameter 'pricePlanName' is not null or undefined
            if (pricePlanName === null || pricePlanName === undefined) {
                throw new RequiredError('pricePlanName','Required parameter pricePlanName was null or undefined when calling pricePlansPricePlanNamePut.');
            }
            const localVarPath = `/price_plans/{price_plan_name}`
                .replace(`{${"price_plan_name"}}`, encodeURIComponent(String(pricePlanName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdatePricePlanArgs" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PricePlansApi - functional programming interface
 * @export
 */
export const PricePlansApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetch all price plans associated with a vendor.
         * @summary Get All Price Plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricePlansGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PricePlan>> {
            const localVarFetchArgs = PricePlansApiFetchParamCreator(configuration).pricePlansGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create Price Plan
         * @param {CreatePricePlanArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricePlansPost(body: CreatePricePlanArgs, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PricePlan> {
            const localVarFetchArgs = PricePlansApiFetchParamCreator(configuration).pricePlansPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an existing Price Plan. Plans which map to active Subscriptions must be replaced or removed before deletion can occur.
         * @summary Delete Price Plan
         * @param {string} pricePlanName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricePlansPricePlanNameDelete(pricePlanName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PricePlansApiFetchParamCreator(configuration).pricePlansPricePlanNameDelete(pricePlanName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch an existing price plan.
         * @summary Get a Price Plan
         * @param {string} pricePlanName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricePlansPricePlanNameGet(pricePlanName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PricePlan> {
            const localVarFetchArgs = PricePlansApiFetchParamCreator(configuration).pricePlansPricePlanNameGet(pricePlanName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update an existing price plan.
         * @summary Update a Price Plan
         * @param {UpdatePricePlanArgs} body 
         * @param {string} pricePlanName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricePlansPricePlanNamePut(body: UpdatePricePlanArgs, pricePlanName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PricePlan> {
            const localVarFetchArgs = PricePlansApiFetchParamCreator(configuration).pricePlansPricePlanNamePut(body, pricePlanName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PricePlansApi - factory interface
 * @export
 */
export const PricePlansApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetch all price plans associated with a vendor.
         * @summary Get All Price Plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricePlansGet(options?: any) {
            return PricePlansApiFp(configuration).pricePlansGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create Price Plan
         * @param {CreatePricePlanArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricePlansPost(body: CreatePricePlanArgs, options?: any) {
            return PricePlansApiFp(configuration).pricePlansPost(body, options)(fetch, basePath);
        },
        /**
         * Delete an existing Price Plan. Plans which map to active Subscriptions must be replaced or removed before deletion can occur.
         * @summary Delete Price Plan
         * @param {string} pricePlanName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricePlansPricePlanNameDelete(pricePlanName: string, options?: any) {
            return PricePlansApiFp(configuration).pricePlansPricePlanNameDelete(pricePlanName, options)(fetch, basePath);
        },
        /**
         * Fetch an existing price plan.
         * @summary Get a Price Plan
         * @param {string} pricePlanName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricePlansPricePlanNameGet(pricePlanName: string, options?: any) {
            return PricePlansApiFp(configuration).pricePlansPricePlanNameGet(pricePlanName, options)(fetch, basePath);
        },
        /**
         * Update an existing price plan.
         * @summary Update a Price Plan
         * @param {UpdatePricePlanArgs} body 
         * @param {string} pricePlanName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricePlansPricePlanNamePut(body: UpdatePricePlanArgs, pricePlanName: string, options?: any) {
            return PricePlansApiFp(configuration).pricePlansPricePlanNamePut(body, pricePlanName, options)(fetch, basePath);
        },
    };
};

/**
 * PricePlansApi - object-oriented interface
 * @export
 * @class PricePlansApi
 * @extends {BaseAPI}
 */
export class PricePlansApi extends BaseAPI {
    /**
     * Fetch all price plans associated with a vendor.
     * @summary Get All Price Plans
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public pricePlansGet(options?: any) {
        return PricePlansApiFp(this.configuration).pricePlansGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create Price Plan
     * @param {CreatePricePlanArgs} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public pricePlansPost(body: CreatePricePlanArgs, options?: any) {
        return PricePlansApiFp(this.configuration).pricePlansPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete an existing Price Plan. Plans which map to active Subscriptions must be replaced or removed before deletion can occur.
     * @summary Delete Price Plan
     * @param {string} pricePlanName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public pricePlansPricePlanNameDelete(pricePlanName: string, options?: any) {
        return PricePlansApiFp(this.configuration).pricePlansPricePlanNameDelete(pricePlanName, options)(this.fetch, this.basePath);
    }

    /**
     * Fetch an existing price plan.
     * @summary Get a Price Plan
     * @param {string} pricePlanName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public pricePlansPricePlanNameGet(pricePlanName: string, options?: any) {
        return PricePlansApiFp(this.configuration).pricePlansPricePlanNameGet(pricePlanName, options)(this.fetch, this.basePath);
    }

    /**
     * Update an existing price plan.
     * @summary Update a Price Plan
     * @param {UpdatePricePlanArgs} body 
     * @param {string} pricePlanName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public pricePlansPricePlanNamePut(body: UpdatePricePlanArgs, pricePlanName: string, options?: any) {
        return PricePlansApiFp(this.configuration).pricePlansPricePlanNamePut(body, pricePlanName, options)(this.fetch, this.basePath);
    }

}
/**
 * VendorsApi - fetch parameter creator
 * @export
 */
export const VendorsApiFetchParamCreator = function (_configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Vendor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsDelete(options: any = {}): FetchArgs {
            const localVarPath = `/vendors/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch vendor data. The vendor used is based on the API Key provided as a part of auth.
         * @summary Get Vendor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsGet(options: any = {}): FetchArgs {
            const localVarPath = `/vendors/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **[ADMIN ONLY]** Create a new vendor.
         * @summary Create Vendor
         * @param {VendorCreateArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsPost(body: VendorCreateArgs, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling vendorsPost.');
            }
            const localVarPath = `/vendors/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VendorCreateArgs" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update vendor metadata.
         * @summary Update Vendor
         * @param {VendorUpdateInputArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsPut(body: VendorUpdateInputArgs, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling vendorsPut.');
            }
            const localVarPath = `/vendors/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VendorUpdateInputArgs" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VendorsApi - functional programming interface
 * @export
 */
export const VendorsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Vendor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsDelete(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VendorsApiFetchParamCreator(configuration).vendorsDelete(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch vendor data. The vendor used is based on the API Key provided as a part of auth.
         * @summary Get Vendor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Vendor> {
            const localVarFetchArgs = VendorsApiFetchParamCreator(configuration).vendorsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **[ADMIN ONLY]** Create a new vendor.
         * @summary Create Vendor
         * @param {VendorCreateArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsPost(body: VendorCreateArgs, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VendorCreateArgs> {
            const localVarFetchArgs = VendorsApiFetchParamCreator(configuration).vendorsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update vendor metadata.
         * @summary Update Vendor
         * @param {VendorUpdateInputArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsPut(body: VendorUpdateInputArgs, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Vendor> {
            const localVarFetchArgs = VendorsApiFetchParamCreator(configuration).vendorsPut(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                localVarFetchArgs.options.headers["Authorization"] = "Bearer " +(configuration?.apiKey || "UNSET"); return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VendorsApi - factory interface
 * @export
 */
export const VendorsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Delete Vendor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsDelete(options?: any) {
            return VendorsApiFp(configuration).vendorsDelete(options)(fetch, basePath);
        },
        /**
         * Fetch vendor data. The vendor used is based on the API Key provided as a part of auth.
         * @summary Get Vendor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsGet(options?: any) {
            return VendorsApiFp(configuration).vendorsGet(options)(fetch, basePath);
        },
        /**
         * **[ADMIN ONLY]** Create a new vendor.
         * @summary Create Vendor
         * @param {VendorCreateArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsPost(body: VendorCreateArgs, options?: any) {
            return VendorsApiFp(configuration).vendorsPost(body, options)(fetch, basePath);
        },
        /**
         * Update vendor metadata.
         * @summary Update Vendor
         * @param {VendorUpdateInputArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsPut(body: VendorUpdateInputArgs, options?: any) {
            return VendorsApiFp(configuration).vendorsPut(body, options)(fetch, basePath);
        },
    };
};

/**
 * VendorsApi - object-oriented interface
 * @export
 * @class VendorsApi
 * @extends {BaseAPI}
 */
export class VendorsApi extends BaseAPI {
    /**
     * 
     * @summary Delete Vendor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VendorsApi
     */
    public vendorsDelete(options?: any) {
        return VendorsApiFp(this.configuration).vendorsDelete(options)(this.fetch, this.basePath);
    }

    /**
     * Fetch vendor data. The vendor used is based on the API Key provided as a part of auth.
     * @summary Get Vendor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VendorsApi
     */
    public vendorsGet(options?: any) {
        return VendorsApiFp(this.configuration).vendorsGet(options)(this.fetch, this.basePath);
    }

    /**
     * **[ADMIN ONLY]** Create a new vendor.
     * @summary Create Vendor
     * @param {VendorCreateArgs} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VendorsApi
     */
    public vendorsPost(body: VendorCreateArgs, options?: any) {
        return VendorsApiFp(this.configuration).vendorsPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Update vendor metadata.
     * @summary Update Vendor
     * @param {VendorUpdateInputArgs} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VendorsApi
     */
    public vendorsPut(body: VendorUpdateInputArgs, options?: any) {
        return VendorsApiFp(this.configuration).vendorsPut(body, options)(this.fetch, this.basePath);
    }

}
