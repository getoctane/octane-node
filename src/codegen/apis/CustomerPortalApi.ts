/* tslint:disable */
/* eslint-disable */
/**
 * Octane API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ContactInfo,
    ContactInfoFromJSON,
    ContactInfoToJSON,
    CreditGrant,
    CreditGrantFromJSON,
    CreditGrantToJSON,
    CreditLedger,
    CreditLedgerFromJSON,
    CreditLedgerToJSON,
    CustomerPaymentMethodStatus,
    CustomerPaymentMethodStatusFromJSON,
    CustomerPaymentMethodStatusToJSON,
    CustomerPortalAccruedRevenue,
    CustomerPortalAccruedRevenueFromJSON,
    CustomerPortalAccruedRevenueToJSON,
    CustomerPortalActiveSubscription,
    CustomerPortalActiveSubscriptionFromJSON,
    CustomerPortalActiveSubscriptionToJSON,
    CustomerPortalActiveSubscriptionInputArgs,
    CustomerPortalActiveSubscriptionInputArgsFromJSON,
    CustomerPortalActiveSubscriptionInputArgsToJSON,
    CustomerPortalAvailableCreditBalance,
    CustomerPortalAvailableCreditBalanceFromJSON,
    CustomerPortalAvailableCreditBalanceToJSON,
    CustomerPortalContactInfoInputArgs,
    CustomerPortalContactInfoInputArgsFromJSON,
    CustomerPortalContactInfoInputArgsToJSON,
    CustomerPortalCreditPurchase,
    CustomerPortalCreditPurchaseFromJSON,
    CustomerPortalCreditPurchaseToJSON,
    CustomerPortalDailyAccruedRevenue,
    CustomerPortalDailyAccruedRevenueFromJSON,
    CustomerPortalDailyAccruedRevenueToJSON,
    CustomerPortalInvoice,
    CustomerPortalInvoiceFromJSON,
    CustomerPortalInvoiceToJSON,
    CustomerPortalMeter,
    CustomerPortalMeterFromJSON,
    CustomerPortalMeterToJSON,
    CustomerPortalMeterLabelFilter,
    CustomerPortalMeterLabelFilterFromJSON,
    CustomerPortalMeterLabelFilterToJSON,
    CustomerPortalPaymentMethod,
    CustomerPortalPaymentMethodFromJSON,
    CustomerPortalPaymentMethodToJSON,
    CustomerPortalStripeCredential,
    CustomerPortalStripeCredentialFromJSON,
    CustomerPortalStripeCredentialToJSON,
    CustomerPortalSubscription,
    CustomerPortalSubscriptionFromJSON,
    CustomerPortalSubscriptionToJSON,
    CustomerPortalSubscriptionInputArgs,
    CustomerPortalSubscriptionInputArgsFromJSON,
    CustomerPortalSubscriptionInputArgsToJSON,
    CustomerPortalToken,
    CustomerPortalTokenFromJSON,
    CustomerPortalTokenToJSON,
    CustomerPortalTokenInputArgs,
    CustomerPortalTokenInputArgsFromJSON,
    CustomerPortalTokenInputArgsToJSON,
    CustomerPortalUrl,
    CustomerPortalUrlFromJSON,
    CustomerPortalUrlToJSON,
    CustomerPortalUsage,
    CustomerPortalUsageFromJSON,
    CustomerPortalUsageToJSON,
    CustomerPortalVendor,
    CustomerPortalVendorFromJSON,
    CustomerPortalVendorToJSON,
    PricePlan,
    PricePlanFromJSON,
    PricePlanToJSON,
    SelfServeCustomization,
    SelfServeCustomizationFromJSON,
    SelfServeCustomizationToJSON,
    SelfServeSettings,
    SelfServeSettingsFromJSON,
    SelfServeSettingsToJSON,
} from '../models';

export interface EcpActiveSubscriptionPostRequest {
    customerPortalActiveSubscriptionInputArgs: CustomerPortalActiveSubscriptionInputArgs;
}

export interface EcpContactInfoPutRequest {
    customerPortalContactInfoInputArgs: CustomerPortalContactInfoInputArgs;
}

export interface EcpCreditPurchasePostRequest {
    customerPortalCreditPurchase: CustomerPortalCreditPurchase;
}

export interface EcpCustomerPortalUrlPostRequest {
    customerPortalTokenInputArgs: CustomerPortalTokenInputArgs;
}

export interface EcpFilteredUsagePostRequest {
    customerPortalMeterLabelFilter: CustomerPortalMeterLabelFilter;
}

export interface EcpSubscriptionPostRequest {
    customerPortalSubscriptionInputArgs: CustomerPortalSubscriptionInputArgs;
}

export interface EcpTokenPostRequest {
    customerPortalTokenInputArgs: CustomerPortalTokenInputArgs;
}

/**
 * 
 */
export class CustomerPortalApi extends runtime.BaseAPI {

    /**
     * Fetch the customer\'s active subscription and related information if they exists. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Active Subscription
     */
    async ecpActiveSubscriptionGetRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerPortalActiveSubscription>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ecp/active_subscription`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerPortalActiveSubscriptionFromJSON(jsonValue));
    }

    /**
     * Fetch the customer\'s active subscription and related information if they exists. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Active Subscription
     */
    async ecpActiveSubscriptionGet(initOverrides?: RequestInit): Promise<CustomerPortalActiveSubscription> {
        const response = await this.ecpActiveSubscriptionGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Create/update the customer\'s subscription. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name in the request body.
     * Create/Update Active Subscription
     */
    async ecpActiveSubscriptionPostRaw(requestParameters: EcpActiveSubscriptionPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerPortalSubscription>> {
        if (requestParameters.customerPortalActiveSubscriptionInputArgs === null || requestParameters.customerPortalActiveSubscriptionInputArgs === undefined) {
            throw new runtime.RequiredError('customerPortalActiveSubscriptionInputArgs','Required parameter requestParameters.customerPortalActiveSubscriptionInputArgs was null or undefined when calling ecpActiveSubscriptionPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ecp/active_subscription`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CustomerPortalActiveSubscriptionInputArgsToJSON(requestParameters.customerPortalActiveSubscriptionInputArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerPortalSubscriptionFromJSON(jsonValue));
    }

    /**
     * Create/update the customer\'s subscription. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name in the request body.
     * Create/Update Active Subscription
     */
    async ecpActiveSubscriptionPost(requestParameters: EcpActiveSubscriptionPostRequest, initOverrides?: RequestInit): Promise<CustomerPortalSubscription> {
        const response = await this.ecpActiveSubscriptionPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the customer\'s contact info. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Contact Info
     */
    async ecpContactInfoGetRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<ContactInfo>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ecp/contact_info`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ContactInfoFromJSON(jsonValue));
    }

    /**
     * Gets the customer\'s contact info. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Contact Info
     */
    async ecpContactInfoGet(initOverrides?: RequestInit): Promise<ContactInfo> {
        const response = await this.ecpContactInfoGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Create/update the customer\'s contact info. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name in the request body.
     * Create/Update Contact Info
     */
    async ecpContactInfoPutRaw(requestParameters: EcpContactInfoPutRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<ContactInfo>> {
        if (requestParameters.customerPortalContactInfoInputArgs === null || requestParameters.customerPortalContactInfoInputArgs === undefined) {
            throw new runtime.RequiredError('customerPortalContactInfoInputArgs','Required parameter requestParameters.customerPortalContactInfoInputArgs was null or undefined when calling ecpContactInfoPut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ecp/contact_info`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CustomerPortalContactInfoInputArgsToJSON(requestParameters.customerPortalContactInfoInputArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ContactInfoFromJSON(jsonValue));
    }

    /**
     * Create/update the customer\'s contact info. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name in the request body.
     * Create/Update Contact Info
     */
    async ecpContactInfoPut(requestParameters: EcpContactInfoPutRequest, initOverrides?: RequestInit): Promise<ContactInfo> {
        const response = await this.ecpContactInfoPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the credit balance. This is a live balance including the accrued revenue in the current cycle. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get the available credit balance.
     */
    async ecpCreditAvailableBalanceGetRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerPortalAvailableCreditBalance>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ecp/credit/available_balance`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerPortalAvailableCreditBalanceFromJSON(jsonValue));
    }

    /**
     * Returns the credit balance. This is a live balance including the accrued revenue in the current cycle. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get the available credit balance.
     */
    async ecpCreditAvailableBalanceGet(initOverrides?: RequestInit): Promise<CustomerPortalAvailableCreditBalance> {
        const response = await this.ecpCreditAvailableBalanceGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns the customer entire credit ledger. This can be used to compute the current and available credit balance. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Fetch the Credit Ledger
     */
    async ecpCreditLedgerGetRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<CreditLedger>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ecp/credit/ledger`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CreditLedgerFromJSON));
    }

    /**
     * Returns the customer entire credit ledger. This can be used to compute the current and available credit balance. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Fetch the Credit Ledger
     */
    async ecpCreditLedgerGet(initOverrides?: RequestInit): Promise<Array<CreditLedger>> {
        const response = await this.ecpCreditLedgerGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Purchase the provided amount of credits at the default expiration and price set by the vendor. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name in the request body.
     * Purchase Credits
     */
    async ecpCreditPurchasePostRaw(requestParameters: EcpCreditPurchasePostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CreditGrant>> {
        if (requestParameters.customerPortalCreditPurchase === null || requestParameters.customerPortalCreditPurchase === undefined) {
            throw new runtime.RequiredError('customerPortalCreditPurchase','Required parameter requestParameters.customerPortalCreditPurchase was null or undefined when calling ecpCreditPurchasePost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ecp/credit/purchase`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CustomerPortalCreditPurchaseToJSON(requestParameters.customerPortalCreditPurchase),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreditGrantFromJSON(jsonValue));
    }

    /**
     * Purchase the provided amount of credits at the default expiration and price set by the vendor. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name in the request body.
     * Purchase Credits
     */
    async ecpCreditPurchasePost(requestParameters: EcpCreditPurchasePostRequest, initOverrides?: RequestInit): Promise<CreditGrant> {
        const response = await this.ecpCreditPurchasePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generate the url to the customer portal. This endpoint expects the vendor API key for authentication.
     * Generate Customer Portal Url
     */
    async ecpCustomerPortalUrlPostRaw(requestParameters: EcpCustomerPortalUrlPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerPortalUrl>> {
        if (requestParameters.customerPortalTokenInputArgs === null || requestParameters.customerPortalTokenInputArgs === undefined) {
            throw new runtime.RequiredError('customerPortalTokenInputArgs','Required parameter requestParameters.customerPortalTokenInputArgs was null or undefined when calling ecpCustomerPortalUrlPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ecp/customer_portal_url`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CustomerPortalTokenInputArgsToJSON(requestParameters.customerPortalTokenInputArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerPortalUrlFromJSON(jsonValue));
    }

    /**
     * Generate the url to the customer portal. This endpoint expects the vendor API key for authentication.
     * Generate Customer Portal Url
     */
    async ecpCustomerPortalUrlPost(requestParameters: EcpCustomerPortalUrlPostRequest, initOverrides?: RequestInit): Promise<CustomerPortalUrl> {
        const response = await this.ecpCustomerPortalUrlPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the daily accrued revenue for a customer broken down by line item until the beginning of the current hour. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Daily Accrued Revenue
     */
    async ecpDailyAccruedRevenueGetRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<CustomerPortalDailyAccruedRevenue>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ecp/daily_accrued_revenue`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CustomerPortalDailyAccruedRevenueFromJSON));
    }

    /**
     * Gets the daily accrued revenue for a customer broken down by line item until the beginning of the current hour. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Daily Accrued Revenue
     */
    async ecpDailyAccruedRevenueGet(initOverrides?: RequestInit): Promise<Array<CustomerPortalDailyAccruedRevenue>> {
        const response = await this.ecpDailyAccruedRevenueGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get the customer\'s daily usage filtered by the inputted meter and labels. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name in the request body.
     * Get Daily Usage For Meter
     */
    async ecpFilteredUsagePostRaw(requestParameters: EcpFilteredUsagePostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerPortalUsage>> {
        if (requestParameters.customerPortalMeterLabelFilter === null || requestParameters.customerPortalMeterLabelFilter === undefined) {
            throw new runtime.RequiredError('customerPortalMeterLabelFilter','Required parameter requestParameters.customerPortalMeterLabelFilter was null or undefined when calling ecpFilteredUsagePost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ecp/filtered_usage`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CustomerPortalMeterLabelFilterToJSON(requestParameters.customerPortalMeterLabelFilter),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerPortalUsageFromJSON(jsonValue));
    }

    /**
     * Get the customer\'s daily usage filtered by the inputted meter and labels. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name in the request body.
     * Get Daily Usage For Meter
     */
    async ecpFilteredUsagePost(requestParameters: EcpFilteredUsagePostRequest, initOverrides?: RequestInit): Promise<CustomerPortalUsage> {
        const response = await this.ecpFilteredUsagePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all invoices visible to the given customer. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Invoices
     */
    async ecpInvoicesGetRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<CustomerPortalInvoice>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ecp/invoices`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CustomerPortalInvoiceFromJSON));
    }

    /**
     * Get all invoices visible to the given customer. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Invoices
     */
    async ecpInvoicesGet(initOverrides?: RequestInit): Promise<Array<CustomerPortalInvoice>> {
        const response = await this.ecpInvoicesGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get the meters and corresponding primary label keys and values from the customer\'s active subscription. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Meters and Primary Labels
     */
    async ecpMetersGetRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<CustomerPortalMeter>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ecp/meters`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CustomerPortalMeterFromJSON));
    }

    /**
     * Get the meters and corresponding primary label keys and values from the customer\'s active subscription. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Meters and Primary Labels
     */
    async ecpMetersGet(initOverrides?: RequestInit): Promise<Array<CustomerPortalMeter>> {
        const response = await this.ecpMetersGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get the customer\'s current payment method if it exists in their payment gateway. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Payment Method
     */
    async ecpPaymentMethodGetRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerPortalPaymentMethod>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ecp/payment_method`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerPortalPaymentMethodFromJSON(jsonValue));
    }

    /**
     * Get the customer\'s current payment method if it exists in their payment gateway. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Payment Method
     */
    async ecpPaymentMethodGet(initOverrides?: RequestInit): Promise<CustomerPortalPaymentMethod> {
        const response = await this.ecpPaymentMethodGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Gets the customer\'s current payment method status. Returns a 400 if the customer has no configuration or if the current payment provider doesn\'t have customer-level payment status. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Payment Method Status
     */
    async ecpPaymentMethodStatusGetRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerPaymentMethodStatus>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ecp/payment_method_status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerPaymentMethodStatusFromJSON(jsonValue));
    }

    /**
     * Gets the customer\'s current payment method status. Returns a 400 if the customer has no configuration or if the current payment provider doesn\'t have customer-level payment status. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Payment Method Status
     */
    async ecpPaymentMethodStatusGet(initOverrides?: RequestInit): Promise<CustomerPaymentMethodStatus> {
        const response = await this.ecpPaymentMethodStatusGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get the url to the customer portal. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get the Customer Portal Url
     */
    async ecpPortalUrlGetRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerPortalUrl>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ecp/portal_url`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerPortalUrlFromJSON(jsonValue));
    }

    /**
     * Get the url to the customer portal. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get the Customer Portal Url
     */
    async ecpPortalUrlGet(initOverrides?: RequestInit): Promise<CustomerPortalUrl> {
        const response = await this.ecpPortalUrlGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get all price plans visible to the given customer for self serve. By default, no price plans are visible. Price plan visibility can be configured by the vendor using the /price_plans/self_serve endpoint. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Self Serve Price Plans
     */
    async ecpPricePlansGetRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<PricePlan>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ecp/price_plans`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PricePlanFromJSON));
    }

    /**
     * Get all price plans visible to the given customer for self serve. By default, no price plans are visible. Price plan visibility can be configured by the vendor using the /price_plans/self_serve endpoint. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Self Serve Price Plans
     */
    async ecpPricePlansGet(initOverrides?: RequestInit): Promise<Array<PricePlan>> {
        const response = await this.ecpPricePlansGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get the customer\'s self serve customization. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Self Serve Customization.
     */
    async ecpSelfServeCustomizationGetRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<SelfServeCustomization>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ecp/self_serve_customization`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SelfServeCustomizationFromJSON(jsonValue));
    }

    /**
     * Get the customer\'s self serve customization. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Self Serve Customization.
     */
    async ecpSelfServeCustomizationGet(initOverrides?: RequestInit): Promise<SelfServeCustomization> {
        const response = await this.ecpSelfServeCustomizationGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get the customer\'s self serve settings. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Self Serve Settings.
     */
    async ecpSelfServeSettingsGetRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<SelfServeSettings>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ecp/self_serve_settings`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SelfServeSettingsFromJSON(jsonValue));
    }

    /**
     * Get the customer\'s self serve settings. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Self Serve Settings.
     */
    async ecpSelfServeSettingsGet(initOverrides?: RequestInit): Promise<SelfServeSettings> {
        const response = await this.ecpSelfServeSettingsGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Attempt to create a Stripe SetupIntent object. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Create SetupIntent
     */
    async ecpSetupIntentPostRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerPortalStripeCredential>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ecp/setup_intent`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerPortalStripeCredentialFromJSON(jsonValue));
    }

    /**
     * Attempt to create a Stripe SetupIntent object. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Create SetupIntent
     */
    async ecpSetupIntentPost(initOverrides?: RequestInit): Promise<CustomerPortalStripeCredential> {
        const response = await this.ecpSetupIntentPostRaw(initOverrides);
        return await response.value();
    }

    /**
     * Cancel the customer\'s subscription. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Cancel Subscription
     */
    async ecpSubscriptionDeleteRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ecp/subscription`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Cancel the customer\'s subscription. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Cancel Subscription
     */
    async ecpSubscriptionDelete(initOverrides?: RequestInit): Promise<void> {
        await this.ecpSubscriptionDeleteRaw(initOverrides);
    }

    /**
     * Fetch the customer\'s active price plan if it exists. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Price Plan
     */
    async ecpSubscriptionGetRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerPortalSubscription>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ecp/subscription`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerPortalSubscriptionFromJSON(jsonValue));
    }

    /**
     * Fetch the customer\'s active price plan if it exists. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Price Plan
     */
    async ecpSubscriptionGet(initOverrides?: RequestInit): Promise<CustomerPortalSubscription> {
        const response = await this.ecpSubscriptionGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Create/update the customer\'s subscription. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name in the request body.
     * Create/Update Subscription
     */
    async ecpSubscriptionPostRaw(requestParameters: EcpSubscriptionPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerPortalSubscription>> {
        if (requestParameters.customerPortalSubscriptionInputArgs === null || requestParameters.customerPortalSubscriptionInputArgs === undefined) {
            throw new runtime.RequiredError('customerPortalSubscriptionInputArgs','Required parameter requestParameters.customerPortalSubscriptionInputArgs was null or undefined when calling ecpSubscriptionPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ecp/subscription`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CustomerPortalSubscriptionInputArgsToJSON(requestParameters.customerPortalSubscriptionInputArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerPortalSubscriptionFromJSON(jsonValue));
    }

    /**
     * Create/update the customer\'s subscription. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name in the request body.
     * Create/Update Subscription
     */
    async ecpSubscriptionPost(requestParameters: EcpSubscriptionPostRequest, initOverrides?: RequestInit): Promise<CustomerPortalSubscription> {
        const response = await this.ecpSubscriptionPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generate a customer-scoped JWT to authorize access to ECP endpoints. This endpoint expects the vendor API key for authentication.
     * Exchange Access Token
     */
    async ecpTokenPostRaw(requestParameters: EcpTokenPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerPortalToken>> {
        if (requestParameters.customerPortalTokenInputArgs === null || requestParameters.customerPortalTokenInputArgs === undefined) {
            throw new runtime.RequiredError('customerPortalTokenInputArgs','Required parameter requestParameters.customerPortalTokenInputArgs was null or undefined when calling ecpTokenPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ecp/token`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CustomerPortalTokenInputArgsToJSON(requestParameters.customerPortalTokenInputArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerPortalTokenFromJSON(jsonValue));
    }

    /**
     * Generate a customer-scoped JWT to authorize access to ECP endpoints. This endpoint expects the vendor API key for authentication.
     * Exchange Access Token
     */
    async ecpTokenPost(requestParameters: EcpTokenPostRequest, initOverrides?: RequestInit): Promise<CustomerPortalToken> {
        const response = await this.ecpTokenPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the total accrued revenue for a customer broken down by line item until the beginning of the current hour. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Total Accrued Revenue
     */
    async ecpTotalAccruedRevenueGetRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerPortalAccruedRevenue>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ecp/total_accrued_revenue`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerPortalAccruedRevenueFromJSON(jsonValue));
    }

    /**
     * Gets the total accrued revenue for a customer broken down by line item until the beginning of the current hour. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Total Accrued Revenue
     */
    async ecpTotalAccruedRevenueGet(initOverrides?: RequestInit): Promise<CustomerPortalAccruedRevenue> {
        const response = await this.ecpTotalAccruedRevenueGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get relevant information about the customer\'s vendor.This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Vendor Information
     */
    async ecpVendorGetRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerPortalVendor>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ecp/vendor`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerPortalVendorFromJSON(jsonValue));
    }

    /**
     * Get relevant information about the customer\'s vendor.This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Get Vendor Information
     */
    async ecpVendorGet(initOverrides?: RequestInit): Promise<CustomerPortalVendor> {
        const response = await this.ecpVendorGetRaw(initOverrides);
        return await response.value();
    }

}
