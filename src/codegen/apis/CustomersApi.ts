/* tslint:disable */
/* eslint-disable */
/**
 * Octane API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    AccountingCustomer,
    AccountingCustomerFromJSON,
    AccountingCustomerToJSON,
    ActiveSubscription,
    ActiveSubscriptionFromJSON,
    ActiveSubscriptionToJSON,
    BillingSettings,
    BillingSettingsFromJSON,
    BillingSettingsToJSON,
    CreateCustomerArgs,
    CreateCustomerArgsFromJSON,
    CreateCustomerArgsToJSON,
    CreateSubscriptionArgs,
    CreateSubscriptionArgsFromJSON,
    CreateSubscriptionArgsToJSON,
    Customer,
    CustomerFromJSON,
    CustomerToJSON,
    CustomerAvalaraSettings,
    CustomerAvalaraSettingsFromJSON,
    CustomerAvalaraSettingsToJSON,
    CustomerBillingSettingsInputArgs,
    CustomerBillingSettingsInputArgsFromJSON,
    CustomerBillingSettingsInputArgsToJSON,
    CustomerFeature,
    CustomerFeatureFromJSON,
    CustomerFeatureToJSON,
    CustomerMeasurementMapping,
    CustomerMeasurementMappingFromJSON,
    CustomerMeasurementMappingToJSON,
    CustomerMeasurementMappingInputArgs,
    CustomerMeasurementMappingInputArgsFromJSON,
    CustomerMeasurementMappingInputArgsToJSON,
    CustomerMetadata,
    CustomerMetadataFromJSON,
    CustomerMetadataToJSON,
    CustomerPaymentGatewayCredentialInputArgs,
    CustomerPaymentGatewayCredentialInputArgsFromJSON,
    CustomerPaymentGatewayCredentialInputArgsToJSON,
    CustomerPaymentMethodStatus,
    CustomerPaymentMethodStatusFromJSON,
    CustomerPaymentMethodStatusToJSON,
    CustomerStatus,
    CustomerStatusFromJSON,
    CustomerStatusToJSON,
    CustomerUsage,
    CustomerUsageFromJSON,
    CustomerUsageToJSON,
    DeleteDiscountInputArgs,
    DeleteDiscountInputArgsFromJSON,
    DeleteDiscountInputArgsToJSON,
    DeleteSubscriptionArgs,
    DeleteSubscriptionArgsFromJSON,
    DeleteSubscriptionArgsToJSON,
    DiscountInputArgs,
    DiscountInputArgsFromJSON,
    DiscountInputArgsToJSON,
    Invoice,
    InvoiceFromJSON,
    InvoiceToJSON,
    PaymentGatewayCredential,
    PaymentGatewayCredentialFromJSON,
    PaymentGatewayCredentialToJSON,
    RevenueBreakdown,
    RevenueBreakdownFromJSON,
    RevenueBreakdownToJSON,
    RevenueResponse,
    RevenueResponseFromJSON,
    RevenueResponseToJSON,
    Subscription,
    SubscriptionFromJSON,
    SubscriptionToJSON,
    SubscriptionAddOnItem,
    SubscriptionAddOnItemFromJSON,
    SubscriptionAddOnItemToJSON,
    UpdateCustomerArgs,
    UpdateCustomerArgsFromJSON,
    UpdateCustomerArgsToJSON,
    UpdateCustomerAvalaraSettingsArgs,
    UpdateCustomerAvalaraSettingsArgsFromJSON,
    UpdateCustomerAvalaraSettingsArgsToJSON,
    UpdateSubscriptionArgs,
    UpdateSubscriptionArgsFromJSON,
    UpdateSubscriptionArgsToJSON,
    UpdateSubscriptionInPlaceArgs,
    UpdateSubscriptionInPlaceArgsFromJSON,
    UpdateSubscriptionInPlaceArgsToJSON,
    ValidateAddressResp,
    ValidateAddressRespFromJSON,
    ValidateAddressRespToJSON,
} from '../models';

export interface CustomersCustomerNameAccountingGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameAccountingPostRequest {
    customerName: string;
    accountingCustomer: AccountingCustomer;
}

export interface CustomersCustomerNameAccruedRevenueGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameActiveSubscriptionGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameBillingSettingsDeleteRequest {
    customerName: string;
}

export interface CustomersCustomerNameBillingSettingsGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameBillingSettingsPostRequest {
    customerName: string;
    customerBillingSettingsInputArgs: CustomerBillingSettingsInputArgs;
}

export interface CustomersCustomerNameBillingSettingsPutRequest {
    customerName: string;
    customerBillingSettingsInputArgs: CustomerBillingSettingsInputArgs;
}

export interface CustomersCustomerNameDeleteRequest {
    customerName: string;
}

export interface CustomersCustomerNameDiscountsDeleteRequest {
    customerName: string;
    deleteDiscountInputArgs: DeleteDiscountInputArgs;
}

export interface CustomersCustomerNameDiscountsPostRequest {
    customerName: string;
    discountInputArgs: Array<DiscountInputArgs>;
}

export interface CustomersCustomerNameFeaturesFeatureNameGetRequest {
    featureName: string;
    customerName: string;
}

export interface CustomersCustomerNameGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameIntegrationTaxAvalaraAddressValidGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameIntegrationTaxAvalaraSettingsGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameIntegrationTaxAvalaraSettingsPutRequest {
    customerName: string;
    updateCustomerAvalaraSettingsArgs: UpdateCustomerAvalaraSettingsArgs;
}

export interface CustomersCustomerNameInvoiceInvoiceIdTokenGetRequest {
    invoiceId: number;
    token: string;
    customerName: string;
}

export interface CustomersCustomerNameInvoicesGetRequest {
    customerName: string;
    limit?: number;
    status?: string;
    sortDirection?: string;
    sortColumn?: string;
    forwardSecondarySortOffset?: string;
    startTime?: Date;
    customerName2?: string;
    forwardSortOffset?: string;
}

export interface CustomersCustomerNameMappingsGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameMappingsPostRequest {
    customerName: string;
    customerMeasurementMappingInputArgs: CustomerMeasurementMappingInputArgs;
}

export interface CustomersCustomerNameMetadataGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameMetadataPostRequest {
    customerName: string;
    customerMetadata: Array<CustomerMetadata>;
}

export interface CustomersCustomerNamePaymentGatewayCredentialsGetRequest {
    customerName: string;
}

export interface CustomersCustomerNamePaymentGatewayCredentialsPostRequest {
    customerName: string;
    customerPaymentGatewayCredentialInputArgs: CustomerPaymentGatewayCredentialInputArgs;
}

export interface CustomersCustomerNamePaymentMethodStatusGetRequest {
    customerName: string;
}

export interface CustomersCustomerNamePutRequest {
    customerName: string;
    updateCustomerArgs: UpdateCustomerArgs;
}

export interface CustomersCustomerNameRevenueGetRequest {
    customerName: string;
    endTime?: Date;
    startTime?: Date;
}

export interface CustomersCustomerNameSampleInvoiceAsOfStrTokenGetRequest {
    token: string;
    asOfStr: string;
    customerName: string;
}

export interface CustomersCustomerNameSampleInvoiceTokenGetRequest {
    token: string;
    customerName: string;
}

export interface CustomersCustomerNameScheduledSubscriptionsGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameStatusGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameSubscriptionAddOnsPostRequest {
    customerName: string;
    subscriptionAddOnItem: Array<SubscriptionAddOnItem>;
}

export interface CustomersCustomerNameSubscriptionDeleteRequest {
    customerName: string;
    deleteSubscriptionArgs: DeleteSubscriptionArgs;
}

export interface CustomersCustomerNameSubscriptionPutRequest {
    customerName: string;
    updateSubscriptionArgs: UpdateSubscriptionArgs;
}

export interface CustomersCustomerNameSubscriptionUpdateInPlacePutRequest {
    customerName: string;
    updateSubscriptionInPlaceArgs: UpdateSubscriptionInPlaceArgs;
}

export interface CustomersCustomerNameSubscriptionsGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameSubscriptionsPostRequest {
    customerName: string;
    createSubscriptionArgs: CreateSubscriptionArgs;
}

export interface CustomersCustomerNameUsageGetRequest {
    customerName: string;
    meterName?: string;
    endTime?: Date;
    startTime?: Date;
}

export interface CustomersPostRequest {
    createCustomerArgs: CreateCustomerArgs;
}

/**
 * 
 */
export class CustomersApi extends runtime.BaseAPI {

    /**
     * Get the accounting customer ID of a customer that has been connected via an accounting integration.
     * Get Accounting Customer ID
     */
    async customersCustomerNameAccountingGetRaw(requestParameters: CustomersCustomerNameAccountingGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<AccountingCustomer>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameAccountingGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/accounting`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountingCustomerFromJSON(jsonValue));
    }

    /**
     * Get the accounting customer ID of a customer that has been connected via an accounting integration.
     * Get Accounting Customer ID
     */
    async customersCustomerNameAccountingGet(requestParameters: CustomersCustomerNameAccountingGetRequest, initOverrides?: RequestInit): Promise<AccountingCustomer> {
        const response = await this.customersCustomerNameAccountingGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Connect an Octane customer to an Accounting customer through the configured Accounting integration. The vendor must have an integration configured.
     * Connect Accounting Customer
     */
    async customersCustomerNameAccountingPostRaw(requestParameters: CustomersCustomerNameAccountingPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameAccountingPost.');
        }

        if (requestParameters.accountingCustomer === null || requestParameters.accountingCustomer === undefined) {
            throw new runtime.RequiredError('accountingCustomer','Required parameter requestParameters.accountingCustomer was null or undefined when calling customersCustomerNameAccountingPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/accounting`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AccountingCustomerToJSON(requestParameters.accountingCustomer),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Connect an Octane customer to an Accounting customer through the configured Accounting integration. The vendor must have an integration configured.
     * Connect Accounting Customer
     */
    async customersCustomerNameAccountingPost(requestParameters: CustomersCustomerNameAccountingPostRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameAccountingPostRaw(requestParameters, initOverrides);
    }

    /**
     * Get the accrued revenue and invoice line items for the given customer.
     * Get Accrued Revenue
     */
    async customersCustomerNameAccruedRevenueGetRaw(requestParameters: CustomersCustomerNameAccruedRevenueGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RevenueBreakdown>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameAccruedRevenueGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/accrued_revenue`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RevenueBreakdownFromJSON(jsonValue));
    }

    /**
     * Get the accrued revenue and invoice line items for the given customer.
     * Get Accrued Revenue
     */
    async customersCustomerNameAccruedRevenueGet(requestParameters: CustomersCustomerNameAccruedRevenueGetRequest, initOverrides?: RequestInit): Promise<RevenueBreakdown> {
        const response = await this.customersCustomerNameAccruedRevenueGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the customer\'s current active subscription.
     * Get Active Subscription
     */
    async customersCustomerNameActiveSubscriptionGetRaw(requestParameters: CustomersCustomerNameActiveSubscriptionGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<ActiveSubscription>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameActiveSubscriptionGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/active_subscription`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ActiveSubscriptionFromJSON(jsonValue));
    }

    /**
     * Get the customer\'s current active subscription.
     * Get Active Subscription
     */
    async customersCustomerNameActiveSubscriptionGet(requestParameters: CustomersCustomerNameActiveSubscriptionGetRequest, initOverrides?: RequestInit): Promise<ActiveSubscription> {
        const response = await this.customersCustomerNameActiveSubscriptionGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete billing settings for a customer.
     * Delete Billing Settings
     */
    async customersCustomerNameBillingSettingsDeleteRaw(requestParameters: CustomersCustomerNameBillingSettingsDeleteRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameBillingSettingsDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/billing_settings`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete billing settings for a customer.
     * Delete Billing Settings
     */
    async customersCustomerNameBillingSettingsDelete(requestParameters: CustomersCustomerNameBillingSettingsDeleteRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameBillingSettingsDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Fetch the billing settings for a customer.
     * Get Billing Settings
     */
    async customersCustomerNameBillingSettingsGetRaw(requestParameters: CustomersCustomerNameBillingSettingsGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<BillingSettings>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameBillingSettingsGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/billing_settings`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BillingSettingsFromJSON(jsonValue));
    }

    /**
     * Fetch the billing settings for a customer.
     * Get Billing Settings
     */
    async customersCustomerNameBillingSettingsGet(requestParameters: CustomersCustomerNameBillingSettingsGetRequest, initOverrides?: RequestInit): Promise<BillingSettings> {
        const response = await this.customersCustomerNameBillingSettingsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create billing settings for a customer.
     * Create Billing Settings
     */
    async customersCustomerNameBillingSettingsPostRaw(requestParameters: CustomersCustomerNameBillingSettingsPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<BillingSettings>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameBillingSettingsPost.');
        }

        if (requestParameters.customerBillingSettingsInputArgs === null || requestParameters.customerBillingSettingsInputArgs === undefined) {
            throw new runtime.RequiredError('customerBillingSettingsInputArgs','Required parameter requestParameters.customerBillingSettingsInputArgs was null or undefined when calling customersCustomerNameBillingSettingsPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/billing_settings`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CustomerBillingSettingsInputArgsToJSON(requestParameters.customerBillingSettingsInputArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BillingSettingsFromJSON(jsonValue));
    }

    /**
     * Create billing settings for a customer.
     * Create Billing Settings
     */
    async customersCustomerNameBillingSettingsPost(requestParameters: CustomersCustomerNameBillingSettingsPostRequest, initOverrides?: RequestInit): Promise<BillingSettings> {
        const response = await this.customersCustomerNameBillingSettingsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update billing settings for a customer.
     * Update Billing Settings
     */
    async customersCustomerNameBillingSettingsPutRaw(requestParameters: CustomersCustomerNameBillingSettingsPutRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<BillingSettings>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameBillingSettingsPut.');
        }

        if (requestParameters.customerBillingSettingsInputArgs === null || requestParameters.customerBillingSettingsInputArgs === undefined) {
            throw new runtime.RequiredError('customerBillingSettingsInputArgs','Required parameter requestParameters.customerBillingSettingsInputArgs was null or undefined when calling customersCustomerNameBillingSettingsPut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/billing_settings`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CustomerBillingSettingsInputArgsToJSON(requestParameters.customerBillingSettingsInputArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BillingSettingsFromJSON(jsonValue));
    }

    /**
     * Update billing settings for a customer.
     * Update Billing Settings
     */
    async customersCustomerNameBillingSettingsPut(requestParameters: CustomersCustomerNameBillingSettingsPutRequest, initOverrides?: RequestInit): Promise<BillingSettings> {
        const response = await this.customersCustomerNameBillingSettingsPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a customer by their unique name.
     * Delete Customer
     */
    async customersCustomerNameDeleteRaw(requestParameters: CustomersCustomerNameDeleteRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a customer by their unique name.
     * Delete Customer
     */
    async customersCustomerNameDelete(requestParameters: CustomersCustomerNameDeleteRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a discount from the customer\'s current subscription. If the discount started before the start of the current billing cycle, we will expire it by setting it\'s end date to the start of the current billing cycle. Otherwise, we will delete the discount.
     * Delete Discount
     */
    async customersCustomerNameDiscountsDeleteRaw(requestParameters: CustomersCustomerNameDiscountsDeleteRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameDiscountsDelete.');
        }

        if (requestParameters.deleteDiscountInputArgs === null || requestParameters.deleteDiscountInputArgs === undefined) {
            throw new runtime.RequiredError('deleteDiscountInputArgs','Required parameter requestParameters.deleteDiscountInputArgs was null or undefined when calling customersCustomerNameDiscountsDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/discounts`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: DeleteDiscountInputArgsToJSON(requestParameters.deleteDiscountInputArgs),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a discount from the customer\'s current subscription. If the discount started before the start of the current billing cycle, we will expire it by setting it\'s end date to the start of the current billing cycle. Otherwise, we will delete the discount.
     * Delete Discount
     */
    async customersCustomerNameDiscountsDelete(requestParameters: CustomersCustomerNameDiscountsDeleteRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameDiscountsDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Add discounts to the list of discounts on the customer\'s current subscription. The new discounts will be effective_at of the start of the current billing cycle.
     * Add Discounts to a Subscription
     */
    async customersCustomerNameDiscountsPostRaw(requestParameters: CustomersCustomerNameDiscountsPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameDiscountsPost.');
        }

        if (requestParameters.discountInputArgs === null || requestParameters.discountInputArgs === undefined) {
            throw new runtime.RequiredError('discountInputArgs','Required parameter requestParameters.discountInputArgs was null or undefined when calling customersCustomerNameDiscountsPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/discounts`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.discountInputArgs.map(DiscountInputArgsToJSON),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Add discounts to the list of discounts on the customer\'s current subscription. The new discounts will be effective_at of the start of the current billing cycle.
     * Add Discounts to a Subscription
     */
    async customersCustomerNameDiscountsPost(requestParameters: CustomersCustomerNameDiscountsPostRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameDiscountsPostRaw(requestParameters, initOverrides);
    }

    /**
     * Get the details of a feature for a given customer. The feature\'s status is determined by their subscription first, and by their price plan if no feature overrides are found on the subscription.
     * Get Feature Status
     */
    async customersCustomerNameFeaturesFeatureNameGetRaw(requestParameters: CustomersCustomerNameFeaturesFeatureNameGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerFeature>> {
        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling customersCustomerNameFeaturesFeatureNameGet.');
        }

        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameFeaturesFeatureNameGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/features/{feature_name}`.replace(`{${"feature_name"}}`, encodeURIComponent(String(requestParameters.featureName))).replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerFeatureFromJSON(jsonValue));
    }

    /**
     * Get the details of a feature for a given customer. The feature\'s status is determined by their subscription first, and by their price plan if no feature overrides are found on the subscription.
     * Get Feature Status
     */
    async customersCustomerNameFeaturesFeatureNameGet(requestParameters: CustomersCustomerNameFeaturesFeatureNameGetRequest, initOverrides?: RequestInit): Promise<CustomerFeature> {
        const response = await this.customersCustomerNameFeaturesFeatureNameGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch a customer by their unique name.
     * Get Customer
     */
    async customersCustomerNameGetRaw(requestParameters: CustomersCustomerNameGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Customer>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerFromJSON(jsonValue));
    }

    /**
     * Fetch a customer by their unique name.
     * Get Customer
     */
    async customersCustomerNameGet(requestParameters: CustomersCustomerNameGetRequest, initOverrides?: RequestInit): Promise<Customer> {
        const response = await this.customersCustomerNameGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Validates to ensure that customer address is taxable via Avalara.
     * Validate customer address.
     */
    async customersCustomerNameIntegrationTaxAvalaraAddressValidGetRaw(requestParameters: CustomersCustomerNameIntegrationTaxAvalaraAddressValidGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<ValidateAddressResp>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameIntegrationTaxAvalaraAddressValidGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/integration/tax/avalara/address/valid`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ValidateAddressRespFromJSON(jsonValue));
    }

    /**
     * Validates to ensure that customer address is taxable via Avalara.
     * Validate customer address.
     */
    async customersCustomerNameIntegrationTaxAvalaraAddressValidGet(requestParameters: CustomersCustomerNameIntegrationTaxAvalaraAddressValidGetRequest, initOverrides?: RequestInit): Promise<ValidateAddressResp> {
        const response = await this.customersCustomerNameIntegrationTaxAvalaraAddressValidGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the customer Avalara settings.
     * Get Customer Avalara Settings
     */
    async customersCustomerNameIntegrationTaxAvalaraSettingsGetRaw(requestParameters: CustomersCustomerNameIntegrationTaxAvalaraSettingsGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerAvalaraSettings>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameIntegrationTaxAvalaraSettingsGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/integration/tax/avalara/settings`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerAvalaraSettingsFromJSON(jsonValue));
    }

    /**
     * Returns the customer Avalara settings.
     * Get Customer Avalara Settings
     */
    async customersCustomerNameIntegrationTaxAvalaraSettingsGet(requestParameters: CustomersCustomerNameIntegrationTaxAvalaraSettingsGetRequest, initOverrides?: RequestInit): Promise<CustomerAvalaraSettings> {
        const response = await this.customersCustomerNameIntegrationTaxAvalaraSettingsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates the Avalara settings for a specific customer.
     * Update customer Avalara settings
     */
    async customersCustomerNameIntegrationTaxAvalaraSettingsPutRaw(requestParameters: CustomersCustomerNameIntegrationTaxAvalaraSettingsPutRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerAvalaraSettings>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameIntegrationTaxAvalaraSettingsPut.');
        }

        if (requestParameters.updateCustomerAvalaraSettingsArgs === null || requestParameters.updateCustomerAvalaraSettingsArgs === undefined) {
            throw new runtime.RequiredError('updateCustomerAvalaraSettingsArgs','Required parameter requestParameters.updateCustomerAvalaraSettingsArgs was null or undefined when calling customersCustomerNameIntegrationTaxAvalaraSettingsPut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/integration/tax/avalara/settings`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateCustomerAvalaraSettingsArgsToJSON(requestParameters.updateCustomerAvalaraSettingsArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerAvalaraSettingsFromJSON(jsonValue));
    }

    /**
     * Updates the Avalara settings for a specific customer.
     * Update customer Avalara settings
     */
    async customersCustomerNameIntegrationTaxAvalaraSettingsPut(requestParameters: CustomersCustomerNameIntegrationTaxAvalaraSettingsPutRequest, initOverrides?: RequestInit): Promise<CustomerAvalaraSettings> {
        const response = await this.customersCustomerNameIntegrationTaxAvalaraSettingsPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * Generate Current Invoice
     */
    async customersCustomerNameInvoiceInvoiceIdTokenGetRaw(requestParameters: CustomersCustomerNameInvoiceInvoiceIdTokenGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Error>> {
        if (requestParameters.invoiceId === null || requestParameters.invoiceId === undefined) {
            throw new runtime.RequiredError('invoiceId','Required parameter requestParameters.invoiceId was null or undefined when calling customersCustomerNameInvoiceInvoiceIdTokenGet.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling customersCustomerNameInvoiceInvoiceIdTokenGet.');
        }

        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameInvoiceInvoiceIdTokenGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/invoice/{invoice_id}/{token}`.replace(`{${"invoice_id"}}`, encodeURIComponent(String(requestParameters.invoiceId))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters.token))).replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * Generate Current Invoice
     */
    async customersCustomerNameInvoiceInvoiceIdTokenGet(requestParameters: CustomersCustomerNameInvoiceInvoiceIdTokenGetRequest, initOverrides?: RequestInit): Promise<Error> {
        const response = await this.customersCustomerNameInvoiceInvoiceIdTokenGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of invoices and their line items for a customer.
     * Get Customer Invoices
     */
    async customersCustomerNameInvoicesGetRaw(requestParameters: CustomersCustomerNameInvoicesGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<Invoice>>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameInvoicesGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.status !== undefined) {
            queryParameters['status'] = requestParameters.status;
        }

        if (requestParameters.sortDirection !== undefined) {
            queryParameters['sort_direction'] = requestParameters.sortDirection;
        }

        if (requestParameters.sortColumn !== undefined) {
            queryParameters['sort_column'] = requestParameters.sortColumn;
        }

        if (requestParameters.forwardSecondarySortOffset !== undefined) {
            queryParameters['forward_secondary_sort_offset'] = requestParameters.forwardSecondarySortOffset;
        }

        if (requestParameters.startTime !== undefined) {
            queryParameters['start_time'] = (requestParameters.startTime as any).toISOString();
        }

        if (requestParameters.customerName2 !== undefined) {
            queryParameters['customer_name'] = requestParameters.customerName2;
        }

        if (requestParameters.forwardSortOffset !== undefined) {
            queryParameters['forward_sort_offset'] = requestParameters.forwardSortOffset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/invoices`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(InvoiceFromJSON));
    }

    /**
     * Get a list of invoices and their line items for a customer.
     * Get Customer Invoices
     */
    async customersCustomerNameInvoicesGet(requestParameters: CustomersCustomerNameInvoicesGetRequest, initOverrides?: RequestInit): Promise<Array<Invoice>> {
        const response = await this.customersCustomerNameInvoicesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch all measurement mappings for a specific customer (by unique customer name).
     * Get Measurement Mappings
     */
    async customersCustomerNameMappingsGetRaw(requestParameters: CustomersCustomerNameMappingsGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<CustomerMeasurementMapping>>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameMappingsGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/mappings`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CustomerMeasurementMappingFromJSON));
    }

    /**
     * Fetch all measurement mappings for a specific customer (by unique customer name).
     * Get Measurement Mappings
     */
    async customersCustomerNameMappingsGet(requestParameters: CustomersCustomerNameMappingsGetRequest, initOverrides?: RequestInit): Promise<Array<CustomerMeasurementMapping>> {
        const response = await this.customersCustomerNameMappingsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new measurement mapping for a customer. If no value_regex is passed, label existence is checked instead.
     * Append Measurement Mapping
     */
    async customersCustomerNameMappingsPostRaw(requestParameters: CustomersCustomerNameMappingsPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerMeasurementMapping>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameMappingsPost.');
        }

        if (requestParameters.customerMeasurementMappingInputArgs === null || requestParameters.customerMeasurementMappingInputArgs === undefined) {
            throw new runtime.RequiredError('customerMeasurementMappingInputArgs','Required parameter requestParameters.customerMeasurementMappingInputArgs was null or undefined when calling customersCustomerNameMappingsPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/mappings`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CustomerMeasurementMappingInputArgsToJSON(requestParameters.customerMeasurementMappingInputArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerMeasurementMappingFromJSON(jsonValue));
    }

    /**
     * Create a new measurement mapping for a customer. If no value_regex is passed, label existence is checked instead.
     * Append Measurement Mapping
     */
    async customersCustomerNameMappingsPost(requestParameters: CustomersCustomerNameMappingsPostRequest, initOverrides?: RequestInit): Promise<CustomerMeasurementMapping> {
        const response = await this.customersCustomerNameMappingsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the metadata for a given customer
     * Get All Customer Metadata
     */
    async customersCustomerNameMetadataGetRaw(requestParameters: CustomersCustomerNameMetadataGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Error>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameMetadataGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/metadata`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Get the metadata for a given customer
     * Get All Customer Metadata
     */
    async customersCustomerNameMetadataGet(requestParameters: CustomersCustomerNameMetadataGetRequest, initOverrides?: RequestInit): Promise<Error> {
        const response = await this.customersCustomerNameMetadataGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add metadata to a customer (e.g., a tuple of Region: US for a US based customer)
     * Add metadata to a customer
     */
    async customersCustomerNameMetadataPostRaw(requestParameters: CustomersCustomerNameMetadataPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameMetadataPost.');
        }

        if (requestParameters.customerMetadata === null || requestParameters.customerMetadata === undefined) {
            throw new runtime.RequiredError('customerMetadata','Required parameter requestParameters.customerMetadata was null or undefined when calling customersCustomerNameMetadataPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/metadata`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.customerMetadata.map(CustomerMetadataToJSON),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Add metadata to a customer (e.g., a tuple of Region: US for a US based customer)
     * Add metadata to a customer
     */
    async customersCustomerNameMetadataPost(requestParameters: CustomersCustomerNameMetadataPostRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameMetadataPostRaw(requestParameters, initOverrides);
    }

    /**
     * Get the payment gateway credentials from the vendor\'s configured payment gateway for the given customer. For example, this endpoint will return a customer\'s Stripe customer ID, assuming the vendor has integrated with stripe and has configured the given customer with a Stripe customer ID.
     * Get PaymentGatewayCredential
     */
    async customersCustomerNamePaymentGatewayCredentialsGetRaw(requestParameters: CustomersCustomerNamePaymentGatewayCredentialsGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PaymentGatewayCredential>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNamePaymentGatewayCredentialsGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/payment_gateway_credentials`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaymentGatewayCredentialFromJSON(jsonValue));
    }

    /**
     * Get the payment gateway credentials from the vendor\'s configured payment gateway for the given customer. For example, this endpoint will return a customer\'s Stripe customer ID, assuming the vendor has integrated with stripe and has configured the given customer with a Stripe customer ID.
     * Get PaymentGatewayCredential
     */
    async customersCustomerNamePaymentGatewayCredentialsGet(requestParameters: CustomersCustomerNamePaymentGatewayCredentialsGetRequest, initOverrides?: RequestInit): Promise<PaymentGatewayCredential> {
        const response = await this.customersCustomerNamePaymentGatewayCredentialsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add credentials for a customer\'s account in the vendor\'s currently configured payment gateway. For example, this endpoint can be used to associate a customer with a Stripe customer ID.
     * Add PaymentGatewayCredential
     */
    async customersCustomerNamePaymentGatewayCredentialsPostRaw(requestParameters: CustomersCustomerNamePaymentGatewayCredentialsPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PaymentGatewayCredential>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNamePaymentGatewayCredentialsPost.');
        }

        if (requestParameters.customerPaymentGatewayCredentialInputArgs === null || requestParameters.customerPaymentGatewayCredentialInputArgs === undefined) {
            throw new runtime.RequiredError('customerPaymentGatewayCredentialInputArgs','Required parameter requestParameters.customerPaymentGatewayCredentialInputArgs was null or undefined when calling customersCustomerNamePaymentGatewayCredentialsPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/payment_gateway_credentials`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CustomerPaymentGatewayCredentialInputArgsToJSON(requestParameters.customerPaymentGatewayCredentialInputArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaymentGatewayCredentialFromJSON(jsonValue));
    }

    /**
     * Add credentials for a customer\'s account in the vendor\'s currently configured payment gateway. For example, this endpoint can be used to associate a customer with a Stripe customer ID.
     * Add PaymentGatewayCredential
     */
    async customersCustomerNamePaymentGatewayCredentialsPost(requestParameters: CustomersCustomerNamePaymentGatewayCredentialsPostRequest, initOverrides?: RequestInit): Promise<PaymentGatewayCredential> {
        const response = await this.customersCustomerNamePaymentGatewayCredentialsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch payment method status for a specific customer (by unique customer name).
     * Get Customer Payment Method Status
     */
    async customersCustomerNamePaymentMethodStatusGetRaw(requestParameters: CustomersCustomerNamePaymentMethodStatusGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerPaymentMethodStatus>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNamePaymentMethodStatusGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/payment_method_status`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerPaymentMethodStatusFromJSON(jsonValue));
    }

    /**
     * Fetch payment method status for a specific customer (by unique customer name).
     * Get Customer Payment Method Status
     */
    async customersCustomerNamePaymentMethodStatusGet(requestParameters: CustomersCustomerNamePaymentMethodStatusGetRequest, initOverrides?: RequestInit): Promise<CustomerPaymentMethodStatus> {
        const response = await this.customersCustomerNamePaymentMethodStatusGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a single customer. To update Customer measurement mappings, use the `customers/{customer_name}/mappings` endpoint.
     * Update Customer
     */
    async customersCustomerNamePutRaw(requestParameters: CustomersCustomerNamePutRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Customer>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNamePut.');
        }

        if (requestParameters.updateCustomerArgs === null || requestParameters.updateCustomerArgs === undefined) {
            throw new runtime.RequiredError('updateCustomerArgs','Required parameter requestParameters.updateCustomerArgs was null or undefined when calling customersCustomerNamePut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateCustomerArgsToJSON(requestParameters.updateCustomerArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerFromJSON(jsonValue));
    }

    /**
     * Update a single customer. To update Customer measurement mappings, use the `customers/{customer_name}/mappings` endpoint.
     * Update Customer
     */
    async customersCustomerNamePut(requestParameters: CustomersCustomerNamePutRequest, initOverrides?: RequestInit): Promise<Customer> {
        const response = await this.customersCustomerNamePutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch revenue of a customer from start_time and end_time.
     * Get Customer Revenue
     */
    async customersCustomerNameRevenueGetRaw(requestParameters: CustomersCustomerNameRevenueGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RevenueResponse>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameRevenueGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.endTime !== undefined) {
            queryParameters['end_time'] = (requestParameters.endTime as any).toISOString();
        }

        if (requestParameters.startTime !== undefined) {
            queryParameters['start_time'] = (requestParameters.startTime as any).toISOString();
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/revenue`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RevenueResponseFromJSON(jsonValue));
    }

    /**
     * Fetch revenue of a customer from start_time and end_time.
     * Get Customer Revenue
     */
    async customersCustomerNameRevenueGet(requestParameters: CustomersCustomerNameRevenueGetRequest, initOverrides?: RequestInit): Promise<RevenueResponse> {
        const response = await this.customersCustomerNameRevenueGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * Generate Current Invoice
     */
    async customersCustomerNameSampleInvoiceAsOfStrTokenGetRaw(requestParameters: CustomersCustomerNameSampleInvoiceAsOfStrTokenGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Error>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling customersCustomerNameSampleInvoiceAsOfStrTokenGet.');
        }

        if (requestParameters.asOfStr === null || requestParameters.asOfStr === undefined) {
            throw new runtime.RequiredError('asOfStr','Required parameter requestParameters.asOfStr was null or undefined when calling customersCustomerNameSampleInvoiceAsOfStrTokenGet.');
        }

        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSampleInvoiceAsOfStrTokenGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/sample_invoice/{as_of_str}/{token}`.replace(`{${"token"}}`, encodeURIComponent(String(requestParameters.token))).replace(`{${"as_of_str"}}`, encodeURIComponent(String(requestParameters.asOfStr))).replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * Generate Current Invoice
     */
    async customersCustomerNameSampleInvoiceAsOfStrTokenGet(requestParameters: CustomersCustomerNameSampleInvoiceAsOfStrTokenGetRequest, initOverrides?: RequestInit): Promise<Error> {
        const response = await this.customersCustomerNameSampleInvoiceAsOfStrTokenGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * Generate Current Invoice
     */
    async customersCustomerNameSampleInvoiceTokenGetRaw(requestParameters: CustomersCustomerNameSampleInvoiceTokenGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Error>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling customersCustomerNameSampleInvoiceTokenGet.');
        }

        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSampleInvoiceTokenGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/sample_invoice/{token}`.replace(`{${"token"}}`, encodeURIComponent(String(requestParameters.token))).replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * Generate Current Invoice
     */
    async customersCustomerNameSampleInvoiceTokenGet(requestParameters: CustomersCustomerNameSampleInvoiceTokenGetRequest, initOverrides?: RequestInit): Promise<Error> {
        const response = await this.customersCustomerNameSampleInvoiceTokenGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of any subscriptions scheduled to start in the future for the given customer.
     * Get Scheduled Subscriptions
     */
    async customersCustomerNameScheduledSubscriptionsGetRaw(requestParameters: CustomersCustomerNameScheduledSubscriptionsGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<Subscription>>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameScheduledSubscriptionsGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/scheduled_subscriptions`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SubscriptionFromJSON));
    }

    /**
     * Get a list of any subscriptions scheduled to start in the future for the given customer.
     * Get Scheduled Subscriptions
     */
    async customersCustomerNameScheduledSubscriptionsGet(requestParameters: CustomersCustomerNameScheduledSubscriptionsGetRequest, initOverrides?: RequestInit): Promise<Array<Subscription>> {
        const response = await this.customersCustomerNameScheduledSubscriptionsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the current status for a customer.
     * Get Customer Status
     */
    async customersCustomerNameStatusGetRaw(requestParameters: CustomersCustomerNameStatusGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerStatus>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameStatusGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/status`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerStatusFromJSON(jsonValue));
    }

    /**
     * Get the current status for a customer.
     * Get Customer Status
     */
    async customersCustomerNameStatusGet(requestParameters: CustomersCustomerNameStatusGetRequest, initOverrides?: RequestInit): Promise<CustomerStatus> {
        const response = await this.customersCustomerNameStatusGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add or remove add ons from the current customer\'s subscription.
     * Modify Add Ons on Subscription
     */
    async customersCustomerNameSubscriptionAddOnsPostRaw(requestParameters: CustomersCustomerNameSubscriptionAddOnsPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSubscriptionAddOnsPost.');
        }

        if (requestParameters.subscriptionAddOnItem === null || requestParameters.subscriptionAddOnItem === undefined) {
            throw new runtime.RequiredError('subscriptionAddOnItem','Required parameter requestParameters.subscriptionAddOnItem was null or undefined when calling customersCustomerNameSubscriptionAddOnsPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/subscription/add_ons`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.subscriptionAddOnItem.map(SubscriptionAddOnItemToJSON),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Add or remove add ons from the current customer\'s subscription.
     * Modify Add Ons on Subscription
     */
    async customersCustomerNameSubscriptionAddOnsPost(requestParameters: CustomersCustomerNameSubscriptionAddOnsPostRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameSubscriptionAddOnsPostRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a subscription for a specific customer (by customer name).
     * Delete Subscription
     */
    async customersCustomerNameSubscriptionDeleteRaw(requestParameters: CustomersCustomerNameSubscriptionDeleteRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSubscriptionDelete.');
        }

        if (requestParameters.deleteSubscriptionArgs === null || requestParameters.deleteSubscriptionArgs === undefined) {
            throw new runtime.RequiredError('deleteSubscriptionArgs','Required parameter requestParameters.deleteSubscriptionArgs was null or undefined when calling customersCustomerNameSubscriptionDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/subscription`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: DeleteSubscriptionArgsToJSON(requestParameters.deleteSubscriptionArgs),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a subscription for a specific customer (by customer name).
     * Delete Subscription
     */
    async customersCustomerNameSubscriptionDelete(requestParameters: CustomersCustomerNameSubscriptionDeleteRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameSubscriptionDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Update a subscription for a specific customer (by customer name).
     * Update Subscription
     */
    async customersCustomerNameSubscriptionPutRaw(requestParameters: CustomersCustomerNameSubscriptionPutRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Subscription>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSubscriptionPut.');
        }

        if (requestParameters.updateSubscriptionArgs === null || requestParameters.updateSubscriptionArgs === undefined) {
            throw new runtime.RequiredError('updateSubscriptionArgs','Required parameter requestParameters.updateSubscriptionArgs was null or undefined when calling customersCustomerNameSubscriptionPut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/subscription`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateSubscriptionArgsToJSON(requestParameters.updateSubscriptionArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubscriptionFromJSON(jsonValue));
    }

    /**
     * Update a subscription for a specific customer (by customer name).
     * Update Subscription
     */
    async customersCustomerNameSubscriptionPut(requestParameters: CustomersCustomerNameSubscriptionPutRequest, initOverrides?: RequestInit): Promise<Subscription> {
        const response = await this.customersCustomerNameSubscriptionPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a subscription in-place for a specific customer (by customer name).
     * Update Subscription In-Place
     */
    async customersCustomerNameSubscriptionUpdateInPlacePutRaw(requestParameters: CustomersCustomerNameSubscriptionUpdateInPlacePutRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Subscription>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSubscriptionUpdateInPlacePut.');
        }

        if (requestParameters.updateSubscriptionInPlaceArgs === null || requestParameters.updateSubscriptionInPlaceArgs === undefined) {
            throw new runtime.RequiredError('updateSubscriptionInPlaceArgs','Required parameter requestParameters.updateSubscriptionInPlaceArgs was null or undefined when calling customersCustomerNameSubscriptionUpdateInPlacePut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/subscription/update_in_place`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateSubscriptionInPlaceArgsToJSON(requestParameters.updateSubscriptionInPlaceArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubscriptionFromJSON(jsonValue));
    }

    /**
     * Update a subscription in-place for a specific customer (by customer name).
     * Update Subscription In-Place
     */
    async customersCustomerNameSubscriptionUpdateInPlacePut(requestParameters: CustomersCustomerNameSubscriptionUpdateInPlacePutRequest, initOverrides?: RequestInit): Promise<Subscription> {
        const response = await this.customersCustomerNameSubscriptionUpdateInPlacePutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all subscriptions for the customer.
     * Get Subscriptions
     */
    async customersCustomerNameSubscriptionsGetRaw(requestParameters: CustomersCustomerNameSubscriptionsGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<Subscription>>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSubscriptionsGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/subscriptions`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SubscriptionFromJSON));
    }

    /**
     * Get all subscriptions for the customer.
     * Get Subscriptions
     */
    async customersCustomerNameSubscriptionsGet(requestParameters: CustomersCustomerNameSubscriptionsGetRequest, initOverrides?: RequestInit): Promise<Array<Subscription>> {
        const response = await this.customersCustomerNameSubscriptionsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new subscription for a customer / price plan combination (by unique name).
     * Create Subscription
     */
    async customersCustomerNameSubscriptionsPostRaw(requestParameters: CustomersCustomerNameSubscriptionsPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Subscription>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSubscriptionsPost.');
        }

        if (requestParameters.createSubscriptionArgs === null || requestParameters.createSubscriptionArgs === undefined) {
            throw new runtime.RequiredError('createSubscriptionArgs','Required parameter requestParameters.createSubscriptionArgs was null or undefined when calling customersCustomerNameSubscriptionsPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/subscriptions`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateSubscriptionArgsToJSON(requestParameters.createSubscriptionArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubscriptionFromJSON(jsonValue));
    }

    /**
     * Create a new subscription for a customer / price plan combination (by unique name).
     * Create Subscription
     */
    async customersCustomerNameSubscriptionsPost(requestParameters: CustomersCustomerNameSubscriptionsPostRequest, initOverrides?: RequestInit): Promise<Subscription> {
        const response = await this.customersCustomerNameSubscriptionsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * For the given meter, get a customer\'s total usage.
     * Get Usage By Meter
     */
    async customersCustomerNameUsageGetRaw(requestParameters: CustomersCustomerNameUsageGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerUsage>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameUsageGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.meterName !== undefined) {
            queryParameters['meter_name'] = requestParameters.meterName;
        }

        if (requestParameters.endTime !== undefined) {
            queryParameters['end_time'] = (requestParameters.endTime as any).toISOString();
        }

        if (requestParameters.startTime !== undefined) {
            queryParameters['start_time'] = (requestParameters.startTime as any).toISOString();
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/usage`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerUsageFromJSON(jsonValue));
    }

    /**
     * For the given meter, get a customer\'s total usage.
     * Get Usage By Meter
     */
    async customersCustomerNameUsageGet(requestParameters: CustomersCustomerNameUsageGetRequest, initOverrides?: RequestInit): Promise<CustomerUsage> {
        const response = await this.customersCustomerNameUsageGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all customers for a given vendor.
     * Get All Customers
     */
    async customersGetRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<Customer>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CustomerFromJSON));
    }

    /**
     * Retrieve all customers for a given vendor.
     * Get All Customers
     */
    async customersGet(initOverrides?: RequestInit): Promise<Array<Customer>> {
        const response = await this.customersGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Create a new customer.
     * Create Customer
     */
    async customersPostRaw(requestParameters: CustomersPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Customer>> {
        if (requestParameters.createCustomerArgs === null || requestParameters.createCustomerArgs === undefined) {
            throw new runtime.RequiredError('createCustomerArgs','Required parameter requestParameters.createCustomerArgs was null or undefined when calling customersPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateCustomerArgsToJSON(requestParameters.createCustomerArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerFromJSON(jsonValue));
    }

    /**
     * Create a new customer.
     * Create Customer
     */
    async customersPost(requestParameters: CustomersPostRequest, initOverrides?: RequestInit): Promise<Customer> {
        const response = await this.customersPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
