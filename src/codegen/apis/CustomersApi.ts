/* tslint:disable */
/* eslint-disable */
/**
 * Octane API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ActiveSubscription,
    ActiveSubscriptionFromJSON,
    ActiveSubscriptionToJSON,
    BillingSettings,
    BillingSettingsFromJSON,
    BillingSettingsToJSON,
    CreateBillingSettingsInputArgs,
    CreateBillingSettingsInputArgsFromJSON,
    CreateBillingSettingsInputArgsToJSON,
    CreateCustomerArgs,
    CreateCustomerArgsFromJSON,
    CreateCustomerArgsToJSON,
    CreateSubscriptionArgs,
    CreateSubscriptionArgsFromJSON,
    CreateSubscriptionArgsToJSON,
    Customer,
    CustomerFromJSON,
    CustomerToJSON,
    CustomerFeature,
    CustomerFeatureFromJSON,
    CustomerFeatureToJSON,
    CustomerMeasurementMapping,
    CustomerMeasurementMappingFromJSON,
    CustomerMeasurementMappingToJSON,
    CustomerMeasurementMappingInputArgs,
    CustomerMeasurementMappingInputArgsFromJSON,
    CustomerMeasurementMappingInputArgsToJSON,
    CustomerPaymentGatewayCredentialInputArgs,
    CustomerPaymentGatewayCredentialInputArgsFromJSON,
    CustomerPaymentGatewayCredentialInputArgsToJSON,
    CustomerPaymentMethodStatus,
    CustomerPaymentMethodStatusFromJSON,
    CustomerPaymentMethodStatusToJSON,
    CustomerStatus,
    CustomerStatusFromJSON,
    CustomerStatusToJSON,
    CustomerUsage,
    CustomerUsageFromJSON,
    CustomerUsageToJSON,
    DeleteSubscriptionArgs,
    DeleteSubscriptionArgsFromJSON,
    DeleteSubscriptionArgsToJSON,
    Invoice,
    InvoiceFromJSON,
    InvoiceToJSON,
    PaymentGatewayCredential,
    PaymentGatewayCredentialFromJSON,
    PaymentGatewayCredentialToJSON,
    RevenueBreakdown,
    RevenueBreakdownFromJSON,
    RevenueBreakdownToJSON,
    RevenueResponse,
    RevenueResponseFromJSON,
    RevenueResponseToJSON,
    Subscription,
    SubscriptionFromJSON,
    SubscriptionToJSON,
    UpdateBillingSettingsInputArgs,
    UpdateBillingSettingsInputArgsFromJSON,
    UpdateBillingSettingsInputArgsToJSON,
    UpdateCustomerArgs,
    UpdateCustomerArgsFromJSON,
    UpdateCustomerArgsToJSON,
    UpdateSubscriptionArgs,
    UpdateSubscriptionArgsFromJSON,
    UpdateSubscriptionArgsToJSON,
    UpdateSubscriptionInPlaceArgs,
    UpdateSubscriptionInPlaceArgsFromJSON,
    UpdateSubscriptionInPlaceArgsToJSON,
} from '../models';

export interface CustomersCustomerNameAccruedRevenueGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameActiveSubscriptionGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameBillingSettingsDeleteRequest {
    customerName: string;
}

export interface CustomersCustomerNameBillingSettingsGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameBillingSettingsPostRequest {
    customerName: string;
    createBillingSettingsInputArgs: CreateBillingSettingsInputArgs;
}

export interface CustomersCustomerNameBillingSettingsPutRequest {
    customerName: string;
    updateBillingSettingsInputArgs: UpdateBillingSettingsInputArgs;
}

export interface CustomersCustomerNameDeleteRequest {
    customerName: string;
}

export interface CustomersCustomerNameFeaturesFeatureNameGetRequest {
    featureName: string;
    customerName: string;
}

export interface CustomersCustomerNameGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameInvoiceInvoiceIdTokenGetRequest {
    token: string;
    customerName: string;
    invoiceId: number;
}

export interface CustomersCustomerNameInvoicesGetRequest {
    customerName: string;
    forwardSortOffset?: string;
    forwardSecondarySortOffset?: number;
    backwardSecondarySortOffset?: number;
    backwardSortOffset?: string;
    limit?: number;
    customerName2?: string;
    status?: string;
    sortColumn?: string;
    startTime?: Date;
    sortDirection?: string;
}

export interface CustomersCustomerNameMappingsGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameMappingsPostRequest {
    customerName: string;
    customerMeasurementMappingInputArgs: CustomerMeasurementMappingInputArgs;
}

export interface CustomersCustomerNamePaymentGatewayCredentialsGetRequest {
    customerName: string;
}

export interface CustomersCustomerNamePaymentGatewayCredentialsPostRequest {
    customerName: string;
    customerPaymentGatewayCredentialInputArgs: CustomerPaymentGatewayCredentialInputArgs;
}

export interface CustomersCustomerNamePaymentMethodStatusGetRequest {
    customerName: string;
}

export interface CustomersCustomerNamePutRequest {
    customerName: string;
    updateCustomerArgs: UpdateCustomerArgs;
}

export interface CustomersCustomerNameRevenueGetRequest {
    customerName: string;
    endTime?: Date;
    startTime?: Date;
}

export interface CustomersCustomerNameSampleInvoiceAsOfStrTokenGetRequest {
    token: string;
    asOfStr: string;
    customerName: string;
}

export interface CustomersCustomerNameSampleInvoiceTokenGetRequest {
    token: string;
    customerName: string;
}

export interface CustomersCustomerNameScheduledSubscriptionsGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameStatusGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameSubscriptionDeleteRequest {
    customerName: string;
    deleteSubscriptionArgs: DeleteSubscriptionArgs;
}

export interface CustomersCustomerNameSubscriptionPutRequest {
    customerName: string;
    updateSubscriptionArgs: UpdateSubscriptionArgs;
}

export interface CustomersCustomerNameSubscriptionUpdateInPlacePutRequest {
    customerName: string;
    updateSubscriptionInPlaceArgs: UpdateSubscriptionInPlaceArgs;
}

export interface CustomersCustomerNameSubscriptionsGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameSubscriptionsPostRequest {
    customerName: string;
    createSubscriptionArgs: CreateSubscriptionArgs;
}

export interface CustomersCustomerNameUsageGetRequest {
    customerName: string;
    endTime?: Date;
    startTime?: Date;
    meterName?: string;
}

export interface CustomersPostRequest {
    createCustomerArgs: CreateCustomerArgs;
}

/**
 * 
 */
export class CustomersApi extends runtime.BaseAPI {

    /**
     */
    async customersCustomerNameAccruedRevenueGetRaw(requestParameters: CustomersCustomerNameAccruedRevenueGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RevenueBreakdown>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameAccruedRevenueGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/accrued_revenue`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RevenueBreakdownFromJSON(jsonValue));
    }

    /**
     */
    async customersCustomerNameAccruedRevenueGet(requestParameters: CustomersCustomerNameAccruedRevenueGetRequest, initOverrides?: RequestInit): Promise<RevenueBreakdown> {
        const response = await this.customersCustomerNameAccruedRevenueGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async customersCustomerNameActiveSubscriptionGetRaw(requestParameters: CustomersCustomerNameActiveSubscriptionGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<ActiveSubscription>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameActiveSubscriptionGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/active_subscription`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ActiveSubscriptionFromJSON(jsonValue));
    }

    /**
     */
    async customersCustomerNameActiveSubscriptionGet(requestParameters: CustomersCustomerNameActiveSubscriptionGetRequest, initOverrides?: RequestInit): Promise<ActiveSubscription> {
        const response = await this.customersCustomerNameActiveSubscriptionGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete billing settings for a customer.
     * Delete Billing Settings
     */
    async customersCustomerNameBillingSettingsDeleteRaw(requestParameters: CustomersCustomerNameBillingSettingsDeleteRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameBillingSettingsDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/billing_settings`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete billing settings for a customer.
     * Delete Billing Settings
     */
    async customersCustomerNameBillingSettingsDelete(requestParameters: CustomersCustomerNameBillingSettingsDeleteRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameBillingSettingsDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Fetch the billing settings for a customer.
     * Get Billing Settings
     */
    async customersCustomerNameBillingSettingsGetRaw(requestParameters: CustomersCustomerNameBillingSettingsGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<BillingSettings>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameBillingSettingsGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/billing_settings`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BillingSettingsFromJSON(jsonValue));
    }

    /**
     * Fetch the billing settings for a customer.
     * Get Billing Settings
     */
    async customersCustomerNameBillingSettingsGet(requestParameters: CustomersCustomerNameBillingSettingsGetRequest, initOverrides?: RequestInit): Promise<BillingSettings> {
        const response = await this.customersCustomerNameBillingSettingsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create billing settings for a vendor.
     * Create billing settings.
     */
    async customersCustomerNameBillingSettingsPostRaw(requestParameters: CustomersCustomerNameBillingSettingsPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<BillingSettings>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameBillingSettingsPost.');
        }

        if (requestParameters.createBillingSettingsInputArgs === null || requestParameters.createBillingSettingsInputArgs === undefined) {
            throw new runtime.RequiredError('createBillingSettingsInputArgs','Required parameter requestParameters.createBillingSettingsInputArgs was null or undefined when calling customersCustomerNameBillingSettingsPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/billing_settings`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateBillingSettingsInputArgsToJSON(requestParameters.createBillingSettingsInputArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BillingSettingsFromJSON(jsonValue));
    }

    /**
     * Create billing settings for a vendor.
     * Create billing settings.
     */
    async customersCustomerNameBillingSettingsPost(requestParameters: CustomersCustomerNameBillingSettingsPostRequest, initOverrides?: RequestInit): Promise<BillingSettings> {
        const response = await this.customersCustomerNameBillingSettingsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update billing settings for a customer.
     * Update Billing Settings.
     */
    async customersCustomerNameBillingSettingsPutRaw(requestParameters: CustomersCustomerNameBillingSettingsPutRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<BillingSettings>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameBillingSettingsPut.');
        }

        if (requestParameters.updateBillingSettingsInputArgs === null || requestParameters.updateBillingSettingsInputArgs === undefined) {
            throw new runtime.RequiredError('updateBillingSettingsInputArgs','Required parameter requestParameters.updateBillingSettingsInputArgs was null or undefined when calling customersCustomerNameBillingSettingsPut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/billing_settings`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateBillingSettingsInputArgsToJSON(requestParameters.updateBillingSettingsInputArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BillingSettingsFromJSON(jsonValue));
    }

    /**
     * Update billing settings for a customer.
     * Update Billing Settings.
     */
    async customersCustomerNameBillingSettingsPut(requestParameters: CustomersCustomerNameBillingSettingsPutRequest, initOverrides?: RequestInit): Promise<BillingSettings> {
        const response = await this.customersCustomerNameBillingSettingsPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a customer by their unique name.
     * Delete Customer
     */
    async customersCustomerNameDeleteRaw(requestParameters: CustomersCustomerNameDeleteRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a customer by their unique name.
     * Delete Customer
     */
    async customersCustomerNameDelete(requestParameters: CustomersCustomerNameDeleteRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameDeleteRaw(requestParameters, initOverrides);
    }

    /**
     */
    async customersCustomerNameFeaturesFeatureNameGetRaw(requestParameters: CustomersCustomerNameFeaturesFeatureNameGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerFeature>> {
        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling customersCustomerNameFeaturesFeatureNameGet.');
        }

        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameFeaturesFeatureNameGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/features/{feature_name}`.replace(`{${"feature_name"}}`, encodeURIComponent(String(requestParameters.featureName))).replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerFeatureFromJSON(jsonValue));
    }

    /**
     */
    async customersCustomerNameFeaturesFeatureNameGet(requestParameters: CustomersCustomerNameFeaturesFeatureNameGetRequest, initOverrides?: RequestInit): Promise<CustomerFeature> {
        const response = await this.customersCustomerNameFeaturesFeatureNameGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch a customer by their unique name.
     * Get Customer
     */
    async customersCustomerNameGetRaw(requestParameters: CustomersCustomerNameGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Customer>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerFromJSON(jsonValue));
    }

    /**
     * Fetch a customer by their unique name.
     * Get Customer
     */
    async customersCustomerNameGet(requestParameters: CustomersCustomerNameGetRequest, initOverrides?: RequestInit): Promise<Customer> {
        const response = await this.customersCustomerNameGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * Generate Current Invoice
     */
    async customersCustomerNameInvoiceInvoiceIdTokenGetRaw(requestParameters: CustomersCustomerNameInvoiceInvoiceIdTokenGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Error>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling customersCustomerNameInvoiceInvoiceIdTokenGet.');
        }

        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameInvoiceInvoiceIdTokenGet.');
        }

        if (requestParameters.invoiceId === null || requestParameters.invoiceId === undefined) {
            throw new runtime.RequiredError('invoiceId','Required parameter requestParameters.invoiceId was null or undefined when calling customersCustomerNameInvoiceInvoiceIdTokenGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/invoice/{invoice_id}/{token}`.replace(`{${"token"}}`, encodeURIComponent(String(requestParameters.token))).replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))).replace(`{${"invoice_id"}}`, encodeURIComponent(String(requestParameters.invoiceId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * Generate Current Invoice
     */
    async customersCustomerNameInvoiceInvoiceIdTokenGet(requestParameters: CustomersCustomerNameInvoiceInvoiceIdTokenGetRequest, initOverrides?: RequestInit): Promise<Error> {
        const response = await this.customersCustomerNameInvoiceInvoiceIdTokenGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async customersCustomerNameInvoicesGetRaw(requestParameters: CustomersCustomerNameInvoicesGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<Invoice>>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameInvoicesGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.forwardSortOffset !== undefined) {
            queryParameters['forward_sort_offset'] = requestParameters.forwardSortOffset;
        }

        if (requestParameters.forwardSecondarySortOffset !== undefined) {
            queryParameters['forward_secondary_sort_offset'] = requestParameters.forwardSecondarySortOffset;
        }

        if (requestParameters.backwardSecondarySortOffset !== undefined) {
            queryParameters['backward_secondary_sort_offset'] = requestParameters.backwardSecondarySortOffset;
        }

        if (requestParameters.backwardSortOffset !== undefined) {
            queryParameters['backward_sort_offset'] = requestParameters.backwardSortOffset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.customerName2 !== undefined) {
            queryParameters['customer_name'] = requestParameters.customerName2;
        }

        if (requestParameters.status !== undefined) {
            queryParameters['status'] = requestParameters.status;
        }

        if (requestParameters.sortColumn !== undefined) {
            queryParameters['sort_column'] = requestParameters.sortColumn;
        }

        if (requestParameters.startTime !== undefined) {
            queryParameters['start_time'] = (requestParameters.startTime as any).toISOString();
        }

        if (requestParameters.sortDirection !== undefined) {
            queryParameters['sort_direction'] = requestParameters.sortDirection;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/invoices`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(InvoiceFromJSON));
    }

    /**
     */
    async customersCustomerNameInvoicesGet(requestParameters: CustomersCustomerNameInvoicesGetRequest, initOverrides?: RequestInit): Promise<Array<Invoice>> {
        const response = await this.customersCustomerNameInvoicesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch all measurement mappings for a specific customer (by unique customer name).
     * Get Measurement Mappings
     */
    async customersCustomerNameMappingsGetRaw(requestParameters: CustomersCustomerNameMappingsGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<CustomerMeasurementMapping>>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameMappingsGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/mappings`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CustomerMeasurementMappingFromJSON));
    }

    /**
     * Fetch all measurement mappings for a specific customer (by unique customer name).
     * Get Measurement Mappings
     */
    async customersCustomerNameMappingsGet(requestParameters: CustomersCustomerNameMappingsGetRequest, initOverrides?: RequestInit): Promise<Array<CustomerMeasurementMapping>> {
        const response = await this.customersCustomerNameMappingsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new measurement mapping for a customer. If no value_regex is passed, label existence is checked instead.
     * Append Measurement Mapping
     */
    async customersCustomerNameMappingsPostRaw(requestParameters: CustomersCustomerNameMappingsPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerMeasurementMapping>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameMappingsPost.');
        }

        if (requestParameters.customerMeasurementMappingInputArgs === null || requestParameters.customerMeasurementMappingInputArgs === undefined) {
            throw new runtime.RequiredError('customerMeasurementMappingInputArgs','Required parameter requestParameters.customerMeasurementMappingInputArgs was null or undefined when calling customersCustomerNameMappingsPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/mappings`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CustomerMeasurementMappingInputArgsToJSON(requestParameters.customerMeasurementMappingInputArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerMeasurementMappingFromJSON(jsonValue));
    }

    /**
     * Create a new measurement mapping for a customer. If no value_regex is passed, label existence is checked instead.
     * Append Measurement Mapping
     */
    async customersCustomerNameMappingsPost(requestParameters: CustomersCustomerNameMappingsPostRequest, initOverrides?: RequestInit): Promise<CustomerMeasurementMapping> {
        const response = await this.customersCustomerNameMappingsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async customersCustomerNamePaymentGatewayCredentialsGetRaw(requestParameters: CustomersCustomerNamePaymentGatewayCredentialsGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PaymentGatewayCredential>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNamePaymentGatewayCredentialsGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/payment_gateway_credentials`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaymentGatewayCredentialFromJSON(jsonValue));
    }

    /**
     */
    async customersCustomerNamePaymentGatewayCredentialsGet(requestParameters: CustomersCustomerNamePaymentGatewayCredentialsGetRequest, initOverrides?: RequestInit): Promise<PaymentGatewayCredential> {
        const response = await this.customersCustomerNamePaymentGatewayCredentialsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add PaymentGatewayCredential for Customer
     */
    async customersCustomerNamePaymentGatewayCredentialsPostRaw(requestParameters: CustomersCustomerNamePaymentGatewayCredentialsPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PaymentGatewayCredential>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNamePaymentGatewayCredentialsPost.');
        }

        if (requestParameters.customerPaymentGatewayCredentialInputArgs === null || requestParameters.customerPaymentGatewayCredentialInputArgs === undefined) {
            throw new runtime.RequiredError('customerPaymentGatewayCredentialInputArgs','Required parameter requestParameters.customerPaymentGatewayCredentialInputArgs was null or undefined when calling customersCustomerNamePaymentGatewayCredentialsPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/payment_gateway_credentials`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CustomerPaymentGatewayCredentialInputArgsToJSON(requestParameters.customerPaymentGatewayCredentialInputArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaymentGatewayCredentialFromJSON(jsonValue));
    }

    /**
     * Add PaymentGatewayCredential for Customer
     */
    async customersCustomerNamePaymentGatewayCredentialsPost(requestParameters: CustomersCustomerNamePaymentGatewayCredentialsPostRequest, initOverrides?: RequestInit): Promise<PaymentGatewayCredential> {
        const response = await this.customersCustomerNamePaymentGatewayCredentialsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async customersCustomerNamePaymentMethodStatusGetRaw(requestParameters: CustomersCustomerNamePaymentMethodStatusGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerPaymentMethodStatus>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNamePaymentMethodStatusGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/payment_method_status`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerPaymentMethodStatusFromJSON(jsonValue));
    }

    /**
     */
    async customersCustomerNamePaymentMethodStatusGet(requestParameters: CustomersCustomerNamePaymentMethodStatusGetRequest, initOverrides?: RequestInit): Promise<CustomerPaymentMethodStatus> {
        const response = await this.customersCustomerNamePaymentMethodStatusGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a single customer. To update Customer measurement mappings, use the `customers/{customer_name}/mappings` endpoint.
     * Update Customer
     */
    async customersCustomerNamePutRaw(requestParameters: CustomersCustomerNamePutRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Customer>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNamePut.');
        }

        if (requestParameters.updateCustomerArgs === null || requestParameters.updateCustomerArgs === undefined) {
            throw new runtime.RequiredError('updateCustomerArgs','Required parameter requestParameters.updateCustomerArgs was null or undefined when calling customersCustomerNamePut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateCustomerArgsToJSON(requestParameters.updateCustomerArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerFromJSON(jsonValue));
    }

    /**
     * Update a single customer. To update Customer measurement mappings, use the `customers/{customer_name}/mappings` endpoint.
     * Update Customer
     */
    async customersCustomerNamePut(requestParameters: CustomersCustomerNamePutRequest, initOverrides?: RequestInit): Promise<Customer> {
        const response = await this.customersCustomerNamePutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch revenue of a customer from start_time and end_time.
     * Get Customer Revenue
     */
    async customersCustomerNameRevenueGetRaw(requestParameters: CustomersCustomerNameRevenueGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RevenueResponse>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameRevenueGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.endTime !== undefined) {
            queryParameters['end_time'] = (requestParameters.endTime as any).toISOString();
        }

        if (requestParameters.startTime !== undefined) {
            queryParameters['start_time'] = (requestParameters.startTime as any).toISOString();
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/revenue`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RevenueResponseFromJSON(jsonValue));
    }

    /**
     * Fetch revenue of a customer from start_time and end_time.
     * Get Customer Revenue
     */
    async customersCustomerNameRevenueGet(requestParameters: CustomersCustomerNameRevenueGetRequest, initOverrides?: RequestInit): Promise<RevenueResponse> {
        const response = await this.customersCustomerNameRevenueGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * Generate Current Invoice
     */
    async customersCustomerNameSampleInvoiceAsOfStrTokenGetRaw(requestParameters: CustomersCustomerNameSampleInvoiceAsOfStrTokenGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Error>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling customersCustomerNameSampleInvoiceAsOfStrTokenGet.');
        }

        if (requestParameters.asOfStr === null || requestParameters.asOfStr === undefined) {
            throw new runtime.RequiredError('asOfStr','Required parameter requestParameters.asOfStr was null or undefined when calling customersCustomerNameSampleInvoiceAsOfStrTokenGet.');
        }

        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSampleInvoiceAsOfStrTokenGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/sample_invoice/{as_of_str}/{token}`.replace(`{${"token"}}`, encodeURIComponent(String(requestParameters.token))).replace(`{${"as_of_str"}}`, encodeURIComponent(String(requestParameters.asOfStr))).replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * Generate Current Invoice
     */
    async customersCustomerNameSampleInvoiceAsOfStrTokenGet(requestParameters: CustomersCustomerNameSampleInvoiceAsOfStrTokenGetRequest, initOverrides?: RequestInit): Promise<Error> {
        const response = await this.customersCustomerNameSampleInvoiceAsOfStrTokenGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * Generate Current Invoice
     */
    async customersCustomerNameSampleInvoiceTokenGetRaw(requestParameters: CustomersCustomerNameSampleInvoiceTokenGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Error>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling customersCustomerNameSampleInvoiceTokenGet.');
        }

        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSampleInvoiceTokenGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/sample_invoice/{token}`.replace(`{${"token"}}`, encodeURIComponent(String(requestParameters.token))).replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * Generate Current Invoice
     */
    async customersCustomerNameSampleInvoiceTokenGet(requestParameters: CustomersCustomerNameSampleInvoiceTokenGetRequest, initOverrides?: RequestInit): Promise<Error> {
        const response = await this.customersCustomerNameSampleInvoiceTokenGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async customersCustomerNameScheduledSubscriptionsGetRaw(requestParameters: CustomersCustomerNameScheduledSubscriptionsGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<Subscription>>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameScheduledSubscriptionsGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/scheduled_subscriptions`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SubscriptionFromJSON));
    }

    /**
     */
    async customersCustomerNameScheduledSubscriptionsGet(requestParameters: CustomersCustomerNameScheduledSubscriptionsGetRequest, initOverrides?: RequestInit): Promise<Array<Subscription>> {
        const response = await this.customersCustomerNameScheduledSubscriptionsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the current status for a customer.
     */
    async customersCustomerNameStatusGetRaw(requestParameters: CustomersCustomerNameStatusGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerStatus>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameStatusGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/status`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerStatusFromJSON(jsonValue));
    }

    /**
     * Get the current status for a customer.
     */
    async customersCustomerNameStatusGet(requestParameters: CustomersCustomerNameStatusGetRequest, initOverrides?: RequestInit): Promise<CustomerStatus> {
        const response = await this.customersCustomerNameStatusGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a subscription for a specific customer (by customer name).
     * Delete Subscription
     */
    async customersCustomerNameSubscriptionDeleteRaw(requestParameters: CustomersCustomerNameSubscriptionDeleteRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSubscriptionDelete.');
        }

        if (requestParameters.deleteSubscriptionArgs === null || requestParameters.deleteSubscriptionArgs === undefined) {
            throw new runtime.RequiredError('deleteSubscriptionArgs','Required parameter requestParameters.deleteSubscriptionArgs was null or undefined when calling customersCustomerNameSubscriptionDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/subscription`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: DeleteSubscriptionArgsToJSON(requestParameters.deleteSubscriptionArgs),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a subscription for a specific customer (by customer name).
     * Delete Subscription
     */
    async customersCustomerNameSubscriptionDelete(requestParameters: CustomersCustomerNameSubscriptionDeleteRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameSubscriptionDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Update a subscription for a specific customer (by customer name).
     * Update Subscription
     */
    async customersCustomerNameSubscriptionPutRaw(requestParameters: CustomersCustomerNameSubscriptionPutRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Subscription>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSubscriptionPut.');
        }

        if (requestParameters.updateSubscriptionArgs === null || requestParameters.updateSubscriptionArgs === undefined) {
            throw new runtime.RequiredError('updateSubscriptionArgs','Required parameter requestParameters.updateSubscriptionArgs was null or undefined when calling customersCustomerNameSubscriptionPut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/subscription`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateSubscriptionArgsToJSON(requestParameters.updateSubscriptionArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubscriptionFromJSON(jsonValue));
    }

    /**
     * Update a subscription for a specific customer (by customer name).
     * Update Subscription
     */
    async customersCustomerNameSubscriptionPut(requestParameters: CustomersCustomerNameSubscriptionPutRequest, initOverrides?: RequestInit): Promise<Subscription> {
        const response = await this.customersCustomerNameSubscriptionPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a subscription in-place for a specific customer (by customer name).
     * Update Subscription In-Place
     */
    async customersCustomerNameSubscriptionUpdateInPlacePutRaw(requestParameters: CustomersCustomerNameSubscriptionUpdateInPlacePutRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Subscription>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSubscriptionUpdateInPlacePut.');
        }

        if (requestParameters.updateSubscriptionInPlaceArgs === null || requestParameters.updateSubscriptionInPlaceArgs === undefined) {
            throw new runtime.RequiredError('updateSubscriptionInPlaceArgs','Required parameter requestParameters.updateSubscriptionInPlaceArgs was null or undefined when calling customersCustomerNameSubscriptionUpdateInPlacePut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/subscription/update_in_place`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateSubscriptionInPlaceArgsToJSON(requestParameters.updateSubscriptionInPlaceArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubscriptionFromJSON(jsonValue));
    }

    /**
     * Update a subscription in-place for a specific customer (by customer name).
     * Update Subscription In-Place
     */
    async customersCustomerNameSubscriptionUpdateInPlacePut(requestParameters: CustomersCustomerNameSubscriptionUpdateInPlacePutRequest, initOverrides?: RequestInit): Promise<Subscription> {
        const response = await this.customersCustomerNameSubscriptionUpdateInPlacePutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all subscriptions for the customer.
     * Get Subscriptions
     */
    async customersCustomerNameSubscriptionsGetRaw(requestParameters: CustomersCustomerNameSubscriptionsGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<Subscription>>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSubscriptionsGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/subscriptions`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SubscriptionFromJSON));
    }

    /**
     * Get all subscriptions for the customer.
     * Get Subscriptions
     */
    async customersCustomerNameSubscriptionsGet(requestParameters: CustomersCustomerNameSubscriptionsGetRequest, initOverrides?: RequestInit): Promise<Array<Subscription>> {
        const response = await this.customersCustomerNameSubscriptionsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new subscription for a customer / price plan combination (by unique name).
     * Create Subscription
     */
    async customersCustomerNameSubscriptionsPostRaw(requestParameters: CustomersCustomerNameSubscriptionsPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Subscription>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSubscriptionsPost.');
        }

        if (requestParameters.createSubscriptionArgs === null || requestParameters.createSubscriptionArgs === undefined) {
            throw new runtime.RequiredError('createSubscriptionArgs','Required parameter requestParameters.createSubscriptionArgs was null or undefined when calling customersCustomerNameSubscriptionsPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/subscriptions`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateSubscriptionArgsToJSON(requestParameters.createSubscriptionArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubscriptionFromJSON(jsonValue));
    }

    /**
     * Create a new subscription for a customer / price plan combination (by unique name).
     * Create Subscription
     */
    async customersCustomerNameSubscriptionsPost(requestParameters: CustomersCustomerNameSubscriptionsPostRequest, initOverrides?: RequestInit): Promise<Subscription> {
        const response = await this.customersCustomerNameSubscriptionsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the current status for a customer.
     */
    async customersCustomerNameUsageGetRaw(requestParameters: CustomersCustomerNameUsageGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerUsage>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameUsageGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.endTime !== undefined) {
            queryParameters['end_time'] = (requestParameters.endTime as any).toISOString();
        }

        if (requestParameters.startTime !== undefined) {
            queryParameters['start_time'] = (requestParameters.startTime as any).toISOString();
        }

        if (requestParameters.meterName !== undefined) {
            queryParameters['meter_name'] = requestParameters.meterName;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/usage`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerUsageFromJSON(jsonValue));
    }

    /**
     * Get the current status for a customer.
     */
    async customersCustomerNameUsageGet(requestParameters: CustomersCustomerNameUsageGetRequest, initOverrides?: RequestInit): Promise<CustomerUsage> {
        const response = await this.customersCustomerNameUsageGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all customers for a given vendor.
     * Get All Customers
     */
    async customersGetRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<Customer>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CustomerFromJSON));
    }

    /**
     * Retrieve all customers for a given vendor.
     * Get All Customers
     */
    async customersGet(initOverrides?: RequestInit): Promise<Array<Customer>> {
        const response = await this.customersGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Create a new customer.
     * Create Customer
     */
    async customersPostRaw(requestParameters: CustomersPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Customer>> {
        if (requestParameters.createCustomerArgs === null || requestParameters.createCustomerArgs === undefined) {
            throw new runtime.RequiredError('createCustomerArgs','Required parameter requestParameters.createCustomerArgs was null or undefined when calling customersPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateCustomerArgsToJSON(requestParameters.createCustomerArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerFromJSON(jsonValue));
    }

    /**
     * Create a new customer.
     * Create Customer
     */
    async customersPost(requestParameters: CustomersPostRequest, initOverrides?: RequestInit): Promise<Customer> {
        const response = await this.customersPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
