/* tslint:disable */
/* eslint-disable */
/**
 * Octane API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    AccountingCustomer,
    AccountingCustomerFromJSON,
    AccountingCustomerToJSON,
    AccruedRevenue,
    AccruedRevenueFromJSON,
    AccruedRevenueToJSON,
    ActiveSubscription,
    ActiveSubscriptionFromJSON,
    ActiveSubscriptionToJSON,
    AdhocCharge,
    AdhocChargeFromJSON,
    AdhocChargeToJSON,
    BillingSettings,
    BillingSettingsFromJSON,
    BillingSettingsToJSON,
    CreateAdhocChargeArgs,
    CreateAdhocChargeArgsFromJSON,
    CreateAdhocChargeArgsToJSON,
    CreateCreditTopOffPlanInputArgs,
    CreateCreditTopOffPlanInputArgsFromJSON,
    CreateCreditTopOffPlanInputArgsToJSON,
    CreateCustomerArgs,
    CreateCustomerArgsFromJSON,
    CreateCustomerArgsToJSON,
    CreateSubscriptionArgs,
    CreateSubscriptionArgsFromJSON,
    CreateSubscriptionArgsToJSON,
    CreditTopOffPlan,
    CreditTopOffPlanFromJSON,
    CreditTopOffPlanToJSON,
    Customer,
    CustomerFromJSON,
    CustomerToJSON,
    CustomerAvalaraSettings,
    CustomerAvalaraSettingsFromJSON,
    CustomerAvalaraSettingsToJSON,
    CustomerBillingSettingsInputArgs,
    CustomerBillingSettingsInputArgsFromJSON,
    CustomerBillingSettingsInputArgsToJSON,
    CustomerFeature,
    CustomerFeatureFromJSON,
    CustomerFeatureToJSON,
    CustomerMeasurementMapping,
    CustomerMeasurementMappingFromJSON,
    CustomerMeasurementMappingToJSON,
    CustomerMeasurementMappingInputArgs,
    CustomerMeasurementMappingInputArgsFromJSON,
    CustomerMeasurementMappingInputArgsToJSON,
    CustomerMetadata,
    CustomerMetadataFromJSON,
    CustomerMetadataToJSON,
    CustomerMetadataInput,
    CustomerMetadataInputFromJSON,
    CustomerMetadataInputToJSON,
    CustomerPaymentGatewayCredentialInputArgs,
    CustomerPaymentGatewayCredentialInputArgsFromJSON,
    CustomerPaymentGatewayCredentialInputArgsToJSON,
    CustomerPaymentMethodStatus,
    CustomerPaymentMethodStatusFromJSON,
    CustomerPaymentMethodStatusToJSON,
    CustomerSpendByTime,
    CustomerSpendByTimeFromJSON,
    CustomerSpendByTimeToJSON,
    CustomerSpendByTimeInputArgs,
    CustomerSpendByTimeInputArgsFromJSON,
    CustomerSpendByTimeInputArgsToJSON,
    CustomerSpendThreshold,
    CustomerSpendThresholdFromJSON,
    CustomerSpendThresholdToJSON,
    CustomerSpendThresholdInputArgs,
    CustomerSpendThresholdInputArgsFromJSON,
    CustomerSpendThresholdInputArgsToJSON,
    CustomerStatus,
    CustomerStatusFromJSON,
    CustomerStatusToJSON,
    CustomerUsage,
    CustomerUsageFromJSON,
    CustomerUsageToJSON,
    CustomerUsageByTime,
    CustomerUsageByTimeFromJSON,
    CustomerUsageByTimeToJSON,
    CustomerUsageByTimeInput,
    CustomerUsageByTimeInputFromJSON,
    CustomerUsageByTimeInputToJSON,
    DailyAccruedRevenue,
    DailyAccruedRevenueFromJSON,
    DailyAccruedRevenueToJSON,
    DeleteDiscountInputArgs,
    DeleteDiscountInputArgsFromJSON,
    DeleteDiscountInputArgsToJSON,
    DeleteSubscriptionArgs,
    DeleteSubscriptionArgsFromJSON,
    DeleteSubscriptionArgsToJSON,
    DiscountInputArgs,
    DiscountInputArgsFromJSON,
    DiscountInputArgsToJSON,
    Invoice,
    InvoiceFromJSON,
    InvoiceToJSON,
    PaymentGatewayCredential,
    PaymentGatewayCredentialFromJSON,
    PaymentGatewayCredentialToJSON,
    RevenueBreakdown,
    RevenueBreakdownFromJSON,
    RevenueBreakdownToJSON,
    RevenueResponse,
    RevenueResponseFromJSON,
    RevenueResponseToJSON,
    Subscription,
    SubscriptionFromJSON,
    SubscriptionToJSON,
    SubscriptionAddOnItem,
    SubscriptionAddOnItemFromJSON,
    SubscriptionAddOnItemToJSON,
    UpdateCreditTopOffPlanInputArgs,
    UpdateCreditTopOffPlanInputArgsFromJSON,
    UpdateCreditTopOffPlanInputArgsToJSON,
    UpdateCreditTopOffPlanState,
    UpdateCreditTopOffPlanStateFromJSON,
    UpdateCreditTopOffPlanStateToJSON,
    UpdateCustomerArgs,
    UpdateCustomerArgsFromJSON,
    UpdateCustomerArgsToJSON,
    UpdateCustomerAvalaraSettingsArgs,
    UpdateCustomerAvalaraSettingsArgsFromJSON,
    UpdateCustomerAvalaraSettingsArgsToJSON,
    UpdateSubscriptionArgs,
    UpdateSubscriptionArgsFromJSON,
    UpdateSubscriptionArgsToJSON,
    UpdateSubscriptionInPlaceArgs,
    UpdateSubscriptionInPlaceArgsFromJSON,
    UpdateSubscriptionInPlaceArgsToJSON,
    ValidateAddressResp,
    ValidateAddressRespFromJSON,
    ValidateAddressRespToJSON,
} from '../models';

export interface CustomersCustomerNameAccountingDeleteRequest {
    customerName: string;
}

export interface CustomersCustomerNameAccountingGenerationPostRequest {
    customerName: string;
}

export interface CustomersCustomerNameAccountingGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameAccountingPostRequest {
    customerName: string;
    accountingCustomer: AccountingCustomer;
}

export interface CustomersCustomerNameAccruedRevenueGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameActiveSubscriptionGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameAdhocChargesGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameAdhocChargesPostRequest {
    customerName: string;
    createAdhocChargeArgs: CreateAdhocChargeArgs;
}

export interface CustomersCustomerNameAdhocChargesUuidDeleteRequest {
    customerName: string;
    uuid: string;
}

export interface CustomersCustomerNameAdhocChargesUuidGetRequest {
    customerName: string;
    uuid: string;
}

export interface CustomersCustomerNameBillingSettingsDeleteRequest {
    customerName: string;
}

export interface CustomersCustomerNameBillingSettingsGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameBillingSettingsPostRequest {
    customerName: string;
    customerBillingSettingsInputArgs: CustomerBillingSettingsInputArgs;
}

export interface CustomersCustomerNameBillingSettingsPutRequest {
    customerName: string;
    customerBillingSettingsInputArgs: CustomerBillingSettingsInputArgs;
}

export interface CustomersCustomerNameCreditTopOffPlanDeleteRequest {
    customerName: string;
}

export interface CustomersCustomerNameCreditTopOffPlanGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameCreditTopOffPlanPostRequest {
    customerName: string;
    createCreditTopOffPlanInputArgs: CreateCreditTopOffPlanInputArgs;
}

export interface CustomersCustomerNameCreditTopOffPlanPutRequest {
    customerName: string;
    updateCreditTopOffPlanInputArgs: UpdateCreditTopOffPlanInputArgs;
}

export interface CustomersCustomerNameCreditTopOffPlanStatePutRequest {
    customerName: string;
    updateCreditTopOffPlanState: UpdateCreditTopOffPlanState;
}

export interface CustomersCustomerNameDailyAccruedRevenueGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameDeleteRequest {
    customerName: string;
}

export interface CustomersCustomerNameDiscountsDeleteRequest {
    customerName: string;
    deleteDiscountInputArgs: DeleteDiscountInputArgs;
}

export interface CustomersCustomerNameDiscountsPostRequest {
    customerName: string;
    discountInputArgs: Array<DiscountInputArgs>;
}

export interface CustomersCustomerNameFeaturesFeatureNameGetRequest {
    customerName: string;
    featureName: string;
}

export interface CustomersCustomerNameGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameIntegrationTaxAvalaraAddressValidGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameIntegrationTaxAvalaraSettingsGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameIntegrationTaxAvalaraSettingsPutRequest {
    customerName: string;
    updateCustomerAvalaraSettingsArgs: UpdateCustomerAvalaraSettingsArgs;
}

export interface CustomersCustomerNameInvoiceInvoiceIdTokenGetRequest {
    invoiceId: number;
    customerName: string;
    token: string;
}

export interface CustomersCustomerNameInvoicesGetRequest {
    customerName: string;
    forwardSecondarySortOffset?: string;
    customerName2?: string;
    startTime?: Date;
    limit?: number;
    sortColumn?: string;
    sortDirection?: string;
    status?: string;
    forwardSortOffset?: string;
}

export interface CustomersCustomerNameMappingsGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameMappingsPostRequest {
    customerName: string;
    customerMeasurementMappingInputArgs: CustomerMeasurementMappingInputArgs;
}

export interface CustomersCustomerNameMetadataGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameMetadataPostRequest {
    customerName: string;
    customerMetadataInput: Array<CustomerMetadataInput>;
}

export interface CustomersCustomerNamePaymentGatewayCredentialsGetRequest {
    customerName: string;
}

export interface CustomersCustomerNamePaymentGatewayCredentialsPostRequest {
    customerName: string;
    customerPaymentGatewayCredentialInputArgs: CustomerPaymentGatewayCredentialInputArgs;
}

export interface CustomersCustomerNamePaymentMethodStatusGetRequest {
    customerName: string;
}

export interface CustomersCustomerNamePutRequest {
    customerName: string;
    updateCustomerArgs: UpdateCustomerArgs;
}

export interface CustomersCustomerNameRevenueGetRequest {
    customerName: string;
    endTime?: Date;
    startTime?: Date;
}

export interface CustomersCustomerNameSampleInvoiceAsOfStrTokenGetRequest {
    token: string;
    asOfStr: string;
    customerName: string;
}

export interface CustomersCustomerNameSampleInvoiceTokenGetRequest {
    token: string;
    customerName: string;
}

export interface CustomersCustomerNameScheduledSubscriptionsGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameSpendByTimePostRequest {
    customerName: string;
    customerSpendByTimeInputArgs: CustomerSpendByTimeInputArgs;
}

export interface CustomersCustomerNameSpendThresholdDeleteRequest {
    customerName: string;
}

export interface CustomersCustomerNameSpendThresholdGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameSpendThresholdPostRequest {
    customerName: string;
    customerSpendThresholdInputArgs: CustomerSpendThresholdInputArgs;
}

export interface CustomersCustomerNameStatusGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameSubscriptionAddOnsPostRequest {
    customerName: string;
    subscriptionAddOnItem: Array<SubscriptionAddOnItem>;
}

export interface CustomersCustomerNameSubscriptionDeleteRequest {
    customerName: string;
    deleteSubscriptionArgs: DeleteSubscriptionArgs;
}

export interface CustomersCustomerNameSubscriptionPutRequest {
    customerName: string;
    updateSubscriptionArgs: UpdateSubscriptionArgs;
}

export interface CustomersCustomerNameSubscriptionUpdateInPlacePutRequest {
    customerName: string;
    updateSubscriptionInPlaceArgs: UpdateSubscriptionInPlaceArgs;
}

export interface CustomersCustomerNameSubscriptionsGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameSubscriptionsPostRequest {
    customerName: string;
    createSubscriptionArgs: CreateSubscriptionArgs;
}

export interface CustomersCustomerNameTotalAccruedRevenueGetRequest {
    customerName: string;
}

export interface CustomersCustomerNameUsageAcrossMetersTokenGetRequest {
    token: string;
    customerName: string;
    endTime: Date;
    startTime: Date;
}

export interface CustomersCustomerNameUsageByTimePostRequest {
    customerName: string;
    customerUsageByTimeInput: CustomerUsageByTimeInput;
}

export interface CustomersCustomerNameUsageGetRequest {
    customerName: string;
    endTime?: Date;
    meterName?: string;
    startTime?: Date;
}

export interface CustomersPostRequest {
    createCustomerArgs: CreateCustomerArgs;
}

/**
 * 
 */
export class CustomersApi extends runtime.BaseAPI {

    /**
     * Deletes the customer entity tied to your accounting software.
     * Delete Accounting Customer
     */
    async customersCustomerNameAccountingDeleteRaw(requestParameters: CustomersCustomerNameAccountingDeleteRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameAccountingDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/accounting`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes the customer entity tied to your accounting software.
     * Delete Accounting Customer
     */
    async customersCustomerNameAccountingDelete(requestParameters: CustomersCustomerNameAccountingDeleteRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameAccountingDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Create the customer entity tied to your accounting software.
     * Create Accounting Customer
     */
    async customersCustomerNameAccountingGenerationPostRaw(requestParameters: CustomersCustomerNameAccountingGenerationPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameAccountingGenerationPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/accounting/generation`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create the customer entity tied to your accounting software.
     * Create Accounting Customer
     */
    async customersCustomerNameAccountingGenerationPost(requestParameters: CustomersCustomerNameAccountingGenerationPostRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameAccountingGenerationPostRaw(requestParameters, initOverrides);
    }

    /**
     * Get the accounting customer ID of a customer that has been connected via an accounting integration.
     * Get Accounting Customer ID
     */
    async customersCustomerNameAccountingGetRaw(requestParameters: CustomersCustomerNameAccountingGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<AccountingCustomer>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameAccountingGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/accounting`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountingCustomerFromJSON(jsonValue));
    }

    /**
     * Get the accounting customer ID of a customer that has been connected via an accounting integration.
     * Get Accounting Customer ID
     */
    async customersCustomerNameAccountingGet(requestParameters: CustomersCustomerNameAccountingGetRequest, initOverrides?: RequestInit): Promise<AccountingCustomer> {
        const response = await this.customersCustomerNameAccountingGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Connect an Octane customer to an Accounting customer through the configured Accounting integration. The vendor must have an integration configured.
     * Connect Accounting Customer
     */
    async customersCustomerNameAccountingPostRaw(requestParameters: CustomersCustomerNameAccountingPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameAccountingPost.');
        }

        if (requestParameters.accountingCustomer === null || requestParameters.accountingCustomer === undefined) {
            throw new runtime.RequiredError('accountingCustomer','Required parameter requestParameters.accountingCustomer was null or undefined when calling customersCustomerNameAccountingPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/accounting`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AccountingCustomerToJSON(requestParameters.accountingCustomer),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Connect an Octane customer to an Accounting customer through the configured Accounting integration. The vendor must have an integration configured.
     * Connect Accounting Customer
     */
    async customersCustomerNameAccountingPost(requestParameters: CustomersCustomerNameAccountingPostRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameAccountingPostRaw(requestParameters, initOverrides);
    }

    /**
     * DEPRECATED - please use /total_accrued_revenue instead
     */
    async customersCustomerNameAccruedRevenueGetRaw(requestParameters: CustomersCustomerNameAccruedRevenueGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RevenueBreakdown>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameAccruedRevenueGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/accrued_revenue`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RevenueBreakdownFromJSON(jsonValue));
    }

    /**
     * DEPRECATED - please use /total_accrued_revenue instead
     */
    async customersCustomerNameAccruedRevenueGet(requestParameters: CustomersCustomerNameAccruedRevenueGetRequest, initOverrides?: RequestInit): Promise<RevenueBreakdown> {
        const response = await this.customersCustomerNameAccruedRevenueGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the customer\'s current active subscription.
     * Get Active Subscription
     */
    async customersCustomerNameActiveSubscriptionGetRaw(requestParameters: CustomersCustomerNameActiveSubscriptionGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<ActiveSubscription>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameActiveSubscriptionGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/active_subscription`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ActiveSubscriptionFromJSON(jsonValue));
    }

    /**
     * Get the customer\'s current active subscription.
     * Get Active Subscription
     */
    async customersCustomerNameActiveSubscriptionGet(requestParameters: CustomersCustomerNameActiveSubscriptionGetRequest, initOverrides?: RequestInit): Promise<ActiveSubscription> {
        const response = await this.customersCustomerNameActiveSubscriptionGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async customersCustomerNameAdhocChargesGetRaw(requestParameters: CustomersCustomerNameAdhocChargesGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<AdhocCharge>>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameAdhocChargesGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/adhoc_charges`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AdhocChargeFromJSON));
    }

    /**
     */
    async customersCustomerNameAdhocChargesGet(requestParameters: CustomersCustomerNameAdhocChargesGetRequest, initOverrides?: RequestInit): Promise<Array<AdhocCharge>> {
        const response = await this.customersCustomerNameAdhocChargesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async customersCustomerNameAdhocChargesPostRaw(requestParameters: CustomersCustomerNameAdhocChargesPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<AdhocCharge>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameAdhocChargesPost.');
        }

        if (requestParameters.createAdhocChargeArgs === null || requestParameters.createAdhocChargeArgs === undefined) {
            throw new runtime.RequiredError('createAdhocChargeArgs','Required parameter requestParameters.createAdhocChargeArgs was null or undefined when calling customersCustomerNameAdhocChargesPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/adhoc_charges`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateAdhocChargeArgsToJSON(requestParameters.createAdhocChargeArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AdhocChargeFromJSON(jsonValue));
    }

    /**
     */
    async customersCustomerNameAdhocChargesPost(requestParameters: CustomersCustomerNameAdhocChargesPostRequest, initOverrides?: RequestInit): Promise<AdhocCharge> {
        const response = await this.customersCustomerNameAdhocChargesPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async customersCustomerNameAdhocChargesUuidDeleteRaw(requestParameters: CustomersCustomerNameAdhocChargesUuidDeleteRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameAdhocChargesUuidDelete.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling customersCustomerNameAdhocChargesUuidDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/adhoc_charges/{uuid}`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async customersCustomerNameAdhocChargesUuidDelete(requestParameters: CustomersCustomerNameAdhocChargesUuidDeleteRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameAdhocChargesUuidDeleteRaw(requestParameters, initOverrides);
    }

    /**
     */
    async customersCustomerNameAdhocChargesUuidGetRaw(requestParameters: CustomersCustomerNameAdhocChargesUuidGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<AdhocCharge>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameAdhocChargesUuidGet.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling customersCustomerNameAdhocChargesUuidGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/adhoc_charges/{uuid}`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AdhocChargeFromJSON(jsonValue));
    }

    /**
     */
    async customersCustomerNameAdhocChargesUuidGet(requestParameters: CustomersCustomerNameAdhocChargesUuidGetRequest, initOverrides?: RequestInit): Promise<AdhocCharge> {
        const response = await this.customersCustomerNameAdhocChargesUuidGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete billing settings for a customer.
     * Delete Billing Settings
     */
    async customersCustomerNameBillingSettingsDeleteRaw(requestParameters: CustomersCustomerNameBillingSettingsDeleteRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameBillingSettingsDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/billing_settings`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete billing settings for a customer.
     * Delete Billing Settings
     */
    async customersCustomerNameBillingSettingsDelete(requestParameters: CustomersCustomerNameBillingSettingsDeleteRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameBillingSettingsDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Fetch the billing settings for a customer.
     * Get Billing Settings
     */
    async customersCustomerNameBillingSettingsGetRaw(requestParameters: CustomersCustomerNameBillingSettingsGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<BillingSettings>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameBillingSettingsGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/billing_settings`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BillingSettingsFromJSON(jsonValue));
    }

    /**
     * Fetch the billing settings for a customer.
     * Get Billing Settings
     */
    async customersCustomerNameBillingSettingsGet(requestParameters: CustomersCustomerNameBillingSettingsGetRequest, initOverrides?: RequestInit): Promise<BillingSettings> {
        const response = await this.customersCustomerNameBillingSettingsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create billing settings for a customer.
     * Create Billing Settings
     */
    async customersCustomerNameBillingSettingsPostRaw(requestParameters: CustomersCustomerNameBillingSettingsPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<BillingSettings>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameBillingSettingsPost.');
        }

        if (requestParameters.customerBillingSettingsInputArgs === null || requestParameters.customerBillingSettingsInputArgs === undefined) {
            throw new runtime.RequiredError('customerBillingSettingsInputArgs','Required parameter requestParameters.customerBillingSettingsInputArgs was null or undefined when calling customersCustomerNameBillingSettingsPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/billing_settings`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CustomerBillingSettingsInputArgsToJSON(requestParameters.customerBillingSettingsInputArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BillingSettingsFromJSON(jsonValue));
    }

    /**
     * Create billing settings for a customer.
     * Create Billing Settings
     */
    async customersCustomerNameBillingSettingsPost(requestParameters: CustomersCustomerNameBillingSettingsPostRequest, initOverrides?: RequestInit): Promise<BillingSettings> {
        const response = await this.customersCustomerNameBillingSettingsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update billing settings for a customer.
     * Update Billing Settings
     */
    async customersCustomerNameBillingSettingsPutRaw(requestParameters: CustomersCustomerNameBillingSettingsPutRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<BillingSettings>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameBillingSettingsPut.');
        }

        if (requestParameters.customerBillingSettingsInputArgs === null || requestParameters.customerBillingSettingsInputArgs === undefined) {
            throw new runtime.RequiredError('customerBillingSettingsInputArgs','Required parameter requestParameters.customerBillingSettingsInputArgs was null or undefined when calling customersCustomerNameBillingSettingsPut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/billing_settings`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CustomerBillingSettingsInputArgsToJSON(requestParameters.customerBillingSettingsInputArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BillingSettingsFromJSON(jsonValue));
    }

    /**
     * Update billing settings for a customer.
     * Update Billing Settings
     */
    async customersCustomerNameBillingSettingsPut(requestParameters: CustomersCustomerNameBillingSettingsPutRequest, initOverrides?: RequestInit): Promise<BillingSettings> {
        const response = await this.customersCustomerNameBillingSettingsPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a customer\'s credit top off plan.
     * Delete Customer\'s Credit Top Off Plan
     */
    async customersCustomerNameCreditTopOffPlanDeleteRaw(requestParameters: CustomersCustomerNameCreditTopOffPlanDeleteRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameCreditTopOffPlanDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/credit_top_off_plan`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a customer\'s credit top off plan.
     * Delete Customer\'s Credit Top Off Plan
     */
    async customersCustomerNameCreditTopOffPlanDelete(requestParameters: CustomersCustomerNameCreditTopOffPlanDeleteRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameCreditTopOffPlanDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Get a customer\'s credit top off plan.
     * Get Customer\'s Credit Top Off Plan
     */
    async customersCustomerNameCreditTopOffPlanGetRaw(requestParameters: CustomersCustomerNameCreditTopOffPlanGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CreditTopOffPlan>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameCreditTopOffPlanGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/credit_top_off_plan`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreditTopOffPlanFromJSON(jsonValue));
    }

    /**
     * Get a customer\'s credit top off plan.
     * Get Customer\'s Credit Top Off Plan
     */
    async customersCustomerNameCreditTopOffPlanGet(requestParameters: CustomersCustomerNameCreditTopOffPlanGetRequest, initOverrides?: RequestInit): Promise<CreditTopOffPlan> {
        const response = await this.customersCustomerNameCreditTopOffPlanGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a credit top off plan for a customer.
     * Create Customer\'s Credit Top Off Plan
     */
    async customersCustomerNameCreditTopOffPlanPostRaw(requestParameters: CustomersCustomerNameCreditTopOffPlanPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CreditTopOffPlan>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameCreditTopOffPlanPost.');
        }

        if (requestParameters.createCreditTopOffPlanInputArgs === null || requestParameters.createCreditTopOffPlanInputArgs === undefined) {
            throw new runtime.RequiredError('createCreditTopOffPlanInputArgs','Required parameter requestParameters.createCreditTopOffPlanInputArgs was null or undefined when calling customersCustomerNameCreditTopOffPlanPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/credit_top_off_plan`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateCreditTopOffPlanInputArgsToJSON(requestParameters.createCreditTopOffPlanInputArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreditTopOffPlanFromJSON(jsonValue));
    }

    /**
     * Create a credit top off plan for a customer.
     * Create Customer\'s Credit Top Off Plan
     */
    async customersCustomerNameCreditTopOffPlanPost(requestParameters: CustomersCustomerNameCreditTopOffPlanPostRequest, initOverrides?: RequestInit): Promise<CreditTopOffPlan> {
        const response = await this.customersCustomerNameCreditTopOffPlanPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a customer\'s current credit top off plan.
     * Update Customer\'s Credit Top Off Plan
     */
    async customersCustomerNameCreditTopOffPlanPutRaw(requestParameters: CustomersCustomerNameCreditTopOffPlanPutRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CreditTopOffPlan>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameCreditTopOffPlanPut.');
        }

        if (requestParameters.updateCreditTopOffPlanInputArgs === null || requestParameters.updateCreditTopOffPlanInputArgs === undefined) {
            throw new runtime.RequiredError('updateCreditTopOffPlanInputArgs','Required parameter requestParameters.updateCreditTopOffPlanInputArgs was null or undefined when calling customersCustomerNameCreditTopOffPlanPut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/credit_top_off_plan`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateCreditTopOffPlanInputArgsToJSON(requestParameters.updateCreditTopOffPlanInputArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreditTopOffPlanFromJSON(jsonValue));
    }

    /**
     * Update a customer\'s current credit top off plan.
     * Update Customer\'s Credit Top Off Plan
     */
    async customersCustomerNameCreditTopOffPlanPut(requestParameters: CustomersCustomerNameCreditTopOffPlanPutRequest, initOverrides?: RequestInit): Promise<CreditTopOffPlan> {
        const response = await this.customersCustomerNameCreditTopOffPlanPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Pause/Unpause the immediate charge attempts for a customer\'s credit top off plan.
     * Update State for a Customer\'s Credit Top Off Plan
     */
    async customersCustomerNameCreditTopOffPlanStatePutRaw(requestParameters: CustomersCustomerNameCreditTopOffPlanStatePutRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameCreditTopOffPlanStatePut.');
        }

        if (requestParameters.updateCreditTopOffPlanState === null || requestParameters.updateCreditTopOffPlanState === undefined) {
            throw new runtime.RequiredError('updateCreditTopOffPlanState','Required parameter requestParameters.updateCreditTopOffPlanState was null or undefined when calling customersCustomerNameCreditTopOffPlanStatePut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/credit_top_off_plan/state`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateCreditTopOffPlanStateToJSON(requestParameters.updateCreditTopOffPlanState),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Pause/Unpause the immediate charge attempts for a customer\'s credit top off plan.
     * Update State for a Customer\'s Credit Top Off Plan
     */
    async customersCustomerNameCreditTopOffPlanStatePut(requestParameters: CustomersCustomerNameCreditTopOffPlanStatePutRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameCreditTopOffPlanStatePutRaw(requestParameters, initOverrides);
    }

    /**
     * Gets the daily accrued revenue for a customer broken down by line item until the beginning of the current hour.
     * Get Daily Accrued Revenue
     */
    async customersCustomerNameDailyAccruedRevenueGetRaw(requestParameters: CustomersCustomerNameDailyAccruedRevenueGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<DailyAccruedRevenue>>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameDailyAccruedRevenueGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/daily_accrued_revenue`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DailyAccruedRevenueFromJSON));
    }

    /**
     * Gets the daily accrued revenue for a customer broken down by line item until the beginning of the current hour.
     * Get Daily Accrued Revenue
     */
    async customersCustomerNameDailyAccruedRevenueGet(requestParameters: CustomersCustomerNameDailyAccruedRevenueGetRequest, initOverrides?: RequestInit): Promise<Array<DailyAccruedRevenue>> {
        const response = await this.customersCustomerNameDailyAccruedRevenueGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a customer by their unique name.
     * Delete Customer
     */
    async customersCustomerNameDeleteRaw(requestParameters: CustomersCustomerNameDeleteRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a customer by their unique name.
     * Delete Customer
     */
    async customersCustomerNameDelete(requestParameters: CustomersCustomerNameDeleteRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a discount from the customer\'s current subscription. If the discount started before the start of the current billing cycle, we will expire it by setting it\'s end date to the start of the current billing cycle. Otherwise, we will delete the discount.
     * Delete Discount
     */
    async customersCustomerNameDiscountsDeleteRaw(requestParameters: CustomersCustomerNameDiscountsDeleteRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameDiscountsDelete.');
        }

        if (requestParameters.deleteDiscountInputArgs === null || requestParameters.deleteDiscountInputArgs === undefined) {
            throw new runtime.RequiredError('deleteDiscountInputArgs','Required parameter requestParameters.deleteDiscountInputArgs was null or undefined when calling customersCustomerNameDiscountsDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/discounts`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: DeleteDiscountInputArgsToJSON(requestParameters.deleteDiscountInputArgs),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a discount from the customer\'s current subscription. If the discount started before the start of the current billing cycle, we will expire it by setting it\'s end date to the start of the current billing cycle. Otherwise, we will delete the discount.
     * Delete Discount
     */
    async customersCustomerNameDiscountsDelete(requestParameters: CustomersCustomerNameDiscountsDeleteRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameDiscountsDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Add discounts to the list of discounts on the customer\'s current subscription. The new discounts will be effective_at of the start of the current billing cycle.
     * Add Discounts to a Subscription
     */
    async customersCustomerNameDiscountsPostRaw(requestParameters: CustomersCustomerNameDiscountsPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameDiscountsPost.');
        }

        if (requestParameters.discountInputArgs === null || requestParameters.discountInputArgs === undefined) {
            throw new runtime.RequiredError('discountInputArgs','Required parameter requestParameters.discountInputArgs was null or undefined when calling customersCustomerNameDiscountsPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/discounts`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.discountInputArgs.map(DiscountInputArgsToJSON),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Add discounts to the list of discounts on the customer\'s current subscription. The new discounts will be effective_at of the start of the current billing cycle.
     * Add Discounts to a Subscription
     */
    async customersCustomerNameDiscountsPost(requestParameters: CustomersCustomerNameDiscountsPostRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameDiscountsPostRaw(requestParameters, initOverrides);
    }

    /**
     * Get the details of a feature for a given customer. The feature\'s status is determined by their subscription first, and by their price plan if no feature overrides are found on the subscription.
     * Get Feature Status
     */
    async customersCustomerNameFeaturesFeatureNameGetRaw(requestParameters: CustomersCustomerNameFeaturesFeatureNameGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerFeature>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameFeaturesFeatureNameGet.');
        }

        if (requestParameters.featureName === null || requestParameters.featureName === undefined) {
            throw new runtime.RequiredError('featureName','Required parameter requestParameters.featureName was null or undefined when calling customersCustomerNameFeaturesFeatureNameGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/features/{feature_name}`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))).replace(`{${"feature_name"}}`, encodeURIComponent(String(requestParameters.featureName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerFeatureFromJSON(jsonValue));
    }

    /**
     * Get the details of a feature for a given customer. The feature\'s status is determined by their subscription first, and by their price plan if no feature overrides are found on the subscription.
     * Get Feature Status
     */
    async customersCustomerNameFeaturesFeatureNameGet(requestParameters: CustomersCustomerNameFeaturesFeatureNameGetRequest, initOverrides?: RequestInit): Promise<CustomerFeature> {
        const response = await this.customersCustomerNameFeaturesFeatureNameGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch a customer by their unique name.
     * Get Customer
     */
    async customersCustomerNameGetRaw(requestParameters: CustomersCustomerNameGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Customer>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerFromJSON(jsonValue));
    }

    /**
     * Fetch a customer by their unique name.
     * Get Customer
     */
    async customersCustomerNameGet(requestParameters: CustomersCustomerNameGetRequest, initOverrides?: RequestInit): Promise<Customer> {
        const response = await this.customersCustomerNameGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Validates to ensure that customer address is taxable via Avalara.
     * Validate customer address.
     */
    async customersCustomerNameIntegrationTaxAvalaraAddressValidGetRaw(requestParameters: CustomersCustomerNameIntegrationTaxAvalaraAddressValidGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<ValidateAddressResp>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameIntegrationTaxAvalaraAddressValidGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/integration/tax/avalara/address/valid`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ValidateAddressRespFromJSON(jsonValue));
    }

    /**
     * Validates to ensure that customer address is taxable via Avalara.
     * Validate customer address.
     */
    async customersCustomerNameIntegrationTaxAvalaraAddressValidGet(requestParameters: CustomersCustomerNameIntegrationTaxAvalaraAddressValidGetRequest, initOverrides?: RequestInit): Promise<ValidateAddressResp> {
        const response = await this.customersCustomerNameIntegrationTaxAvalaraAddressValidGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the customer Avalara settings.
     * Get Customer Avalara Settings
     */
    async customersCustomerNameIntegrationTaxAvalaraSettingsGetRaw(requestParameters: CustomersCustomerNameIntegrationTaxAvalaraSettingsGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerAvalaraSettings>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameIntegrationTaxAvalaraSettingsGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/integration/tax/avalara/settings`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerAvalaraSettingsFromJSON(jsonValue));
    }

    /**
     * Returns the customer Avalara settings.
     * Get Customer Avalara Settings
     */
    async customersCustomerNameIntegrationTaxAvalaraSettingsGet(requestParameters: CustomersCustomerNameIntegrationTaxAvalaraSettingsGetRequest, initOverrides?: RequestInit): Promise<CustomerAvalaraSettings> {
        const response = await this.customersCustomerNameIntegrationTaxAvalaraSettingsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates the Avalara settings for a specific customer.
     * Update customer Avalara settings
     */
    async customersCustomerNameIntegrationTaxAvalaraSettingsPutRaw(requestParameters: CustomersCustomerNameIntegrationTaxAvalaraSettingsPutRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerAvalaraSettings>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameIntegrationTaxAvalaraSettingsPut.');
        }

        if (requestParameters.updateCustomerAvalaraSettingsArgs === null || requestParameters.updateCustomerAvalaraSettingsArgs === undefined) {
            throw new runtime.RequiredError('updateCustomerAvalaraSettingsArgs','Required parameter requestParameters.updateCustomerAvalaraSettingsArgs was null or undefined when calling customersCustomerNameIntegrationTaxAvalaraSettingsPut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/integration/tax/avalara/settings`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateCustomerAvalaraSettingsArgsToJSON(requestParameters.updateCustomerAvalaraSettingsArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerAvalaraSettingsFromJSON(jsonValue));
    }

    /**
     * Updates the Avalara settings for a specific customer.
     * Update customer Avalara settings
     */
    async customersCustomerNameIntegrationTaxAvalaraSettingsPut(requestParameters: CustomersCustomerNameIntegrationTaxAvalaraSettingsPutRequest, initOverrides?: RequestInit): Promise<CustomerAvalaraSettings> {
        const response = await this.customersCustomerNameIntegrationTaxAvalaraSettingsPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * Generate Current Invoice
     */
    async customersCustomerNameInvoiceInvoiceIdTokenGetRaw(requestParameters: CustomersCustomerNameInvoiceInvoiceIdTokenGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Error>> {
        if (requestParameters.invoiceId === null || requestParameters.invoiceId === undefined) {
            throw new runtime.RequiredError('invoiceId','Required parameter requestParameters.invoiceId was null or undefined when calling customersCustomerNameInvoiceInvoiceIdTokenGet.');
        }

        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameInvoiceInvoiceIdTokenGet.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling customersCustomerNameInvoiceInvoiceIdTokenGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/invoice/{invoice_id}/{token}`.replace(`{${"invoice_id"}}`, encodeURIComponent(String(requestParameters.invoiceId))).replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters.token))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * Generate Current Invoice
     */
    async customersCustomerNameInvoiceInvoiceIdTokenGet(requestParameters: CustomersCustomerNameInvoiceInvoiceIdTokenGetRequest, initOverrides?: RequestInit): Promise<Error> {
        const response = await this.customersCustomerNameInvoiceInvoiceIdTokenGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of invoices and their line items for a customer.
     * Get Customer Invoices
     */
    async customersCustomerNameInvoicesGetRaw(requestParameters: CustomersCustomerNameInvoicesGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<Invoice>>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameInvoicesGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.forwardSecondarySortOffset !== undefined) {
            queryParameters['forward_secondary_sort_offset'] = requestParameters.forwardSecondarySortOffset;
        }

        if (requestParameters.customerName2 !== undefined) {
            queryParameters['customer_name'] = requestParameters.customerName2;
        }

        if (requestParameters.startTime !== undefined) {
            queryParameters['start_time'] = (requestParameters.startTime as any).toISOString();
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.sortColumn !== undefined) {
            queryParameters['sort_column'] = requestParameters.sortColumn;
        }

        if (requestParameters.sortDirection !== undefined) {
            queryParameters['sort_direction'] = requestParameters.sortDirection;
        }

        if (requestParameters.status !== undefined) {
            queryParameters['status'] = requestParameters.status;
        }

        if (requestParameters.forwardSortOffset !== undefined) {
            queryParameters['forward_sort_offset'] = requestParameters.forwardSortOffset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/invoices`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(InvoiceFromJSON));
    }

    /**
     * Get a list of invoices and their line items for a customer.
     * Get Customer Invoices
     */
    async customersCustomerNameInvoicesGet(requestParameters: CustomersCustomerNameInvoicesGetRequest, initOverrides?: RequestInit): Promise<Array<Invoice>> {
        const response = await this.customersCustomerNameInvoicesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch all measurement mappings for a specific customer (by unique customer name).
     * Get Measurement Mappings
     */
    async customersCustomerNameMappingsGetRaw(requestParameters: CustomersCustomerNameMappingsGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<CustomerMeasurementMapping>>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameMappingsGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/mappings`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CustomerMeasurementMappingFromJSON));
    }

    /**
     * Fetch all measurement mappings for a specific customer (by unique customer name).
     * Get Measurement Mappings
     */
    async customersCustomerNameMappingsGet(requestParameters: CustomersCustomerNameMappingsGetRequest, initOverrides?: RequestInit): Promise<Array<CustomerMeasurementMapping>> {
        const response = await this.customersCustomerNameMappingsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new measurement mapping for a customer. If no value_regex is passed, label existence is checked instead.
     * Append Measurement Mapping
     */
    async customersCustomerNameMappingsPostRaw(requestParameters: CustomersCustomerNameMappingsPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerMeasurementMapping>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameMappingsPost.');
        }

        if (requestParameters.customerMeasurementMappingInputArgs === null || requestParameters.customerMeasurementMappingInputArgs === undefined) {
            throw new runtime.RequiredError('customerMeasurementMappingInputArgs','Required parameter requestParameters.customerMeasurementMappingInputArgs was null or undefined when calling customersCustomerNameMappingsPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/mappings`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CustomerMeasurementMappingInputArgsToJSON(requestParameters.customerMeasurementMappingInputArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerMeasurementMappingFromJSON(jsonValue));
    }

    /**
     * Create a new measurement mapping for a customer. If no value_regex is passed, label existence is checked instead.
     * Append Measurement Mapping
     */
    async customersCustomerNameMappingsPost(requestParameters: CustomersCustomerNameMappingsPostRequest, initOverrides?: RequestInit): Promise<CustomerMeasurementMapping> {
        const response = await this.customersCustomerNameMappingsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the metadata for a given customer
     * Get All Customer Metadata
     */
    async customersCustomerNameMetadataGetRaw(requestParameters: CustomersCustomerNameMetadataGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<CustomerMetadata>>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameMetadataGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/metadata`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CustomerMetadataFromJSON));
    }

    /**
     * Get the metadata for a given customer
     * Get All Customer Metadata
     */
    async customersCustomerNameMetadataGet(requestParameters: CustomersCustomerNameMetadataGetRequest, initOverrides?: RequestInit): Promise<Array<CustomerMetadata>> {
        const response = await this.customersCustomerNameMetadataGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add metadata to a customer (e.g., a tuple of Region: US for a US based customer)
     * Add metadata to a customer
     */
    async customersCustomerNameMetadataPostRaw(requestParameters: CustomersCustomerNameMetadataPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameMetadataPost.');
        }

        if (requestParameters.customerMetadataInput === null || requestParameters.customerMetadataInput === undefined) {
            throw new runtime.RequiredError('customerMetadataInput','Required parameter requestParameters.customerMetadataInput was null or undefined when calling customersCustomerNameMetadataPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/metadata`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.customerMetadataInput.map(CustomerMetadataInputToJSON),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Add metadata to a customer (e.g., a tuple of Region: US for a US based customer)
     * Add metadata to a customer
     */
    async customersCustomerNameMetadataPost(requestParameters: CustomersCustomerNameMetadataPostRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameMetadataPostRaw(requestParameters, initOverrides);
    }

    /**
     * Get the payment gateway credentials from the vendor\'s configured payment gateway for the given customer. For example, this endpoint will return a customer\'s Stripe customer ID, assuming the vendor has integrated with stripe and has configured the given customer with a Stripe customer ID.
     * Get PaymentGatewayCredential
     */
    async customersCustomerNamePaymentGatewayCredentialsGetRaw(requestParameters: CustomersCustomerNamePaymentGatewayCredentialsGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PaymentGatewayCredential>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNamePaymentGatewayCredentialsGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/payment_gateway_credentials`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaymentGatewayCredentialFromJSON(jsonValue));
    }

    /**
     * Get the payment gateway credentials from the vendor\'s configured payment gateway for the given customer. For example, this endpoint will return a customer\'s Stripe customer ID, assuming the vendor has integrated with stripe and has configured the given customer with a Stripe customer ID.
     * Get PaymentGatewayCredential
     */
    async customersCustomerNamePaymentGatewayCredentialsGet(requestParameters: CustomersCustomerNamePaymentGatewayCredentialsGetRequest, initOverrides?: RequestInit): Promise<PaymentGatewayCredential> {
        const response = await this.customersCustomerNamePaymentGatewayCredentialsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add credentials for a customer\'s account in the vendor\'s currently configured payment gateway. For example, this endpoint can be used to associate a customer with a Stripe customer ID.
     * Add PaymentGatewayCredential
     */
    async customersCustomerNamePaymentGatewayCredentialsPostRaw(requestParameters: CustomersCustomerNamePaymentGatewayCredentialsPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PaymentGatewayCredential>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNamePaymentGatewayCredentialsPost.');
        }

        if (requestParameters.customerPaymentGatewayCredentialInputArgs === null || requestParameters.customerPaymentGatewayCredentialInputArgs === undefined) {
            throw new runtime.RequiredError('customerPaymentGatewayCredentialInputArgs','Required parameter requestParameters.customerPaymentGatewayCredentialInputArgs was null or undefined when calling customersCustomerNamePaymentGatewayCredentialsPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/payment_gateway_credentials`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CustomerPaymentGatewayCredentialInputArgsToJSON(requestParameters.customerPaymentGatewayCredentialInputArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaymentGatewayCredentialFromJSON(jsonValue));
    }

    /**
     * Add credentials for a customer\'s account in the vendor\'s currently configured payment gateway. For example, this endpoint can be used to associate a customer with a Stripe customer ID.
     * Add PaymentGatewayCredential
     */
    async customersCustomerNamePaymentGatewayCredentialsPost(requestParameters: CustomersCustomerNamePaymentGatewayCredentialsPostRequest, initOverrides?: RequestInit): Promise<PaymentGatewayCredential> {
        const response = await this.customersCustomerNamePaymentGatewayCredentialsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch payment method status for a specific customer (by unique customer name).
     * Get Customer Payment Method Status
     */
    async customersCustomerNamePaymentMethodStatusGetRaw(requestParameters: CustomersCustomerNamePaymentMethodStatusGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerPaymentMethodStatus>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNamePaymentMethodStatusGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/payment_method_status`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerPaymentMethodStatusFromJSON(jsonValue));
    }

    /**
     * Fetch payment method status for a specific customer (by unique customer name).
     * Get Customer Payment Method Status
     */
    async customersCustomerNamePaymentMethodStatusGet(requestParameters: CustomersCustomerNamePaymentMethodStatusGetRequest, initOverrides?: RequestInit): Promise<CustomerPaymentMethodStatus> {
        const response = await this.customersCustomerNamePaymentMethodStatusGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a single customer. To update Customer measurement mappings, use the `customers/{customer_name}/mappings` endpoint.
     * Update Customer
     */
    async customersCustomerNamePutRaw(requestParameters: CustomersCustomerNamePutRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Customer>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNamePut.');
        }

        if (requestParameters.updateCustomerArgs === null || requestParameters.updateCustomerArgs === undefined) {
            throw new runtime.RequiredError('updateCustomerArgs','Required parameter requestParameters.updateCustomerArgs was null or undefined when calling customersCustomerNamePut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateCustomerArgsToJSON(requestParameters.updateCustomerArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerFromJSON(jsonValue));
    }

    /**
     * Update a single customer. To update Customer measurement mappings, use the `customers/{customer_name}/mappings` endpoint.
     * Update Customer
     */
    async customersCustomerNamePut(requestParameters: CustomersCustomerNamePutRequest, initOverrides?: RequestInit): Promise<Customer> {
        const response = await this.customersCustomerNamePutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch revenue of a customer from start_time and end_time.
     * Get Customer Revenue
     */
    async customersCustomerNameRevenueGetRaw(requestParameters: CustomersCustomerNameRevenueGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RevenueResponse>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameRevenueGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.endTime !== undefined) {
            queryParameters['end_time'] = (requestParameters.endTime as any).toISOString();
        }

        if (requestParameters.startTime !== undefined) {
            queryParameters['start_time'] = (requestParameters.startTime as any).toISOString();
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/revenue`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RevenueResponseFromJSON(jsonValue));
    }

    /**
     * Fetch revenue of a customer from start_time and end_time.
     * Get Customer Revenue
     */
    async customersCustomerNameRevenueGet(requestParameters: CustomersCustomerNameRevenueGetRequest, initOverrides?: RequestInit): Promise<RevenueResponse> {
        const response = await this.customersCustomerNameRevenueGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * Generate Current Invoice
     */
    async customersCustomerNameSampleInvoiceAsOfStrTokenGetRaw(requestParameters: CustomersCustomerNameSampleInvoiceAsOfStrTokenGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Error>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling customersCustomerNameSampleInvoiceAsOfStrTokenGet.');
        }

        if (requestParameters.asOfStr === null || requestParameters.asOfStr === undefined) {
            throw new runtime.RequiredError('asOfStr','Required parameter requestParameters.asOfStr was null or undefined when calling customersCustomerNameSampleInvoiceAsOfStrTokenGet.');
        }

        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSampleInvoiceAsOfStrTokenGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/sample_invoice/{as_of_str}/{token}`.replace(`{${"token"}}`, encodeURIComponent(String(requestParameters.token))).replace(`{${"as_of_str"}}`, encodeURIComponent(String(requestParameters.asOfStr))).replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * Generate Current Invoice
     */
    async customersCustomerNameSampleInvoiceAsOfStrTokenGet(requestParameters: CustomersCustomerNameSampleInvoiceAsOfStrTokenGetRequest, initOverrides?: RequestInit): Promise<Error> {
        const response = await this.customersCustomerNameSampleInvoiceAsOfStrTokenGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * Generate Current Invoice
     */
    async customersCustomerNameSampleInvoiceTokenGetRaw(requestParameters: CustomersCustomerNameSampleInvoiceTokenGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Error>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling customersCustomerNameSampleInvoiceTokenGet.');
        }

        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSampleInvoiceTokenGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/sample_invoice/{token}`.replace(`{${"token"}}`, encodeURIComponent(String(requestParameters.token))).replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * Generate Current Invoice
     */
    async customersCustomerNameSampleInvoiceTokenGet(requestParameters: CustomersCustomerNameSampleInvoiceTokenGetRequest, initOverrides?: RequestInit): Promise<Error> {
        const response = await this.customersCustomerNameSampleInvoiceTokenGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of any subscriptions scheduled to start in the future for the given customer.
     * Get Scheduled Subscriptions
     */
    async customersCustomerNameScheduledSubscriptionsGetRaw(requestParameters: CustomersCustomerNameScheduledSubscriptionsGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<Subscription>>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameScheduledSubscriptionsGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/scheduled_subscriptions`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SubscriptionFromJSON));
    }

    /**
     * Get a list of any subscriptions scheduled to start in the future for the given customer.
     * Get Scheduled Subscriptions
     */
    async customersCustomerNameScheduledSubscriptionsGet(requestParameters: CustomersCustomerNameScheduledSubscriptionsGetRequest, initOverrides?: RequestInit): Promise<Array<Subscription>> {
        const response = await this.customersCustomerNameScheduledSubscriptionsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the spend for the customer broken down by line item and the given time bucket for the given start and end time. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Spend By Time
     */
    async customersCustomerNameSpendByTimePostRaw(requestParameters: CustomersCustomerNameSpendByTimePostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<CustomerSpendByTime>>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSpendByTimePost.');
        }

        if (requestParameters.customerSpendByTimeInputArgs === null || requestParameters.customerSpendByTimeInputArgs === undefined) {
            throw new runtime.RequiredError('customerSpendByTimeInputArgs','Required parameter requestParameters.customerSpendByTimeInputArgs was null or undefined when calling customersCustomerNameSpendByTimePost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/spend_by_time`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CustomerSpendByTimeInputArgsToJSON(requestParameters.customerSpendByTimeInputArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CustomerSpendByTimeFromJSON));
    }

    /**
     * Gets the spend for the customer broken down by line item and the given time bucket for the given start and end time. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name as a url parameter.
     * Spend By Time
     */
    async customersCustomerNameSpendByTimePost(requestParameters: CustomersCustomerNameSpendByTimePostRequest, initOverrides?: RequestInit): Promise<Array<CustomerSpendByTime>> {
        const response = await this.customersCustomerNameSpendByTimePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a customer\'s spend threshold.
     * Delete Customer Spend Threshold
     */
    async customersCustomerNameSpendThresholdDeleteRaw(requestParameters: CustomersCustomerNameSpendThresholdDeleteRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSpendThresholdDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/spend_threshold`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a customer\'s spend threshold.
     * Delete Customer Spend Threshold
     */
    async customersCustomerNameSpendThresholdDelete(requestParameters: CustomersCustomerNameSpendThresholdDeleteRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameSpendThresholdDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Fetch the spend threshold for a customer.
     * Get Customer Spend Threshold
     */
    async customersCustomerNameSpendThresholdGetRaw(requestParameters: CustomersCustomerNameSpendThresholdGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerSpendThreshold>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSpendThresholdGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/spend_threshold`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerSpendThresholdFromJSON(jsonValue));
    }

    /**
     * Fetch the spend threshold for a customer.
     * Get Customer Spend Threshold
     */
    async customersCustomerNameSpendThresholdGet(requestParameters: CustomersCustomerNameSpendThresholdGetRequest, initOverrides?: RequestInit): Promise<CustomerSpendThreshold> {
        const response = await this.customersCustomerNameSpendThresholdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a spend threshold for a customer.
     * Create Customer Spend Threshold
     */
    async customersCustomerNameSpendThresholdPostRaw(requestParameters: CustomersCustomerNameSpendThresholdPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerSpendThreshold>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSpendThresholdPost.');
        }

        if (requestParameters.customerSpendThresholdInputArgs === null || requestParameters.customerSpendThresholdInputArgs === undefined) {
            throw new runtime.RequiredError('customerSpendThresholdInputArgs','Required parameter requestParameters.customerSpendThresholdInputArgs was null or undefined when calling customersCustomerNameSpendThresholdPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/spend_threshold`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CustomerSpendThresholdInputArgsToJSON(requestParameters.customerSpendThresholdInputArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerSpendThresholdFromJSON(jsonValue));
    }

    /**
     * Create a spend threshold for a customer.
     * Create Customer Spend Threshold
     */
    async customersCustomerNameSpendThresholdPost(requestParameters: CustomersCustomerNameSpendThresholdPostRequest, initOverrides?: RequestInit): Promise<CustomerSpendThreshold> {
        const response = await this.customersCustomerNameSpendThresholdPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the current status for a customer.
     * Get Customer Status
     */
    async customersCustomerNameStatusGetRaw(requestParameters: CustomersCustomerNameStatusGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerStatus>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameStatusGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/status`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerStatusFromJSON(jsonValue));
    }

    /**
     * Get the current status for a customer.
     * Get Customer Status
     */
    async customersCustomerNameStatusGet(requestParameters: CustomersCustomerNameStatusGetRequest, initOverrides?: RequestInit): Promise<CustomerStatus> {
        const response = await this.customersCustomerNameStatusGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add or remove add ons from the current customer\'s subscription.
     * Modify Add Ons on Subscription
     */
    async customersCustomerNameSubscriptionAddOnsPostRaw(requestParameters: CustomersCustomerNameSubscriptionAddOnsPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSubscriptionAddOnsPost.');
        }

        if (requestParameters.subscriptionAddOnItem === null || requestParameters.subscriptionAddOnItem === undefined) {
            throw new runtime.RequiredError('subscriptionAddOnItem','Required parameter requestParameters.subscriptionAddOnItem was null or undefined when calling customersCustomerNameSubscriptionAddOnsPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/subscription/add_ons`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.subscriptionAddOnItem.map(SubscriptionAddOnItemToJSON),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Add or remove add ons from the current customer\'s subscription.
     * Modify Add Ons on Subscription
     */
    async customersCustomerNameSubscriptionAddOnsPost(requestParameters: CustomersCustomerNameSubscriptionAddOnsPostRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameSubscriptionAddOnsPostRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a subscription for a specific customer (by customer name).
     * Delete Subscription
     */
    async customersCustomerNameSubscriptionDeleteRaw(requestParameters: CustomersCustomerNameSubscriptionDeleteRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSubscriptionDelete.');
        }

        if (requestParameters.deleteSubscriptionArgs === null || requestParameters.deleteSubscriptionArgs === undefined) {
            throw new runtime.RequiredError('deleteSubscriptionArgs','Required parameter requestParameters.deleteSubscriptionArgs was null or undefined when calling customersCustomerNameSubscriptionDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/subscription`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: DeleteSubscriptionArgsToJSON(requestParameters.deleteSubscriptionArgs),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a subscription for a specific customer (by customer name).
     * Delete Subscription
     */
    async customersCustomerNameSubscriptionDelete(requestParameters: CustomersCustomerNameSubscriptionDeleteRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameSubscriptionDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Update a subscription for a specific customer (by customer name).
     * Update Subscription
     */
    async customersCustomerNameSubscriptionPutRaw(requestParameters: CustomersCustomerNameSubscriptionPutRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Subscription>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSubscriptionPut.');
        }

        if (requestParameters.updateSubscriptionArgs === null || requestParameters.updateSubscriptionArgs === undefined) {
            throw new runtime.RequiredError('updateSubscriptionArgs','Required parameter requestParameters.updateSubscriptionArgs was null or undefined when calling customersCustomerNameSubscriptionPut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/subscription`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateSubscriptionArgsToJSON(requestParameters.updateSubscriptionArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubscriptionFromJSON(jsonValue));
    }

    /**
     * Update a subscription for a specific customer (by customer name).
     * Update Subscription
     */
    async customersCustomerNameSubscriptionPut(requestParameters: CustomersCustomerNameSubscriptionPutRequest, initOverrides?: RequestInit): Promise<Subscription> {
        const response = await this.customersCustomerNameSubscriptionPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a subscription in-place for a specific customer (by customer name).
     * Update Subscription In-Place
     */
    async customersCustomerNameSubscriptionUpdateInPlacePutRaw(requestParameters: CustomersCustomerNameSubscriptionUpdateInPlacePutRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Subscription>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSubscriptionUpdateInPlacePut.');
        }

        if (requestParameters.updateSubscriptionInPlaceArgs === null || requestParameters.updateSubscriptionInPlaceArgs === undefined) {
            throw new runtime.RequiredError('updateSubscriptionInPlaceArgs','Required parameter requestParameters.updateSubscriptionInPlaceArgs was null or undefined when calling customersCustomerNameSubscriptionUpdateInPlacePut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/subscription/update_in_place`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateSubscriptionInPlaceArgsToJSON(requestParameters.updateSubscriptionInPlaceArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubscriptionFromJSON(jsonValue));
    }

    /**
     * Update a subscription in-place for a specific customer (by customer name).
     * Update Subscription In-Place
     */
    async customersCustomerNameSubscriptionUpdateInPlacePut(requestParameters: CustomersCustomerNameSubscriptionUpdateInPlacePutRequest, initOverrides?: RequestInit): Promise<Subscription> {
        const response = await this.customersCustomerNameSubscriptionUpdateInPlacePutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all subscriptions for the customer.
     * Get Subscriptions
     */
    async customersCustomerNameSubscriptionsGetRaw(requestParameters: CustomersCustomerNameSubscriptionsGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<Subscription>>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSubscriptionsGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/subscriptions`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SubscriptionFromJSON));
    }

    /**
     * Get all subscriptions for the customer.
     * Get Subscriptions
     */
    async customersCustomerNameSubscriptionsGet(requestParameters: CustomersCustomerNameSubscriptionsGetRequest, initOverrides?: RequestInit): Promise<Array<Subscription>> {
        const response = await this.customersCustomerNameSubscriptionsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new subscription for a customer / price plan combination (by unique name).
     * Create Subscription
     */
    async customersCustomerNameSubscriptionsPostRaw(requestParameters: CustomersCustomerNameSubscriptionsPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Subscription>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameSubscriptionsPost.');
        }

        if (requestParameters.createSubscriptionArgs === null || requestParameters.createSubscriptionArgs === undefined) {
            throw new runtime.RequiredError('createSubscriptionArgs','Required parameter requestParameters.createSubscriptionArgs was null or undefined when calling customersCustomerNameSubscriptionsPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/subscriptions`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateSubscriptionArgsToJSON(requestParameters.createSubscriptionArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubscriptionFromJSON(jsonValue));
    }

    /**
     * Create a new subscription for a customer / price plan combination (by unique name).
     * Create Subscription
     */
    async customersCustomerNameSubscriptionsPost(requestParameters: CustomersCustomerNameSubscriptionsPostRequest, initOverrides?: RequestInit): Promise<Subscription> {
        const response = await this.customersCustomerNameSubscriptionsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the total accrued revenue for a customer broken down by line item until the beginning of the current hour.
     * Get Total Accrued Revenue
     */
    async customersCustomerNameTotalAccruedRevenueGetRaw(requestParameters: CustomersCustomerNameTotalAccruedRevenueGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<AccruedRevenue>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameTotalAccruedRevenueGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/total_accrued_revenue`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccruedRevenueFromJSON(jsonValue));
    }

    /**
     * Gets the total accrued revenue for a customer broken down by line item until the beginning of the current hour.
     * Get Total Accrued Revenue
     */
    async customersCustomerNameTotalAccruedRevenueGet(requestParameters: CustomersCustomerNameTotalAccruedRevenueGetRequest, initOverrides?: RequestInit): Promise<AccruedRevenue> {
        const response = await this.customersCustomerNameTotalAccruedRevenueGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the usage for a customer across all meters in XLS format for a given time period.
     * Get Customer\'s Usage Across Meters
     */
    async customersCustomerNameUsageAcrossMetersTokenGetRaw(requestParameters: CustomersCustomerNameUsageAcrossMetersTokenGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling customersCustomerNameUsageAcrossMetersTokenGet.');
        }

        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameUsageAcrossMetersTokenGet.');
        }

        if (requestParameters.endTime === null || requestParameters.endTime === undefined) {
            throw new runtime.RequiredError('endTime','Required parameter requestParameters.endTime was null or undefined when calling customersCustomerNameUsageAcrossMetersTokenGet.');
        }

        if (requestParameters.startTime === null || requestParameters.startTime === undefined) {
            throw new runtime.RequiredError('startTime','Required parameter requestParameters.startTime was null or undefined when calling customersCustomerNameUsageAcrossMetersTokenGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.endTime !== undefined) {
            queryParameters['end_time'] = (requestParameters.endTime as any).toISOString();
        }

        if (requestParameters.startTime !== undefined) {
            queryParameters['start_time'] = (requestParameters.startTime as any).toISOString();
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/usage_across_meters/{token}`.replace(`{${"token"}}`, encodeURIComponent(String(requestParameters.token))).replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Get the usage for a customer across all meters in XLS format for a given time period.
     * Get Customer\'s Usage Across Meters
     */
    async customersCustomerNameUsageAcrossMetersTokenGet(requestParameters: CustomersCustomerNameUsageAcrossMetersTokenGetRequest, initOverrides?: RequestInit): Promise<void> {
        await this.customersCustomerNameUsageAcrossMetersTokenGetRaw(requestParameters, initOverrides);
    }

    /**
     * Get the customer\'s usage over time filtered by the inputted meter and labels. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name in the request body.
     * Usage By Time For Meter
     */
    async customersCustomerNameUsageByTimePostRaw(requestParameters: CustomersCustomerNameUsageByTimePostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerUsageByTime>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameUsageByTimePost.');
        }

        if (requestParameters.customerUsageByTimeInput === null || requestParameters.customerUsageByTimeInput === undefined) {
            throw new runtime.RequiredError('customerUsageByTimeInput','Required parameter requestParameters.customerUsageByTimeInput was null or undefined when calling customersCustomerNameUsageByTimePost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/usage_by_time`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CustomerUsageByTimeInputToJSON(requestParameters.customerUsageByTimeInput),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerUsageByTimeFromJSON(jsonValue));
    }

    /**
     * Get the customer\'s usage over time filtered by the inputted meter and labels. This endpoint expects the customer-scoped token for authentication. If using vendor api key, you must also provide the customer name in the request body.
     * Usage By Time For Meter
     */
    async customersCustomerNameUsageByTimePost(requestParameters: CustomersCustomerNameUsageByTimePostRequest, initOverrides?: RequestInit): Promise<CustomerUsageByTime> {
        const response = await this.customersCustomerNameUsageByTimePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * [DEPRECATED] For the given meter, get a customer\'s total usage.
     * Get Usage By Meter
     */
    async customersCustomerNameUsageGetRaw(requestParameters: CustomersCustomerNameUsageGetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomerUsage>> {
        if (requestParameters.customerName === null || requestParameters.customerName === undefined) {
            throw new runtime.RequiredError('customerName','Required parameter requestParameters.customerName was null or undefined when calling customersCustomerNameUsageGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.endTime !== undefined) {
            queryParameters['end_time'] = (requestParameters.endTime as any).toISOString();
        }

        if (requestParameters.meterName !== undefined) {
            queryParameters['meter_name'] = requestParameters.meterName;
        }

        if (requestParameters.startTime !== undefined) {
            queryParameters['start_time'] = (requestParameters.startTime as any).toISOString();
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/{customer_name}/usage`.replace(`{${"customer_name"}}`, encodeURIComponent(String(requestParameters.customerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerUsageFromJSON(jsonValue));
    }

    /**
     * [DEPRECATED] For the given meter, get a customer\'s total usage.
     * Get Usage By Meter
     */
    async customersCustomerNameUsageGet(requestParameters: CustomersCustomerNameUsageGetRequest, initOverrides?: RequestInit): Promise<CustomerUsage> {
        const response = await this.customersCustomerNameUsageGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all customers for a given vendor.
     * Get All Customers
     */
    async customersGetRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<Customer>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CustomerFromJSON));
    }

    /**
     * Retrieve all customers for a given vendor.
     * Get All Customers
     */
    async customersGet(initOverrides?: RequestInit): Promise<Array<Customer>> {
        const response = await this.customersGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Create a new customer.
     * Create Customer
     */
    async customersPostRaw(requestParameters: CustomersPostRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Customer>> {
        if (requestParameters.createCustomerArgs === null || requestParameters.createCustomerArgs === undefined) {
            throw new runtime.RequiredError('createCustomerArgs','Required parameter requestParameters.createCustomerArgs was null or undefined when calling customersPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/customers/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateCustomerArgsToJSON(requestParameters.createCustomerArgs),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerFromJSON(jsonValue));
    }

    /**
     * Create a new customer.
     * Create Customer
     */
    async customersPost(requestParameters: CustomersPostRequest, initOverrides?: RequestInit): Promise<Customer> {
        const response = await this.customersPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
