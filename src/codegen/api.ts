/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Octane API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from 'url';
import * as isomorphicFetch from 'isomorphic-fetch';
import { Configuration } from './configuration';

const BASE_PATH = 'http://localhost:8080'.replace(/\/+$/, '');

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|',
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration!: Configuration;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = isomorphicFetch.default,
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name!: 'RequiredError';

  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 *
 * @export
 * @interface AddOnInputArgs
 */
export interface AddOnInputArgs {
  /**
   *
   * @type {number}
   * @memberof AddOnInputArgs
   */
  price?: number;
  /**
   *
   * @type {FeatureInputArgs}
   * @memberof AddOnInputArgs
   */
  feature?: FeatureInputArgs;
}
/**
 *
 * @export
 * @interface ApplyCouponInputArgs
 */
export interface ApplyCouponInputArgs {
  /**
   *
   * @type {string}
   * @memberof ApplyCouponInputArgs
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof ApplyCouponInputArgs
   */
  customerName?: string;
  /**
   *
   * @type {number}
   * @memberof ApplyCouponInputArgs
   */
  customerId?: number;
  /**
   *
   * @type {number}
   * @memberof ApplyCouponInputArgs
   */
  vendorId?: number;
  /**
   *
   * @type {string}
   * @memberof ApplyCouponInputArgs
   */
  name?: string;
}
/**
 *
 * @export
 * @interface BillingSettings
 */
export interface BillingSettings {
  /**
   * Time length of the grace period between the end of a billing cycle and invoice generation. *NOTE*: The specified length is unitless. Unit is designated with the `invoice_grace_period_unit` field.
   * @type {number}
   * @memberof BillingSettings
   */
  invoiceGracePeriodLength?: number;
  /**
   * Time length unit of the grace period between the end of a billing cycle and invoice generation. One of `minute`, `hour`, `day`.
   * @type {string}
   * @memberof BillingSettings
   */
  invoiceGracePeriodUnit?: string;
  /**
   * Time length of the grace period between the end of invoice generation and the actual charge. *NOTE*: The specified length is unitless. Unit is designated with the `payment_grace_period_unit` field.
   * @type {number}
   * @memberof BillingSettings
   */
  paymentGracePeriodLength?: number;
  /**
   * Time length unit of the grace period between the end of invoice generation and actual charge. One of `minute`, `hour`, `day`.
   * @type {string}
   * @memberof BillingSettings
   */
  paymentGracePeriodUnit?: string;
  /**
   * Flag that controls whether or not invoices should be sent to customers.
   * @type {boolean}
   * @memberof BillingSettings
   */
  shouldSendInvoiceToCustomers?: boolean;
  /**
   *
   * @type {Object}
   * @memberof BillingSettings
   */
  customerInvoiceDetailLevel?: Object;
  /**
   * Flag that controls whether or not to charge the customer based on the invoice.
   * @type {boolean}
   * @memberof BillingSettings
   */
  chargesEnabled?: boolean;
}
/**
 *
 * @export
 * @interface ContactInfo
 */
export interface ContactInfo {
  /**
   *
   * @type {string}
   * @memberof ContactInfo
   */
  addressLine1?: string;
  /**
   *
   * @type {string}
   * @memberof ContactInfo
   */
  addressLine2?: string;
  /**
   *
   * @type {string}
   * @memberof ContactInfo
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof ContactInfo
   */
  state?: string;
  /**
   *
   * @type {string}
   * @memberof ContactInfo
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof ContactInfo
   */
  zipcode?: string;
  /**
   *
   * @type {string}
   * @memberof ContactInfo
   */
  url?: string;
  /**
   *
   * @type {string}
   * @memberof ContactInfo
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof ContactInfo
   */
  phone?: string;
}
/**
 *
 * @export
 * @interface ContactInfoInputArgs
 */
export interface ContactInfoInputArgs {
  /**
   *
   * @type {string}
   * @memberof ContactInfoInputArgs
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof ContactInfoInputArgs
   */
  state?: string;
  /**
   *
   * @type {string}
   * @memberof ContactInfoInputArgs
   */
  zipcode?: string;
  /**
   *
   * @type {string}
   * @memberof ContactInfoInputArgs
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof ContactInfoInputArgs
   */
  phone?: string;
  /**
   *
   * @type {string}
   * @memberof ContactInfoInputArgs
   */
  url?: string;
  /**
   *
   * @type {string}
   * @memberof ContactInfoInputArgs
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof ContactInfoInputArgs
   */
  addressLine2?: string;
  /**
   *
   * @type {string}
   * @memberof ContactInfoInputArgs
   */
  addressLine1?: string;
}
/**
 *
 * @export
 * @interface Coupon
 */
export interface Coupon {
  /**
   * Unique name identifier.
   * @type {string}
   * @memberof Coupon
   */
  name: string;
}
/**
 *
 * @export
 * @interface Coupon1
 */
export interface Coupon1 {
  /**
   * Unique name identifier.
   * @type {string}
   * @memberof Coupon1
   */
  name: string;
  /**
   * The time when the coupon will stop being effective one its applied.
   * @type {number}
   * @memberof Coupon1
   */
  durationLength?: number;
  /**
   * The unit time unit to apply to the specified duration length.
   * @type {string}
   * @memberof Coupon1
   */
  durationUnit?: string;
  /**
   * ISO-8601 formatted timestamp that defines after what timestamp this coupon cannot be applied.
   * @type {Date}
   * @memberof Coupon1
   */
  expirationTime?: Date;
  /**
   * One of RECURRRING or ONCE.
   * @type {string}
   * @memberof Coupon1
   */
  frequency?: string;
  /**
   * The maximum number of times this coupon can be used.
   * @type {number}
   * @memberof Coupon1
   */
  maxUses?: number;
  /**
   * Customer facing code that can be used to apply coupon.
   * @type {string}
   * @memberof Coupon1
   */
  code?: string;
  /**
   * True if prorate at application date, false otherwise
   * @type {boolean}
   * @memberof Coupon1
   */
  isStartProrated?: boolean;
  /**
   * True if prorate at end of duration, false otherwise
   * @type {boolean}
   * @memberof Coupon1
   */
  isEndProrated?: boolean;
  /**
   * One of FLAT or PERCENT.
   * @type {string}
   * @memberof Coupon1
   */
  discountType: string;
  /**
   * The amount of discount to give based on discount_type
   * @type {number}
   * @memberof Coupon1
   */
  discountAmount: number;
  /**
   *
   * @type {Array<Customer1>}
   * @memberof Coupon1
   */
  excludedCustomers?: Array<Customer1>;
  /**
   *
   * @type {Array<PricePlan1>}
   * @memberof Coupon1
   */
  excludedPricePlans?: Array<PricePlan1>;
}
/**
 *
 * @export
 * @interface CouponInputArgs
 */
export interface CouponInputArgs {
  /**
   *
   * @type {string}
   * @memberof CouponInputArgs
   */
  code?: string;
  /**
   *
   * @type {boolean}
   * @memberof CouponInputArgs
   */
  isEndProrated?: boolean;
  /**
   *
   * @type {Date}
   * @memberof CouponInputArgs
   */
  expirationTime?: Date;
  /**
   *
   * @type {number}
   * @memberof CouponInputArgs
   */
  discountAmount: number;
  /**
   *
   * @type {string}
   * @memberof CouponInputArgs
   */
  discountType: string;
  /**
   *
   * @type {Array<string>}
   * @memberof CouponInputArgs
   */
  excludedPricePlans?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof CouponInputArgs
   */
  frequency: string;
  /**
   *
   * @type {number}
   * @memberof CouponInputArgs
   */
  vendorId?: number;
  /**
   *
   * @type {boolean}
   * @memberof CouponInputArgs
   */
  isStartProrated?: boolean;
  /**
   *
   * @type {string}
   * @memberof CouponInputArgs
   */
  durationUnit?: string;
  /**
   *
   * @type {number}
   * @memberof CouponInputArgs
   */
  durationLength?: number;
  /**
   *
   * @type {string}
   * @memberof CouponInputArgs
   */
  name: string;
  /**
   *
   * @type {Array<string>}
   * @memberof CouponInputArgs
   */
  excludedCustomers?: Array<string>;
  /**
   *
   * @type {number}
   * @memberof CouponInputArgs
   */
  maxUses?: number;
}
/**
 *
 * @export
 * @interface CreateBillingSettingsInputArgs
 */
export interface CreateBillingSettingsInputArgs {
  /**
   *
   * @type {number}
   * @memberof CreateBillingSettingsInputArgs
   */
  paymentGracePeriodLength?: number;
  /**
   *
   * @type {boolean}
   * @memberof CreateBillingSettingsInputArgs
   */
  shouldSendInvoiceToCustomers?: boolean;
  /**
   *
   * @type {number}
   * @memberof CreateBillingSettingsInputArgs
   */
  customerId?: number;
  /**
   *
   * @type {string}
   * @memberof CreateBillingSettingsInputArgs
   */
  invoiceGracePeriodUnit?: string;
  /**
   *
   * @type {string}
   * @memberof CreateBillingSettingsInputArgs
   */
  paymentGracePeriodUnit?: string;
  /**
   *
   * @type {number}
   * @memberof CreateBillingSettingsInputArgs
   */
  vendorId?: number;
  /**
   *
   * @type {boolean}
   * @memberof CreateBillingSettingsInputArgs
   */
  chargesEnabled?: boolean;
  /**
   *
   * @type {string}
   * @memberof CreateBillingSettingsInputArgs
   */
  customerInvoiceDetailLevel?: string;
  /**
   *
   * @type {number}
   * @memberof CreateBillingSettingsInputArgs
   */
  invoiceGracePeriodLength?: number;
}
/**
 *
 * @export
 * @interface CreateCustomerArgs
 */
export interface CreateCustomerArgs {
  /**
   *
   * @type {ContactInfoInputArgs}
   * @memberof CreateCustomerArgs
   */
  contactInfo?: ContactInfoInputArgs;
  /**
   *
   * @type {Array<string>}
   * @memberof CreateCustomerArgs
   */
  tags?: Array<string>;
  /**
   *
   * @type {number}
   * @memberof CreateCustomerArgs
   */
  vendorId?: number;
  /**
   *
   * @type {string}
   * @memberof CreateCustomerArgs
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof CreateCustomerArgs
   */
  displayName?: string;
  /**
   *
   * @type {Array<CustomerMeasurementMappingInputArgs>}
   * @memberof CreateCustomerArgs
   */
  measurementMappings?: Array<CustomerMeasurementMappingInputArgs>;
}
/**
 *
 * @export
 * @interface CreatePricePlanArgs
 */
export interface CreatePricePlanArgs {
  /**
   *
   * @type {string}
   * @memberof CreatePricePlanArgs
   */
  description?: string;
  /**
   *
   * @type {TrialInputArgs}
   * @memberof CreatePricePlanArgs
   */
  trial?: TrialInputArgs;
  /**
   *
   * @type {Array<FeatureInputArgs>}
   * @memberof CreatePricePlanArgs
   */
  features?: Array<FeatureInputArgs>;
  /**
   *
   * @type {Array<string>}
   * @memberof CreatePricePlanArgs
   */
  tags?: Array<string>;
  /**
   *
   * @type {Array<LimitInputArgs>}
   * @memberof CreatePricePlanArgs
   */
  limits?: Array<LimitInputArgs>;
  /**
   *
   * @type {number}
   * @memberof CreatePricePlanArgs
   */
  basePrice?: number;
  /**
   *
   * @type {string}
   * @memberof CreatePricePlanArgs
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof CreatePricePlanArgs
   */
  vendorId?: number;
  /**
   *
   * @type {Array<AddOnInputArgs>}
   * @memberof CreatePricePlanArgs
   */
  addOns?: Array<AddOnInputArgs>;
  /**
   *
   * @type {Array<MeteredComponentInputArgs>}
   * @memberof CreatePricePlanArgs
   */
  meteredComponents?: Array<MeteredComponentInputArgs>;
  /**
   *
   * @type {string}
   * @memberof CreatePricePlanArgs
   */
  couponName?: string;
  /**
   *
   * @type {string}
   * @memberof CreatePricePlanArgs
   */
  period?: string;
  /**
   *
   * @type {string}
   * @memberof CreatePricePlanArgs
   */
  displayName?: string;
  /**
   *
   * @type {DiscountInputArgs}
   * @memberof CreatePricePlanArgs
   */
  discount?: DiscountInputArgs;
}
/**
 *
 * @export
 * @interface CreateSubscriptionArgs
 */
export interface CreateSubscriptionArgs {
  /**
   *
   * @type {number}
   * @memberof CreateSubscriptionArgs
   */
  customerId?: number;
  /**
   *
   * @type {string}
   * @memberof CreateSubscriptionArgs
   */
  pricePlanName?: string;
  /**
   *
   * @type {string}
   * @memberof CreateSubscriptionArgs
   */
  couponOverrideName?: string;
  /**
   *
   * @type {DiscountInputArgs}
   * @memberof CreateSubscriptionArgs
   */
  discountOverride?: DiscountInputArgs;
  /**
   *
   * @type {number}
   * @memberof CreateSubscriptionArgs
   */
  vendorId?: number;
  /**
   *
   * @type {number}
   * @memberof CreateSubscriptionArgs
   */
  couponOverrideId?: number;
  /**
   *
   * @type {number}
   * @memberof CreateSubscriptionArgs
   */
  pricePlanId?: number;
  /**
   *
   * @type {Date}
   * @memberof CreateSubscriptionArgs
   */
  effectiveAt?: Date;
}
/**
 *
 * @export
 * @interface CreateVendorArgs
 */
export interface CreateVendorArgs {
  /**
   *
   * @type {ContactInfoInputArgs}
   * @memberof CreateVendorArgs
   */
  contactInfo?: ContactInfoInputArgs;
  /**
   *
   * @type {string}
   * @memberof CreateVendorArgs
   */
  apiKey?: string;
  /**
   *
   * @type {string}
   * @memberof CreateVendorArgs
   */
  vendorName?: string;
  /**
   *
   * @type {string}
   * @memberof CreateVendorArgs
   */
  vendorDisplayName?: string;
  /**
   *
   * @type {string}
   * @memberof CreateVendorArgs
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof CreateVendorArgs
   */
  displayName?: string;
}
/**
 *
 * @export
 * @interface Customer
 */
export interface Customer {
  /**
   * Unique name identifier of a customer
   * @type {string}
   * @memberof Customer
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Customer
   */
  displayName?: string;
  /**
   *
   * @type {ContactInfo}
   * @memberof Customer
   */
  contactInfo?: ContactInfo;
  /**
   *
   * @type {Array<Object>}
   * @memberof Customer
   */
  measurementMappings?: Array<Object>;
}
/**
 *
 * @export
 * @interface Customer1
 */
export interface Customer1 {
  /**
   * Unique name identifier of a customer
   * @type {string}
   * @memberof Customer1
   */
  name: string;
}
/**
 *
 * @export
 * @interface CustomerMeasurementMapping
 */
export interface CustomerMeasurementMapping {
  /**
   * The label key used to map measurements to customers.
   * @type {string}
   * @memberof CustomerMeasurementMapping
   */
  label: string;
  /**
   * A regex used to match the value of the associated label key.
   * @type {string}
   * @memberof CustomerMeasurementMapping
   */
  valueRegex?: string;
}
/**
 *
 * @export
 * @interface CustomerMeasurementMappingInputArgs
 */
export interface CustomerMeasurementMappingInputArgs {
  /**
   *
   * @type {string}
   * @memberof CustomerMeasurementMappingInputArgs
   */
  valueRegex?: string;
  /**
   *
   * @type {string}
   * @memberof CustomerMeasurementMappingInputArgs
   */
  label?: string;
}
/**
 *
 * @export
 * @interface CustomerPaymentGatewayCredentialInputArgs
 */
export interface CustomerPaymentGatewayCredentialInputArgs {
  /**
   *
   * @type {string}
   * @memberof CustomerPaymentGatewayCredentialInputArgs
   */
  accountId?: string;
}
/**
 *
 * @export
 * @interface CustomerStatus
 */
export interface CustomerStatus {
  /**
   *
   * @type {string}
   * @memberof CustomerStatus
   */
  status?: string;
}
/**
 *
 * @export
 * @interface DeleteSubscriptionArgs
 */
export interface DeleteSubscriptionArgs {
  /**
   *
   * @type {number}
   * @memberof DeleteSubscriptionArgs
   */
  vendorId?: number;
  /**
   *
   * @type {number}
   * @memberof DeleteSubscriptionArgs
   */
  customerId?: number;
  /**
   *
   * @type {Date}
   * @memberof DeleteSubscriptionArgs
   */
  expireAt?: Date;
}
/**
 *
 * @export
 * @interface Discount
 */
export interface Discount {
  /**
   *
   * @type {Object}
   * @memberof Discount
   */
  discountType?: Object;
  /**
   *
   * @type {number}
   * @memberof Discount
   */
  amount?: number;
  /**
   * The date when the discount is applied from.
   * @type {Date}
   * @memberof Discount
   */
  startDate?: Date;
  /**
   * The date when the discount ends.
   * @type {Date}
   * @memberof Discount
   */
  endDate?: Date;
  /**
   * The id of coupon associated with this discount, none if discount does not originate from coupon
   * @type {number}
   * @memberof Discount
   */
  couponId?: number;
}
/**
 *
 * @export
 * @interface DiscountInputArgs
 */
export interface DiscountInputArgs {
  /**
   *
   * @type {string}
   * @memberof DiscountInputArgs
   */
  discountType?: string;
  /**
   *
   * @type {number}
   * @memberof DiscountInputArgs
   */
  amount?: number;
}
/**
 *
 * @export
 * @interface Feature
 */
export interface Feature {
  /**
   *
   * @type {string}
   * @memberof Feature
   */
  description?: string;
  /**
   * Unique name of a feature
   * @type {string}
   * @memberof Feature
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Feature
   */
  displayName?: string;
}
/**
 *
 * @export
 * @interface FeatureInputArgs
 */
export interface FeatureInputArgs {
  /**
   *
   * @type {string}
   * @memberof FeatureInputArgs
   */
  displayName?: string;
  /**
   *
   * @type {string}
   * @memberof FeatureInputArgs
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof FeatureInputArgs
   */
  name?: string;
}
/**
 *
 * @export
 * @interface LimitInputArgs
 */
export interface LimitInputArgs {
  /**
   *
   * @type {number}
   * @memberof LimitInputArgs
   */
  limit?: number;
  /**
   *
   * @type {FeatureInputArgs}
   * @memberof LimitInputArgs
   */
  feature?: FeatureInputArgs;
}
/**
 *
 * @export
 * @interface Measurement
 */
export interface Measurement {
  /**
   * A set of key:value label pairs to supplement a measurement. Each meter defines its own set of primary and/or expected labels.
   * @type {{ [key: string]: string; }}
   * @memberof Measurement
   */
  labels?: { [key: string]: string };
  /**
   * The raw value of the measurement
   * @type {number}
   * @memberof Measurement
   */
  value: number;
  /**
   * All times are parsed as `ISO-8601` formatted, UTC-based timestamps
   * @type {Date}
   * @memberof Measurement
   */
  time?: Date;
  /**
   * The unique name of the meter associated with this measurement
   * @type {string}
   * @memberof Measurement
   */
  meterName: string;
}
/**
 *
 * @export
 * @interface Meter
 */
export interface Meter {
  /**
   * Unique name identifier
   * @type {string}
   * @memberof Meter
   */
  name: string;
  /**
   * Name used for display in UI
   * @type {string}
   * @memberof Meter
   */
  displayName?: string;
  /**
   *
   * @type {string}
   * @memberof Meter
   */
  description?: string;
  /**
   * Whether measurement values are to be considered incremental (versus a running total)
   * @type {boolean}
   * @memberof Meter
   */
  isIncremental?: boolean;
  /**
   *
   * @type {Object}
   * @memberof Meter
   */
  meterType?: Object;
  /**
   * The expected unit for the measurement values associated with this meter.
   * @type {Object}
   * @memberof Meter
   */
  unitName?: Object;
  /**
   *
   * @type {Array<Object>}
   * @memberof Meter
   */
  expectedLabels?: Array<Object>;
  /**
   *
   * @type {Array<Object>}
   * @memberof Meter
   */
  primaryLabels?: Array<Object>;
}
/**
 *
 * @export
 * @interface MeterInputArgs
 */
export interface MeterInputArgs {
  /**
   *
   * @type {string}
   * @memberof MeterInputArgs
   */
  description?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof MeterInputArgs
   */
  expectedLabels?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof MeterInputArgs
   */
  meterType?: string;
  /**
   *
   * @type {boolean}
   * @memberof MeterInputArgs
   */
  isIncremental?: boolean;
  /**
   *
   * @type {string}
   * @memberof MeterInputArgs
   */
  unitName?: string;
  /**
   *
   * @type {number}
   * @memberof MeterInputArgs
   */
  vendorId?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof MeterInputArgs
   */
  primaryLabels?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof MeterInputArgs
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof MeterInputArgs
   */
  displayName?: string;
}
/**
 *
 * @export
 * @interface MeteredComponent
 */
export interface MeteredComponent {
  /**
   * Unique name identifier
   * @type {Object}
   * @memberof MeteredComponent
   */
  meterName?: Object;
  /**
   *
   * @type {PriceScheme}
   * @memberof MeteredComponent
   */
  priceScheme?: PriceScheme;
}
/**
 *
 * @export
 * @interface MeteredComponentInputArgs
 */
export interface MeteredComponentInputArgs {
  /**
   *
   * @type {number}
   * @memberof MeteredComponentInputArgs
   */
  meterId?: number;
  /**
   *
   * @type {PriceSchemeInputArgs}
   * @memberof MeteredComponentInputArgs
   */
  priceScheme?: PriceSchemeInputArgs;
  /**
   *
   * @type {string}
   * @memberof MeteredComponentInputArgs
   */
  meterName?: string;
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   * Error code
   * @type {number}
   * @memberof ModelError
   */
  code?: number;
  /**
   * Errors
   * @type {any}
   * @memberof ModelError
   */
  errors?: any;
  /**
   * Error name
   * @type {string}
   * @memberof ModelError
   */
  status?: string;
  /**
   * Error message
   * @type {string}
   * @memberof ModelError
   */
  message?: string;
}
/**
 *
 * @export
 * @interface PaymentGatewayCredential
 */
export interface PaymentGatewayCredential {
  /**
   * One of `STRIPE` or `PADDLE`
   * @type {string}
   * @memberof PaymentGatewayCredential
   */
  paymentGateway: string;
  /**
   * Payment gateway account id associated with customer
   * @type {string}
   * @memberof PaymentGatewayCredential
   */
  accountId: string;
  /**
   * Unique name identifier of a customer
   * @type {string}
   * @memberof PaymentGatewayCredential
   */
  authToken?: string;
}
/**
 *
 * @export
 * @interface PaymentGatewayCredentialInputArgs
 */
export interface PaymentGatewayCredentialInputArgs {
  /**
   *
   * @type {string}
   * @memberof PaymentGatewayCredentialInputArgs
   */
  accountId?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentGatewayCredentialInputArgs
   */
  authToken?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentGatewayCredentialInputArgs
   */
  paymentGateway?: string;
}
/**
 *
 * @export
 * @interface PriceInputArgs
 */
export interface PriceInputArgs {
  /**
   *
   * @type {number}
   * @memberof PriceInputArgs
   */
  cap?: number;
  /**
   *
   * @type {number}
   * @memberof PriceInputArgs
   */
  price?: number;
}
/**
 *
 * @export
 * @interface PricePlan
 */
export interface PricePlan {
  /**
   * Unique name indentifier of a price plan
   * @type {string}
   * @memberof PricePlan
   */
  name: string;
  /**
   * UI-friendly name used for data display. Defaults to `name`.
   * @type {string}
   * @memberof PricePlan
   */
  displayName?: string;
  /**
   *
   * @type {string}
   * @memberof PricePlan
   */
  description?: string;
  /**
   * Lowest denomination of currency. e.g. USD is represented as cents.
   * @type {number}
   * @memberof PricePlan
   */
  basePrice?: number;
  /**
   * Time period that defines the length of a price plan cycle. One of `day`, `week`, `month`, `quarter`, or `year`.
   * @type {string}
   * @memberof PricePlan
   */
  period: string;
  /**
   *
   * @type {Coupon}
   * @memberof PricePlan
   */
  coupon?: Coupon;
  /**
   *
   * @type {Array<MeteredComponent>}
   * @memberof PricePlan
   */
  meteredComponents?: Array<MeteredComponent>;
  /**
   *
   * @type {Discount}
   * @memberof PricePlan
   */
  discount?: Discount;
  /**
   *
   * @type {Array<Feature>}
   * @memberof PricePlan
   */
  features?: Array<Feature>;
  /**
   *
   * @type {Array<PricePlanTag>}
   * @memberof PricePlan
   */
  tags?: Array<PricePlanTag>;
  /**
   *
   * @type {Trial}
   * @memberof PricePlan
   */
  trial?: Trial;
}
/**
 *
 * @export
 * @interface PricePlan1
 */
export interface PricePlan1 {
  /**
   * Unique name indentifier of a price plan
   * @type {string}
   * @memberof PricePlan1
   */
  name: string;
}
/**
 *
 * @export
 * @interface PricePlanTag
 */
export interface PricePlanTag {
  /**
   * Supplementary tag label that is associated with a specific version of a price plan
   * @type {string}
   * @memberof PricePlanTag
   */
  tag: string;
}
/**
 *
 * @export
 * @interface PriceScheme
 */
export interface PriceScheme {
  /**
   *
   * @type {string}
   * @memberof PriceScheme
   */
  displayName?: string;
  /**
   *
   * @type {string}
   * @memberof PriceScheme
   */
  name?: string;
  /**
   *
   * @type {Object}
   * @memberof PriceScheme
   */
  schemeType?: Object;
  /**
   * Array of price tiers, each of which consists of `price` and `cap` key:value pairs
   * @type {Array<PriceTier>}
   * @memberof PriceScheme
   */
  prices?: Array<PriceTier>;
  /**
   *
   * @type {string}
   * @memberof PriceScheme
   */
  timeUnitName?: string;
  /**
   *
   * @type {string}
   * @memberof PriceScheme
   */
  unitName?: string;
}
/**
 *
 * @export
 * @interface PriceSchemeInputArgs
 */
export interface PriceSchemeInputArgs {
  /**
   *
   * @type {Array<PriceInputArgs>}
   * @memberof PriceSchemeInputArgs
   */
  prices?: Array<PriceInputArgs>;
  /**
   *
   * @type {string}
   * @memberof PriceSchemeInputArgs
   */
  schemeType?: string;
  /**
   *
   * @type {string}
   * @memberof PriceSchemeInputArgs
   */
  timeUnitName?: string;
  /**
   *
   * @type {string}
   * @memberof PriceSchemeInputArgs
   */
  unitName?: string;
}
/**
 *
 * @export
 * @interface PriceTier
 */
export interface PriceTier {
  /**
   * Cap of the tier, meaning that any subsequent usage will be bucketed into the following tier. If cap is undefined, it is effectively treated as Infinity.
   * @type {number}
   * @memberof PriceTier
   */
  cap?: number;
  /**
   * The price (in lowest currency denomination by which to charge, given that the usage is within the cap range.
   * @type {number}
   * @memberof PriceTier
   */
  price: number;
}
/**
 *
 * @export
 * @interface RevenueResponse
 */
export interface RevenueResponse {
  /**
   *
   * @type {number}
   * @memberof RevenueResponse
   */
  revenue?: number;
}
/**
 *
 * @export
 * @interface Subscription
 */
export interface Subscription {
  /**
   * Unique name identifier of a customer
   * @type {Object}
   * @memberof Subscription
   */
  customerName: Object;
  /**
   * Unique name indentifier of a price plan
   * @type {Object}
   * @memberof Subscription
   */
  pricePlanName: Object;
  /**
   * Optional discount override for the associated subscription.
   * @type {Discount}
   * @memberof Subscription
   */
  discountOverride?: Discount;
  /**
   * Optional trial override for the associated subscription.
   * @type {Trial}
   * @memberof Subscription
   */
  trialOverride?: Trial;
  /**
   * Optional base price override for the associated subscription.
   * @type {number}
   * @memberof Subscription
   */
  basePriceOverride?: number;
  /**
   * ISO-8601 formatted timestamp that defines when the subscription should take effect. If this field is omitted, the subscription is effective upon creation.
   * @type {Date}
   * @memberof Subscription
   */
  effectiveAt?: Date;
}
/**
 *
 * @export
 * @interface Trial
 */
export interface Trial {
  /**
   *
   * @type {number}
   * @memberof Trial
   */
  timeLength?: number;
  /**
   *
   * @type {string}
   * @memberof Trial
   */
  timeUnitName?: string;
  /**
   *
   * @type {number}
   * @memberof Trial
   */
  credit?: number;
}
/**
 *
 * @export
 * @interface TrialInputArgs
 */
export interface TrialInputArgs {
  /**
   *
   * @type {number}
   * @memberof TrialInputArgs
   */
  timeLength?: number;
  /**
   *
   * @type {number}
   * @memberof TrialInputArgs
   */
  credit?: number;
  /**
   *
   * @type {string}
   * @memberof TrialInputArgs
   */
  timeUnitName?: string;
}
/**
 *
 * @export
 * @interface UpdateBillingSettingsInputArgs
 */
export interface UpdateBillingSettingsInputArgs {
  /**
   *
   * @type {number}
   * @memberof UpdateBillingSettingsInputArgs
   */
  paymentGracePeriodLength?: number;
  /**
   *
   * @type {boolean}
   * @memberof UpdateBillingSettingsInputArgs
   */
  shouldSendInvoiceToCustomers?: boolean;
  /**
   *
   * @type {number}
   * @memberof UpdateBillingSettingsInputArgs
   */
  customerId?: number;
  /**
   *
   * @type {string}
   * @memberof UpdateBillingSettingsInputArgs
   */
  invoiceGracePeriodUnit?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateBillingSettingsInputArgs
   */
  paymentGracePeriodUnit?: string;
  /**
   *
   * @type {number}
   * @memberof UpdateBillingSettingsInputArgs
   */
  vendorId?: number;
  /**
   *
   * @type {boolean}
   * @memberof UpdateBillingSettingsInputArgs
   */
  chargesEnabled?: boolean;
  /**
   *
   * @type {string}
   * @memberof UpdateBillingSettingsInputArgs
   */
  customerInvoiceDetailLevel?: string;
  /**
   *
   * @type {number}
   * @memberof UpdateBillingSettingsInputArgs
   */
  invoiceGracePeriodLength?: number;
}
/**
 *
 * @export
 * @interface UpdateCustomerArgs
 */
export interface UpdateCustomerArgs {
  /**
   *
   * @type {ContactInfoInputArgs}
   * @memberof UpdateCustomerArgs
   */
  contactInfo?: ContactInfoInputArgs;
  /**
   *
   * @type {Array<string>}
   * @memberof UpdateCustomerArgs
   */
  tags?: Array<string>;
  /**
   *
   * @type {number}
   * @memberof UpdateCustomerArgs
   */
  vendorId?: number;
  /**
   *
   * @type {string}
   * @memberof UpdateCustomerArgs
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateCustomerArgs
   */
  displayName?: string;
  /**
   *
   * @type {Array<CustomerMeasurementMappingInputArgs>}
   * @memberof UpdateCustomerArgs
   */
  measurementMappings?: Array<CustomerMeasurementMappingInputArgs>;
}
/**
 *
 * @export
 * @interface UpdateMeterArgs
 */
export interface UpdateMeterArgs {
  /**
   *
   * @type {string}
   * @memberof UpdateMeterArgs
   */
  description?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof UpdateMeterArgs
   */
  expectedLabels?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof UpdateMeterArgs
   */
  meterType?: string;
  /**
   *
   * @type {boolean}
   * @memberof UpdateMeterArgs
   */
  isIncremental?: boolean;
  /**
   *
   * @type {string}
   * @memberof UpdateMeterArgs
   */
  unitName?: string;
  /**
   *
   * @type {number}
   * @memberof UpdateMeterArgs
   */
  vendorId?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof UpdateMeterArgs
   */
  primaryLabels?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof UpdateMeterArgs
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateMeterArgs
   */
  displayName?: string;
}
/**
 *
 * @export
 * @interface UpdatePricePlanArgs
 */
export interface UpdatePricePlanArgs {
  /**
   *
   * @type {string}
   * @memberof UpdatePricePlanArgs
   */
  description?: string;
  /**
   *
   * @type {TrialInputArgs}
   * @memberof UpdatePricePlanArgs
   */
  trial?: TrialInputArgs;
  /**
   *
   * @type {Array<FeatureInputArgs>}
   * @memberof UpdatePricePlanArgs
   */
  features?: Array<FeatureInputArgs>;
  /**
   *
   * @type {Array<string>}
   * @memberof UpdatePricePlanArgs
   */
  tags?: Array<string>;
  /**
   *
   * @type {Array<LimitInputArgs>}
   * @memberof UpdatePricePlanArgs
   */
  limits?: Array<LimitInputArgs>;
  /**
   *
   * @type {number}
   * @memberof UpdatePricePlanArgs
   */
  basePrice?: number;
  /**
   *
   * @type {string}
   * @memberof UpdatePricePlanArgs
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof UpdatePricePlanArgs
   */
  vendorId?: number;
  /**
   *
   * @type {Array<AddOnInputArgs>}
   * @memberof UpdatePricePlanArgs
   */
  addOns?: Array<AddOnInputArgs>;
  /**
   *
   * @type {Array<MeteredComponentInputArgs>}
   * @memberof UpdatePricePlanArgs
   */
  meteredComponents?: Array<MeteredComponentInputArgs>;
  /**
   *
   * @type {string}
   * @memberof UpdatePricePlanArgs
   */
  couponName?: string;
  /**
   *
   * @type {string}
   * @memberof UpdatePricePlanArgs
   */
  period?: string;
  /**
   *
   * @type {string}
   * @memberof UpdatePricePlanArgs
   */
  displayName?: string;
  /**
   *
   * @type {DiscountInputArgs}
   * @memberof UpdatePricePlanArgs
   */
  discount?: DiscountInputArgs;
}
/**
 *
 * @export
 * @interface UpdateSubscriptionArgs
 */
export interface UpdateSubscriptionArgs {
  /**
   *
   * @type {number}
   * @memberof UpdateSubscriptionArgs
   */
  customerId?: number;
  /**
   *
   * @type {string}
   * @memberof UpdateSubscriptionArgs
   */
  pricePlanName?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateSubscriptionArgs
   */
  couponOverrideName?: string;
  /**
   *
   * @type {DiscountInputArgs}
   * @memberof UpdateSubscriptionArgs
   */
  discountOverride?: DiscountInputArgs;
  /**
   *
   * @type {number}
   * @memberof UpdateSubscriptionArgs
   */
  vendorId?: number;
  /**
   *
   * @type {number}
   * @memberof UpdateSubscriptionArgs
   */
  couponOverrideId?: number;
  /**
   *
   * @type {number}
   * @memberof UpdateSubscriptionArgs
   */
  pricePlanId?: number;
  /**
   *
   * @type {Date}
   * @memberof UpdateSubscriptionArgs
   */
  effectiveAt?: Date;
}
/**
 *
 * @export
 * @interface UpdateVendorArgs
 */
export interface UpdateVendorArgs {
  /**
   *
   * @type {number}
   * @memberof UpdateVendorArgs
   */
  vendorId?: number;
  /**
   *
   * @type {ContactInfoInputArgs}
   * @memberof UpdateVendorArgs
   */
  contactInfo?: ContactInfoInputArgs;
  /**
   *
   * @type {string}
   * @memberof UpdateVendorArgs
   */
  displayName?: string;
}
/**
 *
 * @export
 * @interface Vendor
 */
export interface Vendor {
  /**
   * Unique name identifier of a Vendor
   * @type {string}
   * @memberof Vendor
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Vendor
   */
  displayName?: string;
  /**
   *
   * @type {string}
   * @memberof Vendor
   */
  apiKey?: string;
  /**
   *
   * @type {ContactInfo}
   * @memberof Vendor
   */
  contactInfo?: ContactInfo;
}
/**
 * BillingSettingsApi - fetch parameter creator
 * @export
 */
export const BillingSettingsApiFetchParamCreator = function (
  _configuration?: Configuration,
) {
  return {
    /**
     * Delete billing settings for a vendor.
     * @summary Delete Billing Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    billingSettingsDelete(options: any = {}): FetchArgs {
      const localVarPath = `/billing_settings/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = {
        method: 'DELETE',
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch the billing settings for a vendor.
     * @summary Get Billing Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    billingSettingsGet(options: any = {}): FetchArgs {
      const localVarPath = `/billing_settings/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create billing settings for a vendor.
     * @summary Create billing settings.
     * @param {CreateBillingSettingsInputArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    billingSettingsPost(
      body: CreateBillingSettingsInputArgs,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling billingSettingsPost.',
        );
      }
      const localVarPath = `/billing_settings/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        <any>'CreateBillingSettingsInputArgs' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update billing settings for a vendor.
     * @summary Update Billing Settings
     * @param {UpdateBillingSettingsInputArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    billingSettingsPut(
      body: UpdateBillingSettingsInputArgs,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling billingSettingsPut.',
        );
      }
      const localVarPath = `/billing_settings/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'PUT', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        <any>'UpdateBillingSettingsInputArgs' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BillingSettingsApi - functional programming interface
 * @export
 */
export const BillingSettingsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Delete billing settings for a vendor.
     * @summary Delete Billing Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    billingSettingsDelete(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs =
        BillingSettingsApiFetchParamCreator(
          configuration,
        ).billingSettingsDelete(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     * Fetch the billing settings for a vendor.
     * @summary Get Billing Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    billingSettingsGet(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<BillingSettings> {
      const localVarFetchArgs =
        BillingSettingsApiFetchParamCreator(configuration).billingSettingsGet(
          options,
        );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     * Create billing settings for a vendor.
     * @summary Create billing settings.
     * @param {CreateBillingSettingsInputArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    billingSettingsPost(
      body: CreateBillingSettingsInputArgs,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<BillingSettings> {
      const localVarFetchArgs = BillingSettingsApiFetchParamCreator(
        configuration,
      ).billingSettingsPost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     * Update billing settings for a vendor.
     * @summary Update Billing Settings
     * @param {UpdateBillingSettingsInputArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    billingSettingsPut(
      body: UpdateBillingSettingsInputArgs,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<BillingSettings> {
      const localVarFetchArgs = BillingSettingsApiFetchParamCreator(
        configuration,
      ).billingSettingsPut(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
  };
};

/**
 * BillingSettingsApi - factory interface
 * @export
 */
export const BillingSettingsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Delete billing settings for a vendor.
     * @summary Delete Billing Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    billingSettingsDelete(options?: any) {
      return BillingSettingsApiFp(configuration).billingSettingsDelete(options)(
        fetch,
        basePath,
      );
    },
    /**
     * Fetch the billing settings for a vendor.
     * @summary Get Billing Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    billingSettingsGet(options?: any) {
      return BillingSettingsApiFp(configuration).billingSettingsGet(options)(
        fetch,
        basePath,
      );
    },
    /**
     * Create billing settings for a vendor.
     * @summary Create billing settings.
     * @param {CreateBillingSettingsInputArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    billingSettingsPost(body: CreateBillingSettingsInputArgs, options?: any) {
      return BillingSettingsApiFp(configuration).billingSettingsPost(
        body,
        options,
      )(fetch, basePath);
    },
    /**
     * Update billing settings for a vendor.
     * @summary Update Billing Settings
     * @param {UpdateBillingSettingsInputArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    billingSettingsPut(body: UpdateBillingSettingsInputArgs, options?: any) {
      return BillingSettingsApiFp(configuration).billingSettingsPut(
        body,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * BillingSettingsApi - object-oriented interface
 * @export
 * @class BillingSettingsApi
 * @extends {BaseAPI}
 */
export class BillingSettingsApi extends BaseAPI {
  /**
   * Delete billing settings for a vendor.
   * @summary Delete Billing Settings
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BillingSettingsApi
   */
  public billingSettingsDelete(options?: any) {
    return BillingSettingsApiFp(this.configuration).billingSettingsDelete(
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Fetch the billing settings for a vendor.
   * @summary Get Billing Settings
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BillingSettingsApi
   */
  public billingSettingsGet(options?: any) {
    return BillingSettingsApiFp(this.configuration).billingSettingsGet(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Create billing settings for a vendor.
   * @summary Create billing settings.
   * @param {CreateBillingSettingsInputArgs} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BillingSettingsApi
   */
  public billingSettingsPost(
    body: CreateBillingSettingsInputArgs,
    options?: any,
  ) {
    return BillingSettingsApiFp(this.configuration).billingSettingsPost(
      body,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Update billing settings for a vendor.
   * @summary Update Billing Settings
   * @param {UpdateBillingSettingsInputArgs} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BillingSettingsApi
   */
  public billingSettingsPut(
    body: UpdateBillingSettingsInputArgs,
    options?: any,
  ) {
    return BillingSettingsApiFp(this.configuration).billingSettingsPut(
      body,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * CouponsApi - fetch parameter creator
 * @export
 */
export const CouponsApiFetchParamCreator = function (
  _configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {ApplyCouponInputArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    couponsApplyCouponPost(
      body: ApplyCouponInputArgs,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling couponsApplyCouponPost.',
        );
      }
      const localVarPath = `/coupons/apply_coupon`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        <any>'ApplyCouponInputArgs' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a coupon by its unique name.
     * @summary Delete Coupon
     * @param {string} couponName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    couponsCouponNameDelete(couponName: string, options: any = {}): FetchArgs {
      // verify required parameter 'couponName' is not null or undefined
      if (couponName === null || couponName === undefined) {
        throw new RequiredError(
          'couponName',
          'Required parameter couponName was null or undefined when calling couponsCouponNameDelete.',
        );
      }
      const localVarPath = `/coupons/{coupon_name}`.replace(
        `{${'coupon_name'}}`,
        encodeURIComponent(String(couponName)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = {
        method: 'DELETE',
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch a Coupon by its unique name.
     * @summary Get Coupon
     * @param {string} couponName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    couponsCouponNameGet(couponName: string, options: any = {}): FetchArgs {
      // verify required parameter 'couponName' is not null or undefined
      if (couponName === null || couponName === undefined) {
        throw new RequiredError(
          'couponName',
          'Required parameter couponName was null or undefined when calling couponsCouponNameGet.',
        );
      }
      const localVarPath = `/coupons/{coupon_name}`.replace(
        `{${'coupon_name'}}`,
        encodeURIComponent(String(couponName)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets all the coupons for a vendor.
     * @summary Get Coupons
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    couponsGet(options: any = {}): FetchArgs {
      const localVarPath = `/coupons/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new coupon.
     * @summary Create coupon
     * @param {CouponInputArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    couponsPost(body: CouponInputArgs, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling couponsPost.',
        );
      }
      const localVarPath = `/coupons/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        <any>'CouponInputArgs' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CouponsApi - functional programming interface
 * @export
 */
export const CouponsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {ApplyCouponInputArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    couponsApplyCouponPost(
      body: ApplyCouponInputArgs,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = CouponsApiFetchParamCreator(
        configuration,
      ).couponsApplyCouponPost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     * Delete a coupon by its unique name.
     * @summary Delete Coupon
     * @param {string} couponName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    couponsCouponNameDelete(
      couponName: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = CouponsApiFetchParamCreator(
        configuration,
      ).couponsCouponNameDelete(couponName, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     * Fetch a Coupon by its unique name.
     * @summary Get Coupon
     * @param {string} couponName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    couponsCouponNameGet(
      couponName: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Coupon1> {
      const localVarFetchArgs = CouponsApiFetchParamCreator(
        configuration,
      ).couponsCouponNameGet(couponName, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     * Gets all the coupons for a vendor.
     * @summary Get Coupons
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    couponsGet(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Coupon1>> {
      const localVarFetchArgs =
        CouponsApiFetchParamCreator(configuration).couponsGet(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     * Create a new coupon.
     * @summary Create coupon
     * @param {CouponInputArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    couponsPost(
      body: CouponInputArgs,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Coupon1> {
      const localVarFetchArgs = CouponsApiFetchParamCreator(
        configuration,
      ).couponsPost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
  };
};

/**
 * CouponsApi - factory interface
 * @export
 */
export const CouponsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @param {ApplyCouponInputArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    couponsApplyCouponPost(body: ApplyCouponInputArgs, options?: any) {
      return CouponsApiFp(configuration).couponsApplyCouponPost(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Delete a coupon by its unique name.
     * @summary Delete Coupon
     * @param {string} couponName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    couponsCouponNameDelete(couponName: string, options?: any) {
      return CouponsApiFp(configuration).couponsCouponNameDelete(
        couponName,
        options,
      )(fetch, basePath);
    },
    /**
     * Fetch a Coupon by its unique name.
     * @summary Get Coupon
     * @param {string} couponName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    couponsCouponNameGet(couponName: string, options?: any) {
      return CouponsApiFp(configuration).couponsCouponNameGet(
        couponName,
        options,
      )(fetch, basePath);
    },
    /**
     * Gets all the coupons for a vendor.
     * @summary Get Coupons
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    couponsGet(options?: any) {
      return CouponsApiFp(configuration).couponsGet(options)(fetch, basePath);
    },
    /**
     * Create a new coupon.
     * @summary Create coupon
     * @param {CouponInputArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    couponsPost(body: CouponInputArgs, options?: any) {
      return CouponsApiFp(configuration).couponsPost(body, options)(
        fetch,
        basePath,
      );
    },
  };
};

/**
 * CouponsApi - object-oriented interface
 * @export
 * @class CouponsApi
 * @extends {BaseAPI}
 */
export class CouponsApi extends BaseAPI {
  /**
   *
   * @param {ApplyCouponInputArgs} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CouponsApi
   */
  public couponsApplyCouponPost(body: ApplyCouponInputArgs, options?: any) {
    return CouponsApiFp(this.configuration).couponsApplyCouponPost(
      body,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Delete a coupon by its unique name.
   * @summary Delete Coupon
   * @param {string} couponName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CouponsApi
   */
  public couponsCouponNameDelete(couponName: string, options?: any) {
    return CouponsApiFp(this.configuration).couponsCouponNameDelete(
      couponName,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Fetch a Coupon by its unique name.
   * @summary Get Coupon
   * @param {string} couponName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CouponsApi
   */
  public couponsCouponNameGet(couponName: string, options?: any) {
    return CouponsApiFp(this.configuration).couponsCouponNameGet(
      couponName,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Gets all the coupons for a vendor.
   * @summary Get Coupons
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CouponsApi
   */
  public couponsGet(options?: any) {
    return CouponsApiFp(this.configuration).couponsGet(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Create a new coupon.
   * @summary Create coupon
   * @param {CouponInputArgs} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CouponsApi
   */
  public couponsPost(body: CouponInputArgs, options?: any) {
    return CouponsApiFp(this.configuration).couponsPost(body, options)(
      this.fetch,
      this.basePath,
    );
  }
}
/**
 * CustomersApi - fetch parameter creator
 * @export
 */
export const CustomersApiFetchParamCreator = function (
  _configuration?: Configuration,
) {
  return {
    /**
     * Delete billing settings for a customer.
     * @summary Delete Billing Settings
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameBillingSettingsDelete(
      customerName: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'customerName' is not null or undefined
      if (customerName === null || customerName === undefined) {
        throw new RequiredError(
          'customerName',
          'Required parameter customerName was null or undefined when calling customersCustomerNameBillingSettingsDelete.',
        );
      }
      const localVarPath =
        `/customers/{customer_name}/billing_settings`.replace(
          `{${'customer_name'}}`,
          encodeURIComponent(String(customerName)),
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = {
        method: 'DELETE',
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch the billing settings for a customer.
     * @summary Get Billing Settings
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameBillingSettingsGet(
      customerName: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'customerName' is not null or undefined
      if (customerName === null || customerName === undefined) {
        throw new RequiredError(
          'customerName',
          'Required parameter customerName was null or undefined when calling customersCustomerNameBillingSettingsGet.',
        );
      }
      const localVarPath =
        `/customers/{customer_name}/billing_settings`.replace(
          `{${'customer_name'}}`,
          encodeURIComponent(String(customerName)),
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create billing settings for a vendor.
     * @summary Create billing settings.
     * @param {CreateBillingSettingsInputArgs} body
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameBillingSettingsPost(
      body: CreateBillingSettingsInputArgs,
      customerName: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling customersCustomerNameBillingSettingsPost.',
        );
      }
      // verify required parameter 'customerName' is not null or undefined
      if (customerName === null || customerName === undefined) {
        throw new RequiredError(
          'customerName',
          'Required parameter customerName was null or undefined when calling customersCustomerNameBillingSettingsPost.',
        );
      }
      const localVarPath =
        `/customers/{customer_name}/billing_settings`.replace(
          `{${'customer_name'}}`,
          encodeURIComponent(String(customerName)),
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        <any>'CreateBillingSettingsInputArgs' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update billing settings for a customer.
     * @summary Update Billing Settings.
     * @param {UpdateBillingSettingsInputArgs} body
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameBillingSettingsPut(
      body: UpdateBillingSettingsInputArgs,
      customerName: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling customersCustomerNameBillingSettingsPut.',
        );
      }
      // verify required parameter 'customerName' is not null or undefined
      if (customerName === null || customerName === undefined) {
        throw new RequiredError(
          'customerName',
          'Required parameter customerName was null or undefined when calling customersCustomerNameBillingSettingsPut.',
        );
      }
      const localVarPath =
        `/customers/{customer_name}/billing_settings`.replace(
          `{${'customer_name'}}`,
          encodeURIComponent(String(customerName)),
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'PUT', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        <any>'UpdateBillingSettingsInputArgs' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a customer by their unique name.
     * @summary Delete Customer
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameDelete(
      customerName: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'customerName' is not null or undefined
      if (customerName === null || customerName === undefined) {
        throw new RequiredError(
          'customerName',
          'Required parameter customerName was null or undefined when calling customersCustomerNameDelete.',
        );
      }
      const localVarPath = `/customers/{customer_name}`.replace(
        `{${'customer_name'}}`,
        encodeURIComponent(String(customerName)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = {
        method: 'DELETE',
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch a customer by their unique name.
     * @summary Get Customer
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameGet(
      customerName: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'customerName' is not null or undefined
      if (customerName === null || customerName === undefined) {
        throw new RequiredError(
          'customerName',
          'Required parameter customerName was null or undefined when calling customersCustomerNameGet.',
        );
      }
      const localVarPath = `/customers/{customer_name}`.replace(
        `{${'customer_name'}}`,
        encodeURIComponent(String(customerName)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * @summary Generate Current Invoice
     * @param {string} customerName
     * @param {number} invoiceId
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameInvoiceInvoiceIdTokenGet(
      customerName: string,
      invoiceId: number,
      token: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'customerName' is not null or undefined
      if (customerName === null || customerName === undefined) {
        throw new RequiredError(
          'customerName',
          'Required parameter customerName was null or undefined when calling customersCustomerNameInvoiceInvoiceIdTokenGet.',
        );
      }
      // verify required parameter 'invoiceId' is not null or undefined
      if (invoiceId === null || invoiceId === undefined) {
        throw new RequiredError(
          'invoiceId',
          'Required parameter invoiceId was null or undefined when calling customersCustomerNameInvoiceInvoiceIdTokenGet.',
        );
      }
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          'token',
          'Required parameter token was null or undefined when calling customersCustomerNameInvoiceInvoiceIdTokenGet.',
        );
      }
      const localVarPath =
        `/customers/{customer_name}/invoice/{invoice_id}/{token}`
          .replace(
            `{${'customer_name'}}`,
            encodeURIComponent(String(customerName)),
          )
          .replace(`{${'invoice_id'}}`, encodeURIComponent(String(invoiceId)))
          .replace(`{${'token'}}`, encodeURIComponent(String(token)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch all measurement mappings for a specific customer (by unique customer name).
     * @summary Get Measurement Mappings
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameMappingsGet(
      customerName: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'customerName' is not null or undefined
      if (customerName === null || customerName === undefined) {
        throw new RequiredError(
          'customerName',
          'Required parameter customerName was null or undefined when calling customersCustomerNameMappingsGet.',
        );
      }
      const localVarPath = `/customers/{customer_name}/mappings`.replace(
        `{${'customer_name'}}`,
        encodeURIComponent(String(customerName)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new measurement mapping for a customer. If no value_regex is passed, label existence is checked instead.
     * @summary Append Measurement Mapping
     * @param {CustomerMeasurementMappingInputArgs} body
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameMappingsPost(
      body: CustomerMeasurementMappingInputArgs,
      customerName: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling customersCustomerNameMappingsPost.',
        );
      }
      // verify required parameter 'customerName' is not null or undefined
      if (customerName === null || customerName === undefined) {
        throw new RequiredError(
          'customerName',
          'Required parameter customerName was null or undefined when calling customersCustomerNameMappingsPost.',
        );
      }
      const localVarPath = `/customers/{customer_name}/mappings`.replace(
        `{${'customer_name'}}`,
        encodeURIComponent(String(customerName)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        <any>'CustomerMeasurementMappingInputArgs' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add PaymentGatewayCredential for Customer
     * @param {CustomerPaymentGatewayCredentialInputArgs} body
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNamePaymentGatewayCredentialsPost(
      body: CustomerPaymentGatewayCredentialInputArgs,
      customerName: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling customersCustomerNamePaymentGatewayCredentialsPost.',
        );
      }
      // verify required parameter 'customerName' is not null or undefined
      if (customerName === null || customerName === undefined) {
        throw new RequiredError(
          'customerName',
          'Required parameter customerName was null or undefined when calling customersCustomerNamePaymentGatewayCredentialsPost.',
        );
      }
      const localVarPath =
        `/customers/{customer_name}/payment_gateway_credentials`.replace(
          `{${'customer_name'}}`,
          encodeURIComponent(String(customerName)),
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        <any>'CustomerPaymentGatewayCredentialInputArgs' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a single customer. To update Customer measurement mappings, use the `customers/{customer_name}/mappings` endpoint.
     * @summary Update Customer
     * @param {UpdateCustomerArgs} body
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNamePut(
      body: UpdateCustomerArgs,
      customerName: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling customersCustomerNamePut.',
        );
      }
      // verify required parameter 'customerName' is not null or undefined
      if (customerName === null || customerName === undefined) {
        throw new RequiredError(
          'customerName',
          'Required parameter customerName was null or undefined when calling customersCustomerNamePut.',
        );
      }
      const localVarPath = `/customers/{customer_name}`.replace(
        `{${'customer_name'}}`,
        encodeURIComponent(String(customerName)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'PUT', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        <any>'UpdateCustomerArgs' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch revenue of a customer from start_time and end_time.
     * @summary Get Customer Revenue
     * @param {string} customerName
     * @param {Date} [endTime]
     * @param {Date} [startTime]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameRevenueGet(
      customerName: string,
      endTime?: Date,
      startTime?: Date,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'customerName' is not null or undefined
      if (customerName === null || customerName === undefined) {
        throw new RequiredError(
          'customerName',
          'Required parameter customerName was null or undefined when calling customersCustomerNameRevenueGet.',
        );
      }
      const localVarPath = `/customers/{customer_name}/revenue`.replace(
        `{${'customer_name'}}`,
        encodeURIComponent(String(customerName)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      if (endTime !== undefined) {
        localVarQueryParameter.end_time = (endTime as any).toISOString();
      }

      if (startTime !== undefined) {
        localVarQueryParameter.start_time = (startTime as any).toISOString();
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * @summary Generate Current Invoice
     * @param {string} customerName
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameSampleInvoiceTokenGet(
      customerName: string,
      token: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'customerName' is not null or undefined
      if (customerName === null || customerName === undefined) {
        throw new RequiredError(
          'customerName',
          'Required parameter customerName was null or undefined when calling customersCustomerNameSampleInvoiceTokenGet.',
        );
      }
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          'token',
          'Required parameter token was null or undefined when calling customersCustomerNameSampleInvoiceTokenGet.',
        );
      }
      const localVarPath = `/customers/{customer_name}/sample_invoice/{token}`
        .replace(
          `{${'customer_name'}}`,
          encodeURIComponent(String(customerName)),
        )
        .replace(`{${'token'}}`, encodeURIComponent(String(token)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the current status for a customer.
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameStatusGet(
      customerName: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'customerName' is not null or undefined
      if (customerName === null || customerName === undefined) {
        throw new RequiredError(
          'customerName',
          'Required parameter customerName was null or undefined when calling customersCustomerNameStatusGet.',
        );
      }
      const localVarPath = `/customers/{customer_name}/status`.replace(
        `{${'customer_name'}}`,
        encodeURIComponent(String(customerName)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a subscription for a specific customer (by customer name).
     * @summary Delete Subscription
     * @param {DeleteSubscriptionArgs} body
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameSubscriptionDelete(
      body: DeleteSubscriptionArgs,
      customerName: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling customersCustomerNameSubscriptionDelete.',
        );
      }
      // verify required parameter 'customerName' is not null or undefined
      if (customerName === null || customerName === undefined) {
        throw new RequiredError(
          'customerName',
          'Required parameter customerName was null or undefined when calling customersCustomerNameSubscriptionDelete.',
        );
      }
      const localVarPath = `/customers/{customer_name}/subscription`.replace(
        `{${'customer_name'}}`,
        encodeURIComponent(String(customerName)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = {
        method: 'DELETE',
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        <any>'DeleteSubscriptionArgs' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a subscription for a specific customer (by customer name).
     * @summary Update Subscription
     * @param {UpdateSubscriptionArgs} body
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameSubscriptionPut(
      body: UpdateSubscriptionArgs,
      customerName: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling customersCustomerNameSubscriptionPut.',
        );
      }
      // verify required parameter 'customerName' is not null or undefined
      if (customerName === null || customerName === undefined) {
        throw new RequiredError(
          'customerName',
          'Required parameter customerName was null or undefined when calling customersCustomerNameSubscriptionPut.',
        );
      }
      const localVarPath = `/customers/{customer_name}/subscription`.replace(
        `{${'customer_name'}}`,
        encodeURIComponent(String(customerName)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'PUT', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        <any>'UpdateSubscriptionArgs' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all subscriptions for the customer.
     * @summary Get Subscriptions
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameSubscriptionsGet(
      customerName: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'customerName' is not null or undefined
      if (customerName === null || customerName === undefined) {
        throw new RequiredError(
          'customerName',
          'Required parameter customerName was null or undefined when calling customersCustomerNameSubscriptionsGet.',
        );
      }
      const localVarPath = `/customers/{customer_name}/subscriptions`.replace(
        `{${'customer_name'}}`,
        encodeURIComponent(String(customerName)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new subscription for a customer / price plan combination (by unique name).
     * @summary Create Subscription
     * @param {CreateSubscriptionArgs} body
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameSubscriptionsPost(
      body: CreateSubscriptionArgs,
      customerName: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling customersCustomerNameSubscriptionsPost.',
        );
      }
      // verify required parameter 'customerName' is not null or undefined
      if (customerName === null || customerName === undefined) {
        throw new RequiredError(
          'customerName',
          'Required parameter customerName was null or undefined when calling customersCustomerNameSubscriptionsPost.',
        );
      }
      const localVarPath = `/customers/{customer_name}/subscriptions`.replace(
        `{${'customer_name'}}`,
        encodeURIComponent(String(customerName)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        <any>'CreateSubscriptionArgs' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve all customers for a given vendor.
     * @summary Get All Customers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersGet(options: any = {}): FetchArgs {
      const localVarPath = `/customers/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new customer.
     * @summary Create Customer
     * @param {CreateCustomerArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersPost(body: CreateCustomerArgs, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling customersPost.',
        );
      }
      const localVarPath = `/customers/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        <any>'CreateCustomerArgs' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CustomersApi - functional programming interface
 * @export
 */
export const CustomersApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Delete billing settings for a customer.
     * @summary Delete Billing Settings
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameBillingSettingsDelete(
      customerName: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = CustomersApiFetchParamCreator(
        configuration,
      ).customersCustomerNameBillingSettingsDelete(customerName, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     * Fetch the billing settings for a customer.
     * @summary Get Billing Settings
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameBillingSettingsGet(
      customerName: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<BillingSettings> {
      const localVarFetchArgs = CustomersApiFetchParamCreator(
        configuration,
      ).customersCustomerNameBillingSettingsGet(customerName, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     * Create billing settings for a vendor.
     * @summary Create billing settings.
     * @param {CreateBillingSettingsInputArgs} body
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameBillingSettingsPost(
      body: CreateBillingSettingsInputArgs,
      customerName: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<BillingSettings> {
      const localVarFetchArgs = CustomersApiFetchParamCreator(
        configuration,
      ).customersCustomerNameBillingSettingsPost(body, customerName, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     * Update billing settings for a customer.
     * @summary Update Billing Settings.
     * @param {UpdateBillingSettingsInputArgs} body
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameBillingSettingsPut(
      body: UpdateBillingSettingsInputArgs,
      customerName: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<BillingSettings> {
      const localVarFetchArgs = CustomersApiFetchParamCreator(
        configuration,
      ).customersCustomerNameBillingSettingsPut(body, customerName, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     * Delete a customer by their unique name.
     * @summary Delete Customer
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameDelete(
      customerName: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = CustomersApiFetchParamCreator(
        configuration,
      ).customersCustomerNameDelete(customerName, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     * Fetch a customer by their unique name.
     * @summary Get Customer
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameGet(
      customerName: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Customer> {
      const localVarFetchArgs = CustomersApiFetchParamCreator(
        configuration,
      ).customersCustomerNameGet(customerName, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * @summary Generate Current Invoice
     * @param {string} customerName
     * @param {number} invoiceId
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameInvoiceInvoiceIdTokenGet(
      customerName: string,
      invoiceId: number,
      token: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Error> {
      const localVarFetchArgs = CustomersApiFetchParamCreator(
        configuration,
      ).customersCustomerNameInvoiceInvoiceIdTokenGet(
        customerName,
        invoiceId,
        token,
        options,
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     * Fetch all measurement mappings for a specific customer (by unique customer name).
     * @summary Get Measurement Mappings
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameMappingsGet(
      customerName: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<Array<CustomerMeasurementMapping>> {
      const localVarFetchArgs = CustomersApiFetchParamCreator(
        configuration,
      ).customersCustomerNameMappingsGet(customerName, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     * Create a new measurement mapping for a customer. If no value_regex is passed, label existence is checked instead.
     * @summary Append Measurement Mapping
     * @param {CustomerMeasurementMappingInputArgs} body
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameMappingsPost(
      body: CustomerMeasurementMappingInputArgs,
      customerName: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<CustomerMeasurementMapping> {
      const localVarFetchArgs = CustomersApiFetchParamCreator(
        configuration,
      ).customersCustomerNameMappingsPost(body, customerName, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Add PaymentGatewayCredential for Customer
     * @param {CustomerPaymentGatewayCredentialInputArgs} body
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNamePaymentGatewayCredentialsPost(
      body: CustomerPaymentGatewayCredentialInputArgs,
      customerName: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<PaymentGatewayCredential> {
      const localVarFetchArgs = CustomersApiFetchParamCreator(
        configuration,
      ).customersCustomerNamePaymentGatewayCredentialsPost(
        body,
        customerName,
        options,
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     * Update a single customer. To update Customer measurement mappings, use the `customers/{customer_name}/mappings` endpoint.
     * @summary Update Customer
     * @param {UpdateCustomerArgs} body
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNamePut(
      body: UpdateCustomerArgs,
      customerName: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Customer> {
      const localVarFetchArgs = CustomersApiFetchParamCreator(
        configuration,
      ).customersCustomerNamePut(body, customerName, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     * Fetch revenue of a customer from start_time and end_time.
     * @summary Get Customer Revenue
     * @param {string} customerName
     * @param {Date} [endTime]
     * @param {Date} [startTime]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameRevenueGet(
      customerName: string,
      endTime?: Date,
      startTime?: Date,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<RevenueResponse> {
      const localVarFetchArgs = CustomersApiFetchParamCreator(
        configuration,
      ).customersCustomerNameRevenueGet(
        customerName,
        endTime,
        startTime,
        options,
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * @summary Generate Current Invoice
     * @param {string} customerName
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameSampleInvoiceTokenGet(
      customerName: string,
      token: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Error> {
      const localVarFetchArgs = CustomersApiFetchParamCreator(
        configuration,
      ).customersCustomerNameSampleInvoiceTokenGet(
        customerName,
        token,
        options,
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Get the current status for a customer.
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameStatusGet(
      customerName: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerStatus> {
      const localVarFetchArgs = CustomersApiFetchParamCreator(
        configuration,
      ).customersCustomerNameStatusGet(customerName, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     * Delete a subscription for a specific customer (by customer name).
     * @summary Delete Subscription
     * @param {DeleteSubscriptionArgs} body
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameSubscriptionDelete(
      body: DeleteSubscriptionArgs,
      customerName: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = CustomersApiFetchParamCreator(
        configuration,
      ).customersCustomerNameSubscriptionDelete(body, customerName, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     * Update a subscription for a specific customer (by customer name).
     * @summary Update Subscription
     * @param {UpdateSubscriptionArgs} body
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameSubscriptionPut(
      body: UpdateSubscriptionArgs,
      customerName: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Subscription> {
      const localVarFetchArgs = CustomersApiFetchParamCreator(
        configuration,
      ).customersCustomerNameSubscriptionPut(body, customerName, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     * Get all subscriptions for the customer.
     * @summary Get Subscriptions
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameSubscriptionsGet(
      customerName: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Subscription>> {
      const localVarFetchArgs = CustomersApiFetchParamCreator(
        configuration,
      ).customersCustomerNameSubscriptionsGet(customerName, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     * Create a new subscription for a customer / price plan combination (by unique name).
     * @summary Create Subscription
     * @param {CreateSubscriptionArgs} body
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameSubscriptionsPost(
      body: CreateSubscriptionArgs,
      customerName: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Subscription> {
      const localVarFetchArgs = CustomersApiFetchParamCreator(
        configuration,
      ).customersCustomerNameSubscriptionsPost(body, customerName, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     * Retrieve all customers for a given vendor.
     * @summary Get All Customers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersGet(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Customer>> {
      const localVarFetchArgs =
        CustomersApiFetchParamCreator(configuration).customersGet(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     * Create a new customer.
     * @summary Create Customer
     * @param {CreateCustomerArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersPost(
      body: CreateCustomerArgs,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Customer> {
      const localVarFetchArgs = CustomersApiFetchParamCreator(
        configuration,
      ).customersPost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
  };
};

/**
 * CustomersApi - factory interface
 * @export
 */
export const CustomersApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Delete billing settings for a customer.
     * @summary Delete Billing Settings
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameBillingSettingsDelete(
      customerName: string,
      options?: any,
    ) {
      return CustomersApiFp(
        configuration,
      ).customersCustomerNameBillingSettingsDelete(customerName, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Fetch the billing settings for a customer.
     * @summary Get Billing Settings
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameBillingSettingsGet(
      customerName: string,
      options?: any,
    ) {
      return CustomersApiFp(
        configuration,
      ).customersCustomerNameBillingSettingsGet(customerName, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Create billing settings for a vendor.
     * @summary Create billing settings.
     * @param {CreateBillingSettingsInputArgs} body
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameBillingSettingsPost(
      body: CreateBillingSettingsInputArgs,
      customerName: string,
      options?: any,
    ) {
      return CustomersApiFp(
        configuration,
      ).customersCustomerNameBillingSettingsPost(
        body,
        customerName,
        options,
      )(fetch, basePath);
    },
    /**
     * Update billing settings for a customer.
     * @summary Update Billing Settings.
     * @param {UpdateBillingSettingsInputArgs} body
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameBillingSettingsPut(
      body: UpdateBillingSettingsInputArgs,
      customerName: string,
      options?: any,
    ) {
      return CustomersApiFp(
        configuration,
      ).customersCustomerNameBillingSettingsPut(
        body,
        customerName,
        options,
      )(fetch, basePath);
    },
    /**
     * Delete a customer by their unique name.
     * @summary Delete Customer
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameDelete(customerName: string, options?: any) {
      return CustomersApiFp(configuration).customersCustomerNameDelete(
        customerName,
        options,
      )(fetch, basePath);
    },
    /**
     * Fetch a customer by their unique name.
     * @summary Get Customer
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameGet(customerName: string, options?: any) {
      return CustomersApiFp(configuration).customersCustomerNameGet(
        customerName,
        options,
      )(fetch, basePath);
    },
    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * @summary Generate Current Invoice
     * @param {string} customerName
     * @param {number} invoiceId
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameInvoiceInvoiceIdTokenGet(
      customerName: string,
      invoiceId: number,
      token: string,
      options?: any,
    ) {
      return CustomersApiFp(
        configuration,
      ).customersCustomerNameInvoiceInvoiceIdTokenGet(
        customerName,
        invoiceId,
        token,
        options,
      )(fetch, basePath);
    },
    /**
     * Fetch all measurement mappings for a specific customer (by unique customer name).
     * @summary Get Measurement Mappings
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameMappingsGet(customerName: string, options?: any) {
      return CustomersApiFp(configuration).customersCustomerNameMappingsGet(
        customerName,
        options,
      )(fetch, basePath);
    },
    /**
     * Create a new measurement mapping for a customer. If no value_regex is passed, label existence is checked instead.
     * @summary Append Measurement Mapping
     * @param {CustomerMeasurementMappingInputArgs} body
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameMappingsPost(
      body: CustomerMeasurementMappingInputArgs,
      customerName: string,
      options?: any,
    ) {
      return CustomersApiFp(configuration).customersCustomerNameMappingsPost(
        body,
        customerName,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Add PaymentGatewayCredential for Customer
     * @param {CustomerPaymentGatewayCredentialInputArgs} body
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNamePaymentGatewayCredentialsPost(
      body: CustomerPaymentGatewayCredentialInputArgs,
      customerName: string,
      options?: any,
    ) {
      return CustomersApiFp(
        configuration,
      ).customersCustomerNamePaymentGatewayCredentialsPost(
        body,
        customerName,
        options,
      )(fetch, basePath);
    },
    /**
     * Update a single customer. To update Customer measurement mappings, use the `customers/{customer_name}/mappings` endpoint.
     * @summary Update Customer
     * @param {UpdateCustomerArgs} body
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNamePut(
      body: UpdateCustomerArgs,
      customerName: string,
      options?: any,
    ) {
      return CustomersApiFp(configuration).customersCustomerNamePut(
        body,
        customerName,
        options,
      )(fetch, basePath);
    },
    /**
     * Fetch revenue of a customer from start_time and end_time.
     * @summary Get Customer Revenue
     * @param {string} customerName
     * @param {Date} [endTime]
     * @param {Date} [startTime]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameRevenueGet(
      customerName: string,
      endTime?: Date,
      startTime?: Date,
      options?: any,
    ) {
      return CustomersApiFp(configuration).customersCustomerNameRevenueGet(
        customerName,
        endTime,
        startTime,
        options,
      )(fetch, basePath);
    },
    /**
     * Fetch current cycle revenue for a customer and generate an invoice.
     * @summary Generate Current Invoice
     * @param {string} customerName
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameSampleInvoiceTokenGet(
      customerName: string,
      token: string,
      options?: any,
    ) {
      return CustomersApiFp(
        configuration,
      ).customersCustomerNameSampleInvoiceTokenGet(
        customerName,
        token,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the current status for a customer.
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameStatusGet(customerName: string, options?: any) {
      return CustomersApiFp(configuration).customersCustomerNameStatusGet(
        customerName,
        options,
      )(fetch, basePath);
    },
    /**
     * Delete a subscription for a specific customer (by customer name).
     * @summary Delete Subscription
     * @param {DeleteSubscriptionArgs} body
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameSubscriptionDelete(
      body: DeleteSubscriptionArgs,
      customerName: string,
      options?: any,
    ) {
      return CustomersApiFp(
        configuration,
      ).customersCustomerNameSubscriptionDelete(
        body,
        customerName,
        options,
      )(fetch, basePath);
    },
    /**
     * Update a subscription for a specific customer (by customer name).
     * @summary Update Subscription
     * @param {UpdateSubscriptionArgs} body
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameSubscriptionPut(
      body: UpdateSubscriptionArgs,
      customerName: string,
      options?: any,
    ) {
      return CustomersApiFp(configuration).customersCustomerNameSubscriptionPut(
        body,
        customerName,
        options,
      )(fetch, basePath);
    },
    /**
     * Get all subscriptions for the customer.
     * @summary Get Subscriptions
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameSubscriptionsGet(customerName: string, options?: any) {
      return CustomersApiFp(
        configuration,
      ).customersCustomerNameSubscriptionsGet(customerName, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Create a new subscription for a customer / price plan combination (by unique name).
     * @summary Create Subscription
     * @param {CreateSubscriptionArgs} body
     * @param {string} customerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCustomerNameSubscriptionsPost(
      body: CreateSubscriptionArgs,
      customerName: string,
      options?: any,
    ) {
      return CustomersApiFp(
        configuration,
      ).customersCustomerNameSubscriptionsPost(
        body,
        customerName,
        options,
      )(fetch, basePath);
    },
    /**
     * Retrieve all customers for a given vendor.
     * @summary Get All Customers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersGet(options?: any) {
      return CustomersApiFp(configuration).customersGet(options)(
        fetch,
        basePath,
      );
    },
    /**
     * Create a new customer.
     * @summary Create Customer
     * @param {CreateCustomerArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersPost(body: CreateCustomerArgs, options?: any) {
      return CustomersApiFp(configuration).customersPost(body, options)(
        fetch,
        basePath,
      );
    },
  };
};

/**
 * CustomersApi - object-oriented interface
 * @export
 * @class CustomersApi
 * @extends {BaseAPI}
 */
export class CustomersApi extends BaseAPI {
  /**
   * Delete billing settings for a customer.
   * @summary Delete Billing Settings
   * @param {string} customerName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public customersCustomerNameBillingSettingsDelete(
    customerName: string,
    options?: any,
  ) {
    return CustomersApiFp(
      this.configuration,
    ).customersCustomerNameBillingSettingsDelete(customerName, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Fetch the billing settings for a customer.
   * @summary Get Billing Settings
   * @param {string} customerName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public customersCustomerNameBillingSettingsGet(
    customerName: string,
    options?: any,
  ) {
    return CustomersApiFp(
      this.configuration,
    ).customersCustomerNameBillingSettingsGet(customerName, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Create billing settings for a vendor.
   * @summary Create billing settings.
   * @param {CreateBillingSettingsInputArgs} body
   * @param {string} customerName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public customersCustomerNameBillingSettingsPost(
    body: CreateBillingSettingsInputArgs,
    customerName: string,
    options?: any,
  ) {
    return CustomersApiFp(
      this.configuration,
    ).customersCustomerNameBillingSettingsPost(
      body,
      customerName,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Update billing settings for a customer.
   * @summary Update Billing Settings.
   * @param {UpdateBillingSettingsInputArgs} body
   * @param {string} customerName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public customersCustomerNameBillingSettingsPut(
    body: UpdateBillingSettingsInputArgs,
    customerName: string,
    options?: any,
  ) {
    return CustomersApiFp(
      this.configuration,
    ).customersCustomerNameBillingSettingsPut(
      body,
      customerName,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Delete a customer by their unique name.
   * @summary Delete Customer
   * @param {string} customerName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public customersCustomerNameDelete(customerName: string, options?: any) {
    return CustomersApiFp(this.configuration).customersCustomerNameDelete(
      customerName,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Fetch a customer by their unique name.
   * @summary Get Customer
   * @param {string} customerName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public customersCustomerNameGet(customerName: string, options?: any) {
    return CustomersApiFp(this.configuration).customersCustomerNameGet(
      customerName,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Fetch current cycle revenue for a customer and generate an invoice.
   * @summary Generate Current Invoice
   * @param {string} customerName
   * @param {number} invoiceId
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public customersCustomerNameInvoiceInvoiceIdTokenGet(
    customerName: string,
    invoiceId: number,
    token: string,
    options?: any,
  ) {
    return CustomersApiFp(
      this.configuration,
    ).customersCustomerNameInvoiceInvoiceIdTokenGet(
      customerName,
      invoiceId,
      token,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Fetch all measurement mappings for a specific customer (by unique customer name).
   * @summary Get Measurement Mappings
   * @param {string} customerName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public customersCustomerNameMappingsGet(customerName: string, options?: any) {
    return CustomersApiFp(this.configuration).customersCustomerNameMappingsGet(
      customerName,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Create a new measurement mapping for a customer. If no value_regex is passed, label existence is checked instead.
   * @summary Append Measurement Mapping
   * @param {CustomerMeasurementMappingInputArgs} body
   * @param {string} customerName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public customersCustomerNameMappingsPost(
    body: CustomerMeasurementMappingInputArgs,
    customerName: string,
    options?: any,
  ) {
    return CustomersApiFp(this.configuration).customersCustomerNameMappingsPost(
      body,
      customerName,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Add PaymentGatewayCredential for Customer
   * @param {CustomerPaymentGatewayCredentialInputArgs} body
   * @param {string} customerName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public customersCustomerNamePaymentGatewayCredentialsPost(
    body: CustomerPaymentGatewayCredentialInputArgs,
    customerName: string,
    options?: any,
  ) {
    return CustomersApiFp(
      this.configuration,
    ).customersCustomerNamePaymentGatewayCredentialsPost(
      body,
      customerName,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Update a single customer. To update Customer measurement mappings, use the `customers/{customer_name}/mappings` endpoint.
   * @summary Update Customer
   * @param {UpdateCustomerArgs} body
   * @param {string} customerName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public customersCustomerNamePut(
    body: UpdateCustomerArgs,
    customerName: string,
    options?: any,
  ) {
    return CustomersApiFp(this.configuration).customersCustomerNamePut(
      body,
      customerName,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Fetch revenue of a customer from start_time and end_time.
   * @summary Get Customer Revenue
   * @param {string} customerName
   * @param {Date} [endTime]
   * @param {Date} [startTime]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public customersCustomerNameRevenueGet(
    customerName: string,
    endTime?: Date,
    startTime?: Date,
    options?: any,
  ) {
    return CustomersApiFp(this.configuration).customersCustomerNameRevenueGet(
      customerName,
      endTime,
      startTime,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Fetch current cycle revenue for a customer and generate an invoice.
   * @summary Generate Current Invoice
   * @param {string} customerName
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public customersCustomerNameSampleInvoiceTokenGet(
    customerName: string,
    token: string,
    options?: any,
  ) {
    return CustomersApiFp(
      this.configuration,
    ).customersCustomerNameSampleInvoiceTokenGet(
      customerName,
      token,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the current status for a customer.
   * @param {string} customerName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public customersCustomerNameStatusGet(customerName: string, options?: any) {
    return CustomersApiFp(this.configuration).customersCustomerNameStatusGet(
      customerName,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Delete a subscription for a specific customer (by customer name).
   * @summary Delete Subscription
   * @param {DeleteSubscriptionArgs} body
   * @param {string} customerName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public customersCustomerNameSubscriptionDelete(
    body: DeleteSubscriptionArgs,
    customerName: string,
    options?: any,
  ) {
    return CustomersApiFp(
      this.configuration,
    ).customersCustomerNameSubscriptionDelete(
      body,
      customerName,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Update a subscription for a specific customer (by customer name).
   * @summary Update Subscription
   * @param {UpdateSubscriptionArgs} body
   * @param {string} customerName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public customersCustomerNameSubscriptionPut(
    body: UpdateSubscriptionArgs,
    customerName: string,
    options?: any,
  ) {
    return CustomersApiFp(
      this.configuration,
    ).customersCustomerNameSubscriptionPut(
      body,
      customerName,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Get all subscriptions for the customer.
   * @summary Get Subscriptions
   * @param {string} customerName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public customersCustomerNameSubscriptionsGet(
    customerName: string,
    options?: any,
  ) {
    return CustomersApiFp(
      this.configuration,
    ).customersCustomerNameSubscriptionsGet(customerName, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Create a new subscription for a customer / price plan combination (by unique name).
   * @summary Create Subscription
   * @param {CreateSubscriptionArgs} body
   * @param {string} customerName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public customersCustomerNameSubscriptionsPost(
    body: CreateSubscriptionArgs,
    customerName: string,
    options?: any,
  ) {
    return CustomersApiFp(
      this.configuration,
    ).customersCustomerNameSubscriptionsPost(
      body,
      customerName,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Retrieve all customers for a given vendor.
   * @summary Get All Customers
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public customersGet(options?: any) {
    return CustomersApiFp(this.configuration).customersGet(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Create a new customer.
   * @summary Create Customer
   * @param {CreateCustomerArgs} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public customersPost(body: CreateCustomerArgs, options?: any) {
    return CustomersApiFp(this.configuration).customersPost(body, options)(
      this.fetch,
      this.basePath,
    );
  }
}
/**
 * MeasurementsApi - fetch parameter creator
 * @export
 */
export const MeasurementsApiFetchParamCreator = function (
  _configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Send Batched Measurements
     * @param {Array<Measurement>} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    measurementsMultiPost(
      body: Array<Measurement>,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling measurementsMultiPost.',
        );
      }
      const localVarPath = `/measurements/multi`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        <any>'Array&lt;Measurement&gt;' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Send Measurement
     * @param {Measurement} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    measurementsPost(body: Measurement, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling measurementsPost.',
        );
      }
      const localVarPath = `/measurements/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        <any>'Measurement' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MeasurementsApi - functional programming interface
 * @export
 */
export const MeasurementsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Send Batched Measurements
     * @param {Array<Measurement>} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    measurementsMultiPost(
      body: Array<Measurement>,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Measurement>> {
      const localVarFetchArgs = MeasurementsApiFetchParamCreator(
        configuration,
      ).measurementsMultiPost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Send Measurement
     * @param {Measurement} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    measurementsPost(
      body: Measurement,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Measurement> {
      const localVarFetchArgs = MeasurementsApiFetchParamCreator(
        configuration,
      ).measurementsPost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
  };
};

/**
 * MeasurementsApi - factory interface
 * @export
 */
export const MeasurementsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @summary Send Batched Measurements
     * @param {Array<Measurement>} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    measurementsMultiPost(body: Array<Measurement>, options?: any) {
      return MeasurementsApiFp(configuration).measurementsMultiPost(
        body,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Send Measurement
     * @param {Measurement} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    measurementsPost(body: Measurement, options?: any) {
      return MeasurementsApiFp(configuration).measurementsPost(body, options)(
        fetch,
        basePath,
      );
    },
  };
};

/**
 * MeasurementsApi - object-oriented interface
 * @export
 * @class MeasurementsApi
 * @extends {BaseAPI}
 */
export class MeasurementsApi extends BaseAPI {
  /**
   *
   * @summary Send Batched Measurements
   * @param {Array<Measurement>} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MeasurementsApi
   */
  public measurementsMultiPost(body: Array<Measurement>, options?: any) {
    return MeasurementsApiFp(this.configuration).measurementsMultiPost(
      body,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Send Measurement
   * @param {Measurement} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MeasurementsApi
   */
  public measurementsPost(body: Measurement, options?: any) {
    return MeasurementsApiFp(this.configuration).measurementsPost(
      body,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * MetersApi - fetch parameter creator
 * @export
 */
export const MetersApiFetchParamCreator = function (
  _configuration?: Configuration,
) {
  return {
    /**
     * Retrieve all meters for a given vendor.
     * @summary Get Meters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metersGet(options: any = {}): FetchArgs {
      const localVarPath = `/meters/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a meter by its unique name. Meters can only be deleted if not in-use by a price plan.
     * @summary Delete Meter
     * @param {string} meterName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metersMeterNameDelete(meterName: string, options: any = {}): FetchArgs {
      // verify required parameter 'meterName' is not null or undefined
      if (meterName === null || meterName === undefined) {
        throw new RequiredError(
          'meterName',
          'Required parameter meterName was null or undefined when calling metersMeterNameDelete.',
        );
      }
      const localVarPath = `/meters/{meter_name}`.replace(
        `{${'meter_name'}}`,
        encodeURIComponent(String(meterName)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = {
        method: 'DELETE',
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch a meter by its unique name
     * @summary Get Meter
     * @param {string} meterName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metersMeterNameGet(meterName: string, options: any = {}): FetchArgs {
      // verify required parameter 'meterName' is not null or undefined
      if (meterName === null || meterName === undefined) {
        throw new RequiredError(
          'meterName',
          'Required parameter meterName was null or undefined when calling metersMeterNameGet.',
        );
      }
      const localVarPath = `/meters/{meter_name}`.replace(
        `{${'meter_name'}}`,
        encodeURIComponent(String(meterName)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a meter by its unique name
     * @summary Update Meter
     * @param {UpdateMeterArgs} body
     * @param {string} meterName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metersMeterNamePut(
      body: UpdateMeterArgs,
      meterName: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling metersMeterNamePut.',
        );
      }
      // verify required parameter 'meterName' is not null or undefined
      if (meterName === null || meterName === undefined) {
        throw new RequiredError(
          'meterName',
          'Required parameter meterName was null or undefined when calling metersMeterNamePut.',
        );
      }
      const localVarPath = `/meters/{meter_name}`.replace(
        `{${'meter_name'}}`,
        encodeURIComponent(String(meterName)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'PUT', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        <any>'UpdateMeterArgs' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new Meter.
     * @summary Create Meter
     * @param {MeterInputArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metersPost(body: MeterInputArgs, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling metersPost.',
        );
      }
      const localVarPath = `/meters/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        <any>'MeterInputArgs' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MetersApi - functional programming interface
 * @export
 */
export const MetersApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Retrieve all meters for a given vendor.
     * @summary Get Meters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metersGet(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Meter>> {
      const localVarFetchArgs =
        MetersApiFetchParamCreator(configuration).metersGet(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     * Delete a meter by its unique name. Meters can only be deleted if not in-use by a price plan.
     * @summary Delete Meter
     * @param {string} meterName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metersMeterNameDelete(
      meterName: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = MetersApiFetchParamCreator(
        configuration,
      ).metersMeterNameDelete(meterName, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     * Fetch a meter by its unique name
     * @summary Get Meter
     * @param {string} meterName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metersMeterNameGet(
      meterName: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Meter> {
      const localVarFetchArgs = MetersApiFetchParamCreator(
        configuration,
      ).metersMeterNameGet(meterName, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     * Update a meter by its unique name
     * @summary Update Meter
     * @param {UpdateMeterArgs} body
     * @param {string} meterName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metersMeterNamePut(
      body: UpdateMeterArgs,
      meterName: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Meter> {
      const localVarFetchArgs = MetersApiFetchParamCreator(
        configuration,
      ).metersMeterNamePut(body, meterName, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     * Create a new Meter.
     * @summary Create Meter
     * @param {MeterInputArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metersPost(
      body: MeterInputArgs,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Meter> {
      const localVarFetchArgs = MetersApiFetchParamCreator(
        configuration,
      ).metersPost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
  };
};

/**
 * MetersApi - factory interface
 * @export
 */
export const MetersApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Retrieve all meters for a given vendor.
     * @summary Get Meters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metersGet(options?: any) {
      return MetersApiFp(configuration).metersGet(options)(fetch, basePath);
    },
    /**
     * Delete a meter by its unique name. Meters can only be deleted if not in-use by a price plan.
     * @summary Delete Meter
     * @param {string} meterName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metersMeterNameDelete(meterName: string, options?: any) {
      return MetersApiFp(configuration).metersMeterNameDelete(
        meterName,
        options,
      )(fetch, basePath);
    },
    /**
     * Fetch a meter by its unique name
     * @summary Get Meter
     * @param {string} meterName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metersMeterNameGet(meterName: string, options?: any) {
      return MetersApiFp(configuration).metersMeterNameGet(meterName, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Update a meter by its unique name
     * @summary Update Meter
     * @param {UpdateMeterArgs} body
     * @param {string} meterName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metersMeterNamePut(
      body: UpdateMeterArgs,
      meterName: string,
      options?: any,
    ) {
      return MetersApiFp(configuration).metersMeterNamePut(
        body,
        meterName,
        options,
      )(fetch, basePath);
    },
    /**
     * Create a new Meter.
     * @summary Create Meter
     * @param {MeterInputArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metersPost(body: MeterInputArgs, options?: any) {
      return MetersApiFp(configuration).metersPost(body, options)(
        fetch,
        basePath,
      );
    },
  };
};

/**
 * MetersApi - object-oriented interface
 * @export
 * @class MetersApi
 * @extends {BaseAPI}
 */
export class MetersApi extends BaseAPI {
  /**
   * Retrieve all meters for a given vendor.
   * @summary Get Meters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetersApi
   */
  public metersGet(options?: any) {
    return MetersApiFp(this.configuration).metersGet(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Delete a meter by its unique name. Meters can only be deleted if not in-use by a price plan.
   * @summary Delete Meter
   * @param {string} meterName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetersApi
   */
  public metersMeterNameDelete(meterName: string, options?: any) {
    return MetersApiFp(this.configuration).metersMeterNameDelete(
      meterName,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Fetch a meter by its unique name
   * @summary Get Meter
   * @param {string} meterName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetersApi
   */
  public metersMeterNameGet(meterName: string, options?: any) {
    return MetersApiFp(this.configuration).metersMeterNameGet(
      meterName,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Update a meter by its unique name
   * @summary Update Meter
   * @param {UpdateMeterArgs} body
   * @param {string} meterName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetersApi
   */
  public metersMeterNamePut(
    body: UpdateMeterArgs,
    meterName: string,
    options?: any,
  ) {
    return MetersApiFp(this.configuration).metersMeterNamePut(
      body,
      meterName,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Create a new Meter.
   * @summary Create Meter
   * @param {MeterInputArgs} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetersApi
   */
  public metersPost(body: MeterInputArgs, options?: any) {
    return MetersApiFp(this.configuration).metersPost(body, options)(
      this.fetch,
      this.basePath,
    );
  }
}
/**
 * PaymentGatewayCredentialApi - fetch parameter creator
 * @export
 */
export const PaymentGatewayCredentialApiFetchParamCreator = function (
  _configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Add PaymentGatewayCredential for Vendor
     * @param {PaymentGatewayCredentialInputArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentGatewayCredentialsPost(
      body: PaymentGatewayCredentialInputArgs,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling paymentGatewayCredentialsPost.',
        );
      }
      const localVarPath = `/payment_gateway_credentials/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        <any>'PaymentGatewayCredentialInputArgs' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PaymentGatewayCredentialApi - functional programming interface
 * @export
 */
export const PaymentGatewayCredentialApiFp = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Add PaymentGatewayCredential for Vendor
     * @param {PaymentGatewayCredentialInputArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentGatewayCredentialsPost(
      body: PaymentGatewayCredentialInputArgs,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<PaymentGatewayCredential> {
      const localVarFetchArgs = PaymentGatewayCredentialApiFetchParamCreator(
        configuration,
      ).paymentGatewayCredentialsPost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
  };
};

/**
 * PaymentGatewayCredentialApi - factory interface
 * @export
 */
export const PaymentGatewayCredentialApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @summary Add PaymentGatewayCredential for Vendor
     * @param {PaymentGatewayCredentialInputArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentGatewayCredentialsPost(
      body: PaymentGatewayCredentialInputArgs,
      options?: any,
    ) {
      return PaymentGatewayCredentialApiFp(
        configuration,
      ).paymentGatewayCredentialsPost(body, options)(fetch, basePath);
    },
  };
};

/**
 * PaymentGatewayCredentialApi - object-oriented interface
 * @export
 * @class PaymentGatewayCredentialApi
 * @extends {BaseAPI}
 */
export class PaymentGatewayCredentialApi extends BaseAPI {
  /**
   *
   * @summary Add PaymentGatewayCredential for Vendor
   * @param {PaymentGatewayCredentialInputArgs} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentGatewayCredentialApi
   */
  public paymentGatewayCredentialsPost(
    body: PaymentGatewayCredentialInputArgs,
    options?: any,
  ) {
    return PaymentGatewayCredentialApiFp(
      this.configuration,
    ).paymentGatewayCredentialsPost(body, options)(this.fetch, this.basePath);
  }
}
/**
 * PricePlansApi - fetch parameter creator
 * @export
 */
export const PricePlansApiFetchParamCreator = function (
  _configuration?: Configuration,
) {
  return {
    /**
     * Fetch all price plans associated with a vendor.
     * @summary Get All Price Plans
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pricePlansGet(options: any = {}): FetchArgs {
      const localVarPath = `/price_plans/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create Price Plan
     * @param {CreatePricePlanArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pricePlansPost(body: CreatePricePlanArgs, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling pricePlansPost.',
        );
      }
      const localVarPath = `/price_plans/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        <any>'CreatePricePlanArgs' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete an existing Price Plan. Plans which map to active Subscriptions must be replaced or removed before deletion can occur.
     * @summary Delete Price Plan
     * @param {string} pricePlanName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pricePlansPricePlanNameDelete(
      pricePlanName: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'pricePlanName' is not null or undefined
      if (pricePlanName === null || pricePlanName === undefined) {
        throw new RequiredError(
          'pricePlanName',
          'Required parameter pricePlanName was null or undefined when calling pricePlansPricePlanNameDelete.',
        );
      }
      const localVarPath = `/price_plans/{price_plan_name}`.replace(
        `{${'price_plan_name'}}`,
        encodeURIComponent(String(pricePlanName)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = {
        method: 'DELETE',
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch an existing price plan.
     * @summary Get a Price Plan
     * @param {string} pricePlanName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pricePlansPricePlanNameGet(
      pricePlanName: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'pricePlanName' is not null or undefined
      if (pricePlanName === null || pricePlanName === undefined) {
        throw new RequiredError(
          'pricePlanName',
          'Required parameter pricePlanName was null or undefined when calling pricePlansPricePlanNameGet.',
        );
      }
      const localVarPath = `/price_plans/{price_plan_name}`.replace(
        `{${'price_plan_name'}}`,
        encodeURIComponent(String(pricePlanName)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update an existing price plan.
     * @summary Update a Price Plan
     * @param {UpdatePricePlanArgs} body
     * @param {string} pricePlanName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pricePlansPricePlanNamePut(
      body: UpdatePricePlanArgs,
      pricePlanName: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling pricePlansPricePlanNamePut.',
        );
      }
      // verify required parameter 'pricePlanName' is not null or undefined
      if (pricePlanName === null || pricePlanName === undefined) {
        throw new RequiredError(
          'pricePlanName',
          'Required parameter pricePlanName was null or undefined when calling pricePlansPricePlanNamePut.',
        );
      }
      const localVarPath = `/price_plans/{price_plan_name}`.replace(
        `{${'price_plan_name'}}`,
        encodeURIComponent(String(pricePlanName)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'PUT', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        <any>'UpdatePricePlanArgs' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PricePlansApi - functional programming interface
 * @export
 */
export const PricePlansApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Fetch all price plans associated with a vendor.
     * @summary Get All Price Plans
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pricePlansGet(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PricePlan>> {
      const localVarFetchArgs =
        PricePlansApiFetchParamCreator(configuration).pricePlansGet(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Create Price Plan
     * @param {CreatePricePlanArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pricePlansPost(
      body: CreatePricePlanArgs,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<PricePlan> {
      const localVarFetchArgs = PricePlansApiFetchParamCreator(
        configuration,
      ).pricePlansPost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     * Delete an existing Price Plan. Plans which map to active Subscriptions must be replaced or removed before deletion can occur.
     * @summary Delete Price Plan
     * @param {string} pricePlanName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pricePlansPricePlanNameDelete(
      pricePlanName: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = PricePlansApiFetchParamCreator(
        configuration,
      ).pricePlansPricePlanNameDelete(pricePlanName, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     * Fetch an existing price plan.
     * @summary Get a Price Plan
     * @param {string} pricePlanName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pricePlansPricePlanNameGet(
      pricePlanName: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<PricePlan> {
      const localVarFetchArgs = PricePlansApiFetchParamCreator(
        configuration,
      ).pricePlansPricePlanNameGet(pricePlanName, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     * Update an existing price plan.
     * @summary Update a Price Plan
     * @param {UpdatePricePlanArgs} body
     * @param {string} pricePlanName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pricePlansPricePlanNamePut(
      body: UpdatePricePlanArgs,
      pricePlanName: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<PricePlan> {
      const localVarFetchArgs = PricePlansApiFetchParamCreator(
        configuration,
      ).pricePlansPricePlanNamePut(body, pricePlanName, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
  };
};

/**
 * PricePlansApi - factory interface
 * @export
 */
export const PricePlansApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Fetch all price plans associated with a vendor.
     * @summary Get All Price Plans
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pricePlansGet(options?: any) {
      return PricePlansApiFp(configuration).pricePlansGet(options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary Create Price Plan
     * @param {CreatePricePlanArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pricePlansPost(body: CreatePricePlanArgs, options?: any) {
      return PricePlansApiFp(configuration).pricePlansPost(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Delete an existing Price Plan. Plans which map to active Subscriptions must be replaced or removed before deletion can occur.
     * @summary Delete Price Plan
     * @param {string} pricePlanName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pricePlansPricePlanNameDelete(pricePlanName: string, options?: any) {
      return PricePlansApiFp(configuration).pricePlansPricePlanNameDelete(
        pricePlanName,
        options,
      )(fetch, basePath);
    },
    /**
     * Fetch an existing price plan.
     * @summary Get a Price Plan
     * @param {string} pricePlanName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pricePlansPricePlanNameGet(pricePlanName: string, options?: any) {
      return PricePlansApiFp(configuration).pricePlansPricePlanNameGet(
        pricePlanName,
        options,
      )(fetch, basePath);
    },
    /**
     * Update an existing price plan.
     * @summary Update a Price Plan
     * @param {UpdatePricePlanArgs} body
     * @param {string} pricePlanName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pricePlansPricePlanNamePut(
      body: UpdatePricePlanArgs,
      pricePlanName: string,
      options?: any,
    ) {
      return PricePlansApiFp(configuration).pricePlansPricePlanNamePut(
        body,
        pricePlanName,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * PricePlansApi - object-oriented interface
 * @export
 * @class PricePlansApi
 * @extends {BaseAPI}
 */
export class PricePlansApi extends BaseAPI {
  /**
   * Fetch all price plans associated with a vendor.
   * @summary Get All Price Plans
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PricePlansApi
   */
  public pricePlansGet(options?: any) {
    return PricePlansApiFp(this.configuration).pricePlansGet(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Create Price Plan
   * @param {CreatePricePlanArgs} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PricePlansApi
   */
  public pricePlansPost(body: CreatePricePlanArgs, options?: any) {
    return PricePlansApiFp(this.configuration).pricePlansPost(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Delete an existing Price Plan. Plans which map to active Subscriptions must be replaced or removed before deletion can occur.
   * @summary Delete Price Plan
   * @param {string} pricePlanName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PricePlansApi
   */
  public pricePlansPricePlanNameDelete(pricePlanName: string, options?: any) {
    return PricePlansApiFp(this.configuration).pricePlansPricePlanNameDelete(
      pricePlanName,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Fetch an existing price plan.
   * @summary Get a Price Plan
   * @param {string} pricePlanName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PricePlansApi
   */
  public pricePlansPricePlanNameGet(pricePlanName: string, options?: any) {
    return PricePlansApiFp(this.configuration).pricePlansPricePlanNameGet(
      pricePlanName,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Update an existing price plan.
   * @summary Update a Price Plan
   * @param {UpdatePricePlanArgs} body
   * @param {string} pricePlanName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PricePlansApi
   */
  public pricePlansPricePlanNamePut(
    body: UpdatePricePlanArgs,
    pricePlanName: string,
    options?: any,
  ) {
    return PricePlansApiFp(this.configuration).pricePlansPricePlanNamePut(
      body,
      pricePlanName,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * VendorsApi - fetch parameter creator
 * @export
 */
export const VendorsApiFetchParamCreator = function (
  _configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Delete Vendor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vendorsDelete(options: any = {}): FetchArgs {
      const localVarPath = `/vendors/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = {
        method: 'DELETE',
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch vendor data. The vendor used is based on the API Key provided as a part of auth.
     * @summary Get Vendor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vendorsGet(options: any = {}): FetchArgs {
      const localVarPath = `/vendors/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * **[ADMIN ONLY]** Create a new vendor.
     * @summary Create Vendor
     * @param {CreateVendorArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vendorsPost(body: CreateVendorArgs, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling vendorsPost.',
        );
      }
      const localVarPath = `/vendors/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        <any>'CreateVendorArgs' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update vendor metadata.
     * @summary Update Vendor
     * @param {UpdateVendorArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vendorsPut(body: UpdateVendorArgs, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling vendorsPut.',
        );
      }
      const localVarPath = `/vendors/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'PUT', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerApiKeyAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        <any>'UpdateVendorArgs' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * VendorsApi - functional programming interface
 * @export
 */
export const VendorsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete Vendor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vendorsDelete(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs =
        VendorsApiFetchParamCreator(configuration).vendorsDelete(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     * Fetch vendor data. The vendor used is based on the API Key provided as a part of auth.
     * @summary Get Vendor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vendorsGet(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Vendor> {
      const localVarFetchArgs =
        VendorsApiFetchParamCreator(configuration).vendorsGet(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     * **[ADMIN ONLY]** Create a new vendor.
     * @summary Create Vendor
     * @param {CreateVendorArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vendorsPost(
      body: CreateVendorArgs,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Vendor> {
      const localVarFetchArgs = VendorsApiFetchParamCreator(
        configuration,
      ).vendorsPost(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     * Update vendor metadata.
     * @summary Update Vendor
     * @param {UpdateVendorArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vendorsPut(
      body: UpdateVendorArgs,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Vendor> {
      const localVarFetchArgs = VendorsApiFetchParamCreator(
        configuration,
      ).vendorsPut(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        localVarFetchArgs.options.headers.Authorization = `Bearer ${
          configuration?.apiKey || 'UNSET'
        }`;
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
  };
};

/**
 * VendorsApi - factory interface
 * @export
 */
export const VendorsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @summary Delete Vendor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vendorsDelete(options?: any) {
      return VendorsApiFp(configuration).vendorsDelete(options)(
        fetch,
        basePath,
      );
    },
    /**
     * Fetch vendor data. The vendor used is based on the API Key provided as a part of auth.
     * @summary Get Vendor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vendorsGet(options?: any) {
      return VendorsApiFp(configuration).vendorsGet(options)(fetch, basePath);
    },
    /**
     * **[ADMIN ONLY]** Create a new vendor.
     * @summary Create Vendor
     * @param {CreateVendorArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vendorsPost(body: CreateVendorArgs, options?: any) {
      return VendorsApiFp(configuration).vendorsPost(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Update vendor metadata.
     * @summary Update Vendor
     * @param {UpdateVendorArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vendorsPut(body: UpdateVendorArgs, options?: any) {
      return VendorsApiFp(configuration).vendorsPut(body, options)(
        fetch,
        basePath,
      );
    },
  };
};

/**
 * VendorsApi - object-oriented interface
 * @export
 * @class VendorsApi
 * @extends {BaseAPI}
 */
export class VendorsApi extends BaseAPI {
  /**
   *
   * @summary Delete Vendor
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VendorsApi
   */
  public vendorsDelete(options?: any) {
    return VendorsApiFp(this.configuration).vendorsDelete(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Fetch vendor data. The vendor used is based on the API Key provided as a part of auth.
   * @summary Get Vendor
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VendorsApi
   */
  public vendorsGet(options?: any) {
    return VendorsApiFp(this.configuration).vendorsGet(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * **[ADMIN ONLY]** Create a new vendor.
   * @summary Create Vendor
   * @param {CreateVendorArgs} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VendorsApi
   */
  public vendorsPost(body: CreateVendorArgs, options?: any) {
    return VendorsApiFp(this.configuration).vendorsPost(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Update vendor metadata.
   * @summary Update Vendor
   * @param {UpdateVendorArgs} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VendorsApi
   */
  public vendorsPut(body: UpdateVendorArgs, options?: any) {
    return VendorsApiFp(this.configuration).vendorsPut(body, options)(
      this.fetch,
      this.basePath,
    );
  }
}
